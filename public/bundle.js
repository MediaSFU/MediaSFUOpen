(function () {
  function r(e, n, t) {
    function o(i, f) {
      if (!n[i]) {
        if (!e[i]) {
          var c = "function" == typeof require && require;
          if (!f && c) return c(i, !0);
          if (u) return u(i, !0);
          var a = new Error("Cannot find module '" + i + "'");
          throw ((a.code = "MODULE_NOT_FOUND"), a);
        }
        var p = (n[i] = { exports: {} });
        e[i][0].call(
          p.exports,
          function (r) {
            var n = e[i][1][r];
            return o(n || r);
          },
          p,
          p.exports,
          r,
          e,
          n,
          t
        );
      }
      return n[i].exports;
    }
    for (
      var u = "function" == typeof require && require, i = 0;
      i < t.length;
      i++
    )
      o(t[i]);
    return o;
  }
  return r;
})()(
  {
    1: [
      function (require, module, exports) {
        /**
         * Expose `Emitter`.
         */

        exports.Emitter = Emitter;

        /**
         * Initialize a new `Emitter`.
         *
         * @api public
         */

        function Emitter(obj) {
          if (obj) return mixin(obj);
        }

        /**
         * Mixin the emitter properties.
         *
         * @param {Object} obj
         * @return {Object}
         * @api private
         */

        function mixin(obj) {
          for (var key in Emitter.prototype) {
            obj[key] = Emitter.prototype[key];
          }
          return obj;
        }

        /**
         * Listen on the given `event` with `fn`.
         *
         * @param {String} event
         * @param {Function} fn
         * @return {Emitter}
         * @api public
         */

        Emitter.prototype.on = Emitter.prototype.addEventListener = function (
          event,
          fn
        ) {
          this._callbacks = this._callbacks || {};
          (this._callbacks["$" + event] =
            this._callbacks["$" + event] || []).push(fn);
          return this;
        };

        /**
         * Adds an `event` listener that will be invoked a single
         * time then automatically removed.
         *
         * @param {String} event
         * @param {Function} fn
         * @return {Emitter}
         * @api public
         */

        Emitter.prototype.once = function (event, fn) {
          function on() {
            this.off(event, on);
            fn.apply(this, arguments);
          }

          on.fn = fn;
          this.on(event, on);
          return this;
        };

        /**
         * Remove the given callback for `event` or all
         * registered callbacks.
         *
         * @param {String} event
         * @param {Function} fn
         * @return {Emitter}
         * @api public
         */

        Emitter.prototype.off =
          Emitter.prototype.removeListener =
          Emitter.prototype.removeAllListeners =
          Emitter.prototype.removeEventListener =
            function (event, fn) {
              this._callbacks = this._callbacks || {};

              // all
              if (0 == arguments.length) {
                this._callbacks = {};
                return this;
              }

              // specific event
              var callbacks = this._callbacks["$" + event];
              if (!callbacks) return this;

              // remove all handlers
              if (1 == arguments.length) {
                delete this._callbacks["$" + event];
                return this;
              }

              // remove specific handler
              var cb;
              for (var i = 0; i < callbacks.length; i++) {
                cb = callbacks[i];
                if (cb === fn || cb.fn === fn) {
                  callbacks.splice(i, 1);
                  break;
                }
              }

              // Remove event specific arrays for event types that no
              // one is subscribed for to avoid memory leak.
              if (callbacks.length === 0) {
                delete this._callbacks["$" + event];
              }

              return this;
            };

        /**
         * Emit `event` with the given args.
         *
         * @param {String} event
         * @param {Mixed} ...
         * @return {Emitter}
         */

        Emitter.prototype.emit = function (event) {
          this._callbacks = this._callbacks || {};

          var args = new Array(arguments.length - 1),
            callbacks = this._callbacks["$" + event];

          for (var i = 1; i < arguments.length; i++) {
            args[i - 1] = arguments[i];
          }

          if (callbacks) {
            callbacks = callbacks.slice(0);
            for (var i = 0, len = callbacks.length; i < len; ++i) {
              callbacks[i].apply(this, args);
            }
          }

          return this;
        };

        // alias used for reserved events (protected method)
        Emitter.prototype.emitReserved = Emitter.prototype.emit;

        /**
         * Return array of callbacks for `event`.
         *
         * @param {String} event
         * @return {Array}
         * @api public
         */

        Emitter.prototype.listeners = function (event) {
          this._callbacks = this._callbacks || {};
          return this._callbacks["$" + event] || [];
        };

        /**
         * Check if this emitter has `event` handlers.
         *
         * @param {String} event
         * @return {Boolean}
         * @api public
         */

        Emitter.prototype.hasListeners = function (event) {
          return !!this.listeners(event).length;
        };
      },
      {},
    ],
    2: [
      function (require, module, exports) {
        "use strict";
        Object.defineProperty(exports, "__esModule", { value: true });
        exports.Logger = void 0;
        const debug_1 = require("debug");
        const LIB_NAME = "awaitqueue";
        class Logger {
          constructor(prefix) {
            if (prefix) {
              this._debug = (0, debug_1.default)(`${LIB_NAME}:${prefix}`);
              this._warn = (0, debug_1.default)(`${LIB_NAME}:WARN:${prefix}`);
              this._error = (0, debug_1.default)(`${LIB_NAME}:ERROR:${prefix}`);
            } else {
              this._debug = (0, debug_1.default)(LIB_NAME);
              this._warn = (0, debug_1.default)(`${LIB_NAME}:WARN`);
              this._error = (0, debug_1.default)(`${LIB_NAME}:ERROR`);
            }
            /* eslint-disable no-console */
            this._debug.log = console.info.bind(console);
            this._warn.log = console.warn.bind(console);
            this._error.log = console.error.bind(console);
            /* eslint-enable no-console */
          }
          get debug() {
            return this._debug;
          }
          get warn() {
            return this._warn;
          }
          get error() {
            return this._error;
          }
        }
        exports.Logger = Logger;
      },
      { debug: 4 },
    ],
    3: [
      function (require, module, exports) {
        "use strict";
        Object.defineProperty(exports, "__esModule", { value: true });
        exports.AwaitQueue =
          exports.AwaitQueueRemovedTaskError =
          exports.AwaitQueueStoppedError =
            void 0;
        const Logger_1 = require("./Logger");
        const logger = new Logger_1.Logger();
        /**
         * Custom Error derived class used to reject pending tasks once stop() method
         * has been called.
         */
        class AwaitQueueStoppedError extends Error {
          constructor(message) {
            super(message ?? "AwaitQueue stopped");
            this.name = "AwaitQueueStoppedError";
            // @ts-ignore
            if (typeof Error.captureStackTrace === "function") {
              // @ts-ignore
              Error.captureStackTrace(this, AwaitQueueStoppedError);
            }
          }
        }
        exports.AwaitQueueStoppedError = AwaitQueueStoppedError;
        /**
         * Custom Error derived class used to reject pending tasks once removeTask()
         * method has been called.
         */
        class AwaitQueueRemovedTaskError extends Error {
          constructor(message) {
            super(message ?? "AwaitQueue task removed");
            this.name = "AwaitQueueRemovedTaskError";
            // @ts-ignore
            if (typeof Error.captureStackTrace === "function") {
              // @ts-ignore
              Error.captureStackTrace(this, AwaitQueueRemovedTaskError);
            }
          }
        }
        exports.AwaitQueueRemovedTaskError = AwaitQueueRemovedTaskError;
        class AwaitQueue {
          constructor() {
            // Queue of pending tasks (map of PendingTasks indexed by id).
            this.pendingTasks = new Map();
            // Incrementing PendingTask id.
            this.nextTaskId = 0;
            // Whether stop() method is stopping all pending tasks.
            this.stopping = false;
          }
          get size() {
            return this.pendingTasks.size;
          }
          async push(task, name) {
            name = name ?? task.name;
            logger.debug(`push() [name:${name}]`);
            if (typeof task !== "function") {
              throw new TypeError("given task is not a function");
            }
            if (name) {
              try {
                Object.defineProperty(task, "name", { value: name });
              } catch (error) {}
            }
            return new Promise((resolve, reject) => {
              const pendingTask = {
                id: this.nextTaskId++,
                task: task,
                name: name,
                enqueuedAt: Date.now(),
                executedAt: undefined,
                completed: false,
                resolve: (result) => {
                  // pendingTask.resolve() can only be called in execute() method. Since
                  // resolve() was called it means that the task successfully completed.
                  // However the task may have been stopped before it completed (via
                  // stop() or remove()) so its completed flag was already set. If this
                  // is the case, abort here since next task (if any) is already being
                  // executed.
                  if (pendingTask.completed) {
                    return;
                  }
                  pendingTask.completed = true;
                  // Remove the task from the queue.
                  this.pendingTasks.delete(pendingTask.id);
                  logger.debug(`resolving task [name:${pendingTask.name}]`);
                  // Resolve the task with the obtained result.
                  resolve(result);
                  // Execute the next pending task (if any).
                  const [nextPendingTask] = this.pendingTasks.values();
                  // NOTE: During the resolve() callback the user app may have interacted
                  // with the queue. For instance, the app may have pushed a task while
                  // the queue was empty so such a task is already being executed. If so,
                  // don't execute it twice.
                  if (nextPendingTask && !nextPendingTask.executedAt) {
                    void this.execute(nextPendingTask);
                  }
                },
                reject: (error) => {
                  // pendingTask.reject() can be called within execute() method if the
                  // task completed with error. However it may have also been called in
                  // stop() or remove() methods (before or while being executed) so its
                  // completed flag was already set. If so, abort here since next task
                  // (if any) is already being executed.
                  if (pendingTask.completed) {
                    return;
                  }
                  pendingTask.completed = true;
                  // Remove the task from the queue.
                  this.pendingTasks.delete(pendingTask.id);
                  logger.debug(
                    `rejecting task [name:${pendingTask.name}]: %s`,
                    String(error)
                  );
                  // Reject the task with the obtained error.
                  reject(error);
                  // Execute the next pending task (if any) unless stop() is running.
                  if (!this.stopping) {
                    const [nextPendingTask] = this.pendingTasks.values();
                    // NOTE: During the reject() callback the user app may have interacted
                    // with the queue. For instance, the app may have pushed a task while
                    // the queue was empty so such a task is already being executed. If so,
                    // don't execute it twice.
                    if (nextPendingTask && !nextPendingTask.executedAt) {
                      void this.execute(nextPendingTask);
                    }
                  }
                },
              };
              // Append task to the queue.
              this.pendingTasks.set(pendingTask.id, pendingTask);
              // And execute it if this is the only task in the queue.
              if (this.pendingTasks.size === 1) {
                void this.execute(pendingTask);
              }
            });
          }
          stop() {
            logger.debug("stop()");
            this.stopping = true;
            for (const pendingTask of this.pendingTasks.values()) {
              logger.debug(`stop() | stopping task [name:${pendingTask.name}]`);
              pendingTask.reject(new AwaitQueueStoppedError());
            }
            this.stopping = false;
          }
          remove(taskIdx) {
            logger.debug(`remove() [taskIdx:${taskIdx}]`);
            const pendingTask = Array.from(this.pendingTasks.values())[taskIdx];
            if (!pendingTask) {
              logger.debug(
                `stop() | no task with given idx [taskIdx:${taskIdx}]`
              );
              return;
            }
            pendingTask.reject(new AwaitQueueRemovedTaskError());
          }
          dump() {
            const now = Date.now();
            let idx = 0;
            return Array.from(this.pendingTasks.values()).map(
              (pendingTask) => ({
                idx: idx++,
                task: pendingTask.task,
                name: pendingTask.name,
                enqueuedTime: pendingTask.executedAt
                  ? pendingTask.executedAt - pendingTask.enqueuedAt
                  : now - pendingTask.enqueuedAt,
                executionTime: pendingTask.executedAt
                  ? now - pendingTask.executedAt
                  : 0,
              })
            );
          }
          async execute(pendingTask) {
            logger.debug(`execute() [name:${pendingTask.name}]`);
            if (pendingTask.executedAt) {
              throw new Error("task already being executed");
            }
            pendingTask.executedAt = Date.now();
            try {
              const result = await pendingTask.task();
              // Resolve the task with its resolved result (if any).
              pendingTask.resolve(result);
            } catch (error) {
              // Reject the task with its rejected error.
              pendingTask.reject(error);
            }
          }
        }
        exports.AwaitQueue = AwaitQueue;
      },
      { "./Logger": 2 },
    ],
    4: [
      function (require, module, exports) {
        (function (process) {
          (function () {
            /* eslint-env browser */

            /**
             * This is the web browser implementation of `debug()`.
             */

            exports.formatArgs = formatArgs;
            exports.save = save;
            exports.load = load;
            exports.useColors = useColors;
            exports.storage = localstorage();
            exports.destroy = (() => {
              let warned = false;

              return () => {
                if (!warned) {
                  warned = true;
                  console.warn(
                    "Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`."
                  );
                }
              };
            })();

            /**
             * Colors.
             */

            exports.colors = [
              "#0000CC",
              "#0000FF",
              "#0033CC",
              "#0033FF",
              "#0066CC",
              "#0066FF",
              "#0099CC",
              "#0099FF",
              "#00CC00",
              "#00CC33",
              "#00CC66",
              "#00CC99",
              "#00CCCC",
              "#00CCFF",
              "#3300CC",
              "#3300FF",
              "#3333CC",
              "#3333FF",
              "#3366CC",
              "#3366FF",
              "#3399CC",
              "#3399FF",
              "#33CC00",
              "#33CC33",
              "#33CC66",
              "#33CC99",
              "#33CCCC",
              "#33CCFF",
              "#6600CC",
              "#6600FF",
              "#6633CC",
              "#6633FF",
              "#66CC00",
              "#66CC33",
              "#9900CC",
              "#9900FF",
              "#9933CC",
              "#9933FF",
              "#99CC00",
              "#99CC33",
              "#CC0000",
              "#CC0033",
              "#CC0066",
              "#CC0099",
              "#CC00CC",
              "#CC00FF",
              "#CC3300",
              "#CC3333",
              "#CC3366",
              "#CC3399",
              "#CC33CC",
              "#CC33FF",
              "#CC6600",
              "#CC6633",
              "#CC9900",
              "#CC9933",
              "#CCCC00",
              "#CCCC33",
              "#FF0000",
              "#FF0033",
              "#FF0066",
              "#FF0099",
              "#FF00CC",
              "#FF00FF",
              "#FF3300",
              "#FF3333",
              "#FF3366",
              "#FF3399",
              "#FF33CC",
              "#FF33FF",
              "#FF6600",
              "#FF6633",
              "#FF9900",
              "#FF9933",
              "#FFCC00",
              "#FFCC33",
            ];

            /**
             * Currently only WebKit-based Web Inspectors, Firefox >= v31,
             * and the Firebug extension (any Firefox version) are known
             * to support "%c" CSS customizations.
             *
             * TODO: add a `localStorage` variable to explicitly enable/disable colors
             */

            // eslint-disable-next-line complexity
            function useColors() {
              // NB: In an Electron preload script, document will be defined but not fully
              // initialized. Since we know we're in Chrome, we'll just detect this case
              // explicitly
              if (
                typeof window !== "undefined" &&
                window.process &&
                (window.process.type === "renderer" || window.process.__nwjs)
              ) {
                return true;
              }

              // Internet Explorer and Edge do not support colors.
              if (
                typeof navigator !== "undefined" &&
                navigator.userAgent &&
                navigator.userAgent.toLowerCase().match(/(edge|trident)\/(\d+)/)
              ) {
                return false;
              }

              // Is webkit? http://stackoverflow.com/a/16459606/376773
              // document is undefined in react-native: https://github.com/facebook/react-native/pull/1632
              return (
                (typeof document !== "undefined" &&
                  document.documentElement &&
                  document.documentElement.style &&
                  document.documentElement.style.WebkitAppearance) ||
                // Is firebug? http://stackoverflow.com/a/398120/376773
                (typeof window !== "undefined" &&
                  window.console &&
                  (window.console.firebug ||
                    (window.console.exception && window.console.table))) ||
                // Is firefox >= v31?
                // https://developer.mozilla.org/en-US/docs/Tools/Web_Console#Styling_messages
                (typeof navigator !== "undefined" &&
                  navigator.userAgent &&
                  navigator.userAgent.toLowerCase().match(/firefox\/(\d+)/) &&
                  parseInt(RegExp.$1, 10) >= 31) ||
                // Double check webkit in userAgent just in case we are in a worker
                (typeof navigator !== "undefined" &&
                  navigator.userAgent &&
                  navigator.userAgent.toLowerCase().match(/applewebkit\/(\d+)/))
              );
            }

            /**
             * Colorize log arguments if enabled.
             *
             * @api public
             */

            function formatArgs(args) {
              args[0] =
                (this.useColors ? "%c" : "") +
                this.namespace +
                (this.useColors ? " %c" : " ") +
                args[0] +
                (this.useColors ? "%c " : " ") +
                "+" +
                module.exports.humanize(this.diff);

              if (!this.useColors) {
                return;
              }

              const c = "color: " + this.color;
              args.splice(1, 0, c, "color: inherit");

              // The final "%c" is somewhat tricky, because there could be other
              // arguments passed either before or after the %c, so we need to
              // figure out the correct index to insert the CSS into
              let index = 0;
              let lastC = 0;
              args[0].replace(/%[a-zA-Z%]/g, (match) => {
                if (match === "%%") {
                  return;
                }
                index++;
                if (match === "%c") {
                  // We only are interested in the *last* %c
                  // (the user may have provided their own)
                  lastC = index;
                }
              });

              args.splice(lastC, 0, c);
            }

            /**
             * Invokes `console.debug()` when available.
             * No-op when `console.debug` is not a "function".
             * If `console.debug` is not available, falls back
             * to `console.log`.
             *
             * @api public
             */
            exports.log = console.debug || console.log || (() => {});

            /**
             * Save `namespaces`.
             *
             * @param {String} namespaces
             * @api private
             */
            function save(namespaces) {
              try {
                if (namespaces) {
                  exports.storage.setItem("debug", namespaces);
                } else {
                  exports.storage.removeItem("debug");
                }
              } catch (error) {
                // Swallow
                // XXX (@Qix-) should we be logging these?
              }
            }

            /**
             * Load `namespaces`.
             *
             * @return {String} returns the previously persisted debug modes
             * @api private
             */
            function load() {
              let r;
              try {
                r = exports.storage.getItem("debug");
              } catch (error) {
                // Swallow
                // XXX (@Qix-) should we be logging these?
              }

              // If debug isn't set in LS, and we're in Electron, try to load $DEBUG
              if (!r && typeof process !== "undefined" && "env" in process) {
                r = process.env.DEBUG;
              }

              return r;
            }

            /**
             * Localstorage attempts to return the localstorage.
             *
             * This is necessary because safari throws
             * when a user disables cookies/localstorage
             * and you attempt to access it.
             *
             * @return {LocalStorage}
             * @api private
             */

            function localstorage() {
              try {
                // TVMLKit (Apple TV JS Runtime) does not have a window object, just localStorage in the global context
                // The Browser also has localStorage in the global context.
                return localStorage;
              } catch (error) {
                // Swallow
                // XXX (@Qix-) should we be logging these?
              }
            }

            module.exports = require("./common")(exports);

            const { formatters } = module.exports;

            /**
             * Map %j to `JSON.stringify()`, since no Web Inspectors do that by default.
             */

            formatters.j = function (v) {
              try {
                return JSON.stringify(v);
              } catch (error) {
                return "[UnexpectedJSONParseError]: " + error.message;
              }
            };
          }).call(this);
        }).call(this, require("_process"));
      },
      { "./common": 5, _process: 76 },
    ],
    5: [
      function (require, module, exports) {
        /**
         * This is the common logic for both the Node.js and web browser
         * implementations of `debug()`.
         */

        function setup(env) {
          createDebug.debug = createDebug;
          createDebug.default = createDebug;
          createDebug.coerce = coerce;
          createDebug.disable = disable;
          createDebug.enable = enable;
          createDebug.enabled = enabled;
          createDebug.humanize = require("ms");
          createDebug.destroy = destroy;

          Object.keys(env).forEach((key) => {
            createDebug[key] = env[key];
          });

          /**
           * The currently active debug mode names, and names to skip.
           */

          createDebug.names = [];
          createDebug.skips = [];

          /**
           * Map of special "%n" handling functions, for the debug "format" argument.
           *
           * Valid key names are a single, lower or upper-case letter, i.e. "n" and "N".
           */
          createDebug.formatters = {};

          /**
           * Selects a color for a debug namespace
           * @param {String} namespace The namespace string for the debug instance to be colored
           * @return {Number|String} An ANSI color code for the given namespace
           * @api private
           */
          function selectColor(namespace) {
            let hash = 0;

            for (let i = 0; i < namespace.length; i++) {
              hash = (hash << 5) - hash + namespace.charCodeAt(i);
              hash |= 0; // Convert to 32bit integer
            }

            return createDebug.colors[
              Math.abs(hash) % createDebug.colors.length
            ];
          }
          createDebug.selectColor = selectColor;

          /**
           * Create a debugger with the given `namespace`.
           *
           * @param {String} namespace
           * @return {Function}
           * @api public
           */
          function createDebug(namespace) {
            let prevTime;
            let enableOverride = null;
            let namespacesCache;
            let enabledCache;

            function debug(...args) {
              // Disabled?
              if (!debug.enabled) {
                return;
              }

              const self = debug;

              // Set `diff` timestamp
              const curr = Number(new Date());
              const ms = curr - (prevTime || curr);
              self.diff = ms;
              self.prev = prevTime;
              self.curr = curr;
              prevTime = curr;

              args[0] = createDebug.coerce(args[0]);

              if (typeof args[0] !== "string") {
                // Anything else let's inspect with %O
                args.unshift("%O");
              }

              // Apply any `formatters` transformations
              let index = 0;
              args[0] = args[0].replace(/%([a-zA-Z%])/g, (match, format) => {
                // If we encounter an escaped % then don't increase the array index
                if (match === "%%") {
                  return "%";
                }
                index++;
                const formatter = createDebug.formatters[format];
                if (typeof formatter === "function") {
                  const val = args[index];
                  match = formatter.call(self, val);

                  // Now we need to remove `args[index]` since it's inlined in the `format`
                  args.splice(index, 1);
                  index--;
                }
                return match;
              });

              // Apply env-specific formatting (colors, etc.)
              createDebug.formatArgs.call(self, args);

              const logFn = self.log || createDebug.log;
              logFn.apply(self, args);
            }

            debug.namespace = namespace;
            debug.useColors = createDebug.useColors();
            debug.color = createDebug.selectColor(namespace);
            debug.extend = extend;
            debug.destroy = createDebug.destroy; // XXX Temporary. Will be removed in the next major release.

            Object.defineProperty(debug, "enabled", {
              enumerable: true,
              configurable: false,
              get: () => {
                if (enableOverride !== null) {
                  return enableOverride;
                }
                if (namespacesCache !== createDebug.namespaces) {
                  namespacesCache = createDebug.namespaces;
                  enabledCache = createDebug.enabled(namespace);
                }

                return enabledCache;
              },
              set: (v) => {
                enableOverride = v;
              },
            });

            // Env-specific initialization logic for debug instances
            if (typeof createDebug.init === "function") {
              createDebug.init(debug);
            }

            return debug;
          }

          function extend(namespace, delimiter) {
            const newDebug = createDebug(
              this.namespace +
                (typeof delimiter === "undefined" ? ":" : delimiter) +
                namespace
            );
            newDebug.log = this.log;
            return newDebug;
          }

          /**
           * Enables a debug mode by namespaces. This can include modes
           * separated by a colon and wildcards.
           *
           * @param {String} namespaces
           * @api public
           */
          function enable(namespaces) {
            createDebug.save(namespaces);
            createDebug.namespaces = namespaces;

            createDebug.names = [];
            createDebug.skips = [];

            let i;
            const split = (
              typeof namespaces === "string" ? namespaces : ""
            ).split(/[\s,]+/);
            const len = split.length;

            for (i = 0; i < len; i++) {
              if (!split[i]) {
                // ignore empty strings
                continue;
              }

              namespaces = split[i].replace(/\*/g, ".*?");

              if (namespaces[0] === "-") {
                createDebug.skips.push(
                  new RegExp("^" + namespaces.slice(1) + "$")
                );
              } else {
                createDebug.names.push(new RegExp("^" + namespaces + "$"));
              }
            }
          }

          /**
           * Disable debug output.
           *
           * @return {String} namespaces
           * @api public
           */
          function disable() {
            const namespaces = [
              ...createDebug.names.map(toNamespace),
              ...createDebug.skips
                .map(toNamespace)
                .map((namespace) => "-" + namespace),
            ].join(",");
            createDebug.enable("");
            return namespaces;
          }

          /**
           * Returns true if the given mode name is enabled, false otherwise.
           *
           * @param {String} name
           * @return {Boolean}
           * @api public
           */
          function enabled(name) {
            if (name[name.length - 1] === "*") {
              return true;
            }

            let i;
            let len;

            for (i = 0, len = createDebug.skips.length; i < len; i++) {
              if (createDebug.skips[i].test(name)) {
                return false;
              }
            }

            for (i = 0, len = createDebug.names.length; i < len; i++) {
              if (createDebug.names[i].test(name)) {
                return true;
              }
            }

            return false;
          }

          /**
           * Convert regexp to namespace
           *
           * @param {RegExp} regxep
           * @return {String} namespace
           * @api private
           */
          function toNamespace(regexp) {
            return regexp
              .toString()
              .substring(2, regexp.toString().length - 2)
              .replace(/\.\*\?$/, "*");
          }

          /**
           * Coerce `val`.
           *
           * @param {Mixed} val
           * @return {Mixed}
           * @api private
           */
          function coerce(val) {
            if (val instanceof Error) {
              return val.stack || val.message;
            }
            return val;
          }

          /**
           * XXX DO NOT USE. This is a temporary stub function.
           * XXX It WILL be removed in the next major release.
           */
          function destroy() {
            console.warn(
              "Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`."
            );
          }

          createDebug.enable(createDebug.load());

          return createDebug;
        }

        module.exports = setup;
      },
      { ms: 6 },
    ],
    6: [
      function (require, module, exports) {
        /**
         * Helpers.
         */

        var s = 1000;
        var m = s * 60;
        var h = m * 60;
        var d = h * 24;
        var w = d * 7;
        var y = d * 365.25;

        /**
         * Parse or format the given `val`.
         *
         * Options:
         *
         *  - `long` verbose formatting [false]
         *
         * @param {String|Number} val
         * @param {Object} [options]
         * @throws {Error} throw an error if val is not a non-empty string or a number
         * @return {String|Number}
         * @api public
         */

        module.exports = function (val, options) {
          options = options || {};
          var type = typeof val;
          if (type === "string" && val.length > 0) {
            return parse(val);
          } else if (type === "number" && isFinite(val)) {
            return options.long ? fmtLong(val) : fmtShort(val);
          }
          throw new Error(
            "val is not a non-empty string or a valid number. val=" +
              JSON.stringify(val)
          );
        };

        /**
         * Parse the given `str` and return milliseconds.
         *
         * @param {String} str
         * @return {Number}
         * @api private
         */

        function parse(str) {
          str = String(str);
          if (str.length > 100) {
            return;
          }
          var match =
            /^(-?(?:\d+)?\.?\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|weeks?|w|years?|yrs?|y)?$/i.exec(
              str
            );
          if (!match) {
            return;
          }
          var n = parseFloat(match[1]);
          var type = (match[2] || "ms").toLowerCase();
          switch (type) {
            case "years":
            case "year":
            case "yrs":
            case "yr":
            case "y":
              return n * y;
            case "weeks":
            case "week":
            case "w":
              return n * w;
            case "days":
            case "day":
            case "d":
              return n * d;
            case "hours":
            case "hour":
            case "hrs":
            case "hr":
            case "h":
              return n * h;
            case "minutes":
            case "minute":
            case "mins":
            case "min":
            case "m":
              return n * m;
            case "seconds":
            case "second":
            case "secs":
            case "sec":
            case "s":
              return n * s;
            case "milliseconds":
            case "millisecond":
            case "msecs":
            case "msec":
            case "ms":
              return n;
            default:
              return undefined;
          }
        }

        /**
         * Short format for `ms`.
         *
         * @param {Number} ms
         * @return {String}
         * @api private
         */

        function fmtShort(ms) {
          var msAbs = Math.abs(ms);
          if (msAbs >= d) {
            return Math.round(ms / d) + "d";
          }
          if (msAbs >= h) {
            return Math.round(ms / h) + "h";
          }
          if (msAbs >= m) {
            return Math.round(ms / m) + "m";
          }
          if (msAbs >= s) {
            return Math.round(ms / s) + "s";
          }
          return ms + "ms";
        }

        /**
         * Long format for `ms`.
         *
         * @param {Number} ms
         * @return {String}
         * @api private
         */

        function fmtLong(ms) {
          var msAbs = Math.abs(ms);
          if (msAbs >= d) {
            return plural(ms, msAbs, d, "day");
          }
          if (msAbs >= h) {
            return plural(ms, msAbs, h, "hour");
          }
          if (msAbs >= m) {
            return plural(ms, msAbs, m, "minute");
          }
          if (msAbs >= s) {
            return plural(ms, msAbs, s, "second");
          }
          return ms + " ms";
        }

        /**
         * Pluralization helper.
         */

        function plural(ms, msAbs, n, name) {
          var isPlural = msAbs >= n * 1.5;
          return Math.round(ms / n) + " " + name + (isPlural ? "s" : "");
        }
      },
      {},
    ],
    7: [
      function (require, module, exports) {
        "use strict";

        exports.byteLength = byteLength;
        exports.toByteArray = toByteArray;
        exports.fromByteArray = fromByteArray;

        var lookup = [];
        var revLookup = [];
        var Arr = typeof Uint8Array !== "undefined" ? Uint8Array : Array;

        var code =
          "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
        for (var i = 0, len = code.length; i < len; ++i) {
          lookup[i] = code[i];
          revLookup[code.charCodeAt(i)] = i;
        }

        // Support decoding URL-safe base64 strings, as Node.js does.
        // See: https://en.wikipedia.org/wiki/Base64#URL_applications
        revLookup["-".charCodeAt(0)] = 62;
        revLookup["_".charCodeAt(0)] = 63;

        function getLens(b64) {
          var len = b64.length;

          if (len % 4 > 0) {
            throw new Error("Invalid string. Length must be a multiple of 4");
          }

          // Trim off extra bytes after placeholder bytes are found
          // See: https://github.com/beatgammit/base64-js/issues/42
          var validLen = b64.indexOf("=");
          if (validLen === -1) validLen = len;

          var placeHoldersLen = validLen === len ? 0 : 4 - (validLen % 4);

          return [validLen, placeHoldersLen];
        }

        // base64 is 4/3 + up to two characters of the original data
        function byteLength(b64) {
          var lens = getLens(b64);
          var validLen = lens[0];
          var placeHoldersLen = lens[1];
          return ((validLen + placeHoldersLen) * 3) / 4 - placeHoldersLen;
        }

        function _byteLength(b64, validLen, placeHoldersLen) {
          return ((validLen + placeHoldersLen) * 3) / 4 - placeHoldersLen;
        }

        function toByteArray(b64) {
          var tmp;
          var lens = getLens(b64);
          var validLen = lens[0];
          var placeHoldersLen = lens[1];

          var arr = new Arr(_byteLength(b64, validLen, placeHoldersLen));

          var curByte = 0;

          // if there are placeholders, only get up to the last complete 4 chars
          var len = placeHoldersLen > 0 ? validLen - 4 : validLen;

          var i;
          for (i = 0; i < len; i += 4) {
            tmp =
              (revLookup[b64.charCodeAt(i)] << 18) |
              (revLookup[b64.charCodeAt(i + 1)] << 12) |
              (revLookup[b64.charCodeAt(i + 2)] << 6) |
              revLookup[b64.charCodeAt(i + 3)];
            arr[curByte++] = (tmp >> 16) & 0xff;
            arr[curByte++] = (tmp >> 8) & 0xff;
            arr[curByte++] = tmp & 0xff;
          }

          if (placeHoldersLen === 2) {
            tmp =
              (revLookup[b64.charCodeAt(i)] << 2) |
              (revLookup[b64.charCodeAt(i + 1)] >> 4);
            arr[curByte++] = tmp & 0xff;
          }

          if (placeHoldersLen === 1) {
            tmp =
              (revLookup[b64.charCodeAt(i)] << 10) |
              (revLookup[b64.charCodeAt(i + 1)] << 4) |
              (revLookup[b64.charCodeAt(i + 2)] >> 2);
            arr[curByte++] = (tmp >> 8) & 0xff;
            arr[curByte++] = tmp & 0xff;
          }

          return arr;
        }

        function tripletToBase64(num) {
          return (
            lookup[(num >> 18) & 0x3f] +
            lookup[(num >> 12) & 0x3f] +
            lookup[(num >> 6) & 0x3f] +
            lookup[num & 0x3f]
          );
        }

        function encodeChunk(uint8, start, end) {
          var tmp;
          var output = [];
          for (var i = start; i < end; i += 3) {
            tmp =
              ((uint8[i] << 16) & 0xff0000) +
              ((uint8[i + 1] << 8) & 0xff00) +
              (uint8[i + 2] & 0xff);
            output.push(tripletToBase64(tmp));
          }
          return output.join("");
        }

        function fromByteArray(uint8) {
          var tmp;
          var len = uint8.length;
          var extraBytes = len % 3; // if we have 1 byte left, pad 2 bytes
          var parts = [];
          var maxChunkLength = 16383; // must be multiple of 3

          // go through the array every three bytes, we'll deal with trailing stuff later
          for (
            var i = 0, len2 = len - extraBytes;
            i < len2;
            i += maxChunkLength
          ) {
            parts.push(
              encodeChunk(
                uint8,
                i,
                i + maxChunkLength > len2 ? len2 : i + maxChunkLength
              )
            );
          }

          // pad the end with zeros, but make sure to not forget the extra bytes
          if (extraBytes === 1) {
            tmp = uint8[len - 1];
            parts.push(lookup[tmp >> 2] + lookup[(tmp << 4) & 0x3f] + "==");
          } else if (extraBytes === 2) {
            tmp = (uint8[len - 2] << 8) + uint8[len - 1];
            parts.push(
              lookup[tmp >> 10] +
                lookup[(tmp >> 4) & 0x3f] +
                lookup[(tmp << 2) & 0x3f] +
                "="
            );
          }

          return parts.join("");
        }
      },
      {},
    ],
    8: [
      function (require, module, exports) {
        (function (Buffer) {
          (function () {
            /*!
             * The buffer module from node.js, for the browser.
             *
             * @author   Feross Aboukhadijeh <https://feross.org>
             * @license  MIT
             */
            /* eslint-disable no-proto */

            "use strict";

            var base64 = require("base64-js");
            var ieee754 = require("ieee754");

            exports.Buffer = Buffer;
            exports.SlowBuffer = SlowBuffer;
            exports.INSPECT_MAX_BYTES = 50;

            var K_MAX_LENGTH = 0x7fffffff;
            exports.kMaxLength = K_MAX_LENGTH;

            /**
             * If `Buffer.TYPED_ARRAY_SUPPORT`:
             *   === true    Use Uint8Array implementation (fastest)
             *   === false   Print warning and recommend using `buffer` v4.x which has an Object
             *               implementation (most compatible, even IE6)
             *
             * Browsers that support typed arrays are IE 10+, Firefox 4+, Chrome 7+, Safari 5.1+,
             * Opera 11.6+, iOS 4.2+.
             *
             * We report that the browser does not support typed arrays if the are not subclassable
             * using __proto__. Firefox 4-29 lacks support for adding new properties to `Uint8Array`
             * (See: https://bugzilla.mozilla.org/show_bug.cgi?id=695438). IE 10 lacks support
             * for __proto__ and has a buggy typed array implementation.
             */
            Buffer.TYPED_ARRAY_SUPPORT = typedArraySupport();

            if (
              !Buffer.TYPED_ARRAY_SUPPORT &&
              typeof console !== "undefined" &&
              typeof console.error === "function"
            ) {
              console.error(
                "This browser lacks typed array (Uint8Array) support which is required by " +
                  "`buffer` v5.x. Use `buffer` v4.x if you require old browser support."
              );
            }

            function typedArraySupport() {
              // Can typed array instances can be augmented?
              try {
                var arr = new Uint8Array(1);
                arr.__proto__ = {
                  __proto__: Uint8Array.prototype,
                  foo: function () {
                    return 42;
                  },
                };
                return arr.foo() === 42;
              } catch (e) {
                return false;
              }
            }

            Object.defineProperty(Buffer.prototype, "parent", {
              enumerable: true,
              get: function () {
                if (!Buffer.isBuffer(this)) return undefined;
                return this.buffer;
              },
            });

            Object.defineProperty(Buffer.prototype, "offset", {
              enumerable: true,
              get: function () {
                if (!Buffer.isBuffer(this)) return undefined;
                return this.byteOffset;
              },
            });

            function createBuffer(length) {
              if (length > K_MAX_LENGTH) {
                throw new RangeError(
                  'The value "' + length + '" is invalid for option "size"'
                );
              }
              // Return an augmented `Uint8Array` instance
              var buf = new Uint8Array(length);
              buf.__proto__ = Buffer.prototype;
              return buf;
            }

            /**
             * The Buffer constructor returns instances of `Uint8Array` that have their
             * prototype changed to `Buffer.prototype`. Furthermore, `Buffer` is a subclass of
             * `Uint8Array`, so the returned instances will have all the node `Buffer` methods
             * and the `Uint8Array` methods. Square bracket notation works as expected -- it
             * returns a single octet.
             *
             * The `Uint8Array` prototype remains unmodified.
             */

            function Buffer(arg, encodingOrOffset, length) {
              // Common case.
              if (typeof arg === "number") {
                if (typeof encodingOrOffset === "string") {
                  throw new TypeError(
                    'The "string" argument must be of type string. Received type number'
                  );
                }
                return allocUnsafe(arg);
              }
              return from(arg, encodingOrOffset, length);
            }

            // Fix subarray() in ES2016. See: https://github.com/feross/buffer/pull/97
            if (
              typeof Symbol !== "undefined" &&
              Symbol.species != null &&
              Buffer[Symbol.species] === Buffer
            ) {
              Object.defineProperty(Buffer, Symbol.species, {
                value: null,
                configurable: true,
                enumerable: false,
                writable: false,
              });
            }

            Buffer.poolSize = 8192; // not used by this implementation

            function from(value, encodingOrOffset, length) {
              if (typeof value === "string") {
                return fromString(value, encodingOrOffset);
              }

              if (ArrayBuffer.isView(value)) {
                return fromArrayLike(value);
              }

              if (value == null) {
                throw TypeError(
                  "The first argument must be one of type string, Buffer, ArrayBuffer, Array, " +
                    "or Array-like Object. Received type " +
                    typeof value
                );
              }

              if (
                isInstance(value, ArrayBuffer) ||
                (value && isInstance(value.buffer, ArrayBuffer))
              ) {
                return fromArrayBuffer(value, encodingOrOffset, length);
              }

              if (typeof value === "number") {
                throw new TypeError(
                  'The "value" argument must not be of type number. Received type number'
                );
              }

              var valueOf = value.valueOf && value.valueOf();
              if (valueOf != null && valueOf !== value) {
                return Buffer.from(valueOf, encodingOrOffset, length);
              }

              var b = fromObject(value);
              if (b) return b;

              if (
                typeof Symbol !== "undefined" &&
                Symbol.toPrimitive != null &&
                typeof value[Symbol.toPrimitive] === "function"
              ) {
                return Buffer.from(
                  value[Symbol.toPrimitive]("string"),
                  encodingOrOffset,
                  length
                );
              }

              throw new TypeError(
                "The first argument must be one of type string, Buffer, ArrayBuffer, Array, " +
                  "or Array-like Object. Received type " +
                  typeof value
              );
            }

            /**
             * Functionally equivalent to Buffer(arg, encoding) but throws a TypeError
             * if value is a number.
             * Buffer.from(str[, encoding])
             * Buffer.from(array)
             * Buffer.from(buffer)
             * Buffer.from(arrayBuffer[, byteOffset[, length]])
             **/
            Buffer.from = function (value, encodingOrOffset, length) {
              return from(value, encodingOrOffset, length);
            };

            // Note: Change prototype *after* Buffer.from is defined to workaround Chrome bug:
            // https://github.com/feross/buffer/pull/148
            Buffer.prototype.__proto__ = Uint8Array.prototype;
            Buffer.__proto__ = Uint8Array;

            function assertSize(size) {
              if (typeof size !== "number") {
                throw new TypeError('"size" argument must be of type number');
              } else if (size < 0) {
                throw new RangeError(
                  'The value "' + size + '" is invalid for option "size"'
                );
              }
            }

            function alloc(size, fill, encoding) {
              assertSize(size);
              if (size <= 0) {
                return createBuffer(size);
              }
              if (fill !== undefined) {
                // Only pay attention to encoding if it's a string. This
                // prevents accidentally sending in a number that would
                // be interpretted as a start offset.
                return typeof encoding === "string"
                  ? createBuffer(size).fill(fill, encoding)
                  : createBuffer(size).fill(fill);
              }
              return createBuffer(size);
            }

            /**
             * Creates a new filled Buffer instance.
             * alloc(size[, fill[, encoding]])
             **/
            Buffer.alloc = function (size, fill, encoding) {
              return alloc(size, fill, encoding);
            };

            function allocUnsafe(size) {
              assertSize(size);
              return createBuffer(size < 0 ? 0 : checked(size) | 0);
            }

            /**
             * Equivalent to Buffer(num), by default creates a non-zero-filled Buffer instance.
             * */
            Buffer.allocUnsafe = function (size) {
              return allocUnsafe(size);
            };
            /**
             * Equivalent to SlowBuffer(num), by default creates a non-zero-filled Buffer instance.
             */
            Buffer.allocUnsafeSlow = function (size) {
              return allocUnsafe(size);
            };

            function fromString(string, encoding) {
              if (typeof encoding !== "string" || encoding === "") {
                encoding = "utf8";
              }

              if (!Buffer.isEncoding(encoding)) {
                throw new TypeError("Unknown encoding: " + encoding);
              }

              var length = byteLength(string, encoding) | 0;
              var buf = createBuffer(length);

              var actual = buf.write(string, encoding);

              if (actual !== length) {
                // Writing a hex string, for example, that contains invalid characters will
                // cause everything after the first invalid character to be ignored. (e.g.
                // 'abxxcd' will be treated as 'ab')
                buf = buf.slice(0, actual);
              }

              return buf;
            }

            function fromArrayLike(array) {
              var length = array.length < 0 ? 0 : checked(array.length) | 0;
              var buf = createBuffer(length);
              for (var i = 0; i < length; i += 1) {
                buf[i] = array[i] & 255;
              }
              return buf;
            }

            function fromArrayBuffer(array, byteOffset, length) {
              if (byteOffset < 0 || array.byteLength < byteOffset) {
                throw new RangeError('"offset" is outside of buffer bounds');
              }

              if (array.byteLength < byteOffset + (length || 0)) {
                throw new RangeError('"length" is outside of buffer bounds');
              }

              var buf;
              if (byteOffset === undefined && length === undefined) {
                buf = new Uint8Array(array);
              } else if (length === undefined) {
                buf = new Uint8Array(array, byteOffset);
              } else {
                buf = new Uint8Array(array, byteOffset, length);
              }

              // Return an augmented `Uint8Array` instance
              buf.__proto__ = Buffer.prototype;
              return buf;
            }

            function fromObject(obj) {
              if (Buffer.isBuffer(obj)) {
                var len = checked(obj.length) | 0;
                var buf = createBuffer(len);

                if (buf.length === 0) {
                  return buf;
                }

                obj.copy(buf, 0, 0, len);
                return buf;
              }

              if (obj.length !== undefined) {
                if (typeof obj.length !== "number" || numberIsNaN(obj.length)) {
                  return createBuffer(0);
                }
                return fromArrayLike(obj);
              }

              if (obj.type === "Buffer" && Array.isArray(obj.data)) {
                return fromArrayLike(obj.data);
              }
            }

            function checked(length) {
              // Note: cannot use `length < K_MAX_LENGTH` here because that fails when
              // length is NaN (which is otherwise coerced to zero.)
              if (length >= K_MAX_LENGTH) {
                throw new RangeError(
                  "Attempt to allocate Buffer larger than maximum " +
                    "size: 0x" +
                    K_MAX_LENGTH.toString(16) +
                    " bytes"
                );
              }
              return length | 0;
            }

            function SlowBuffer(length) {
              if (+length != length) {
                // eslint-disable-line eqeqeq
                length = 0;
              }
              return Buffer.alloc(+length);
            }

            Buffer.isBuffer = function isBuffer(b) {
              return (
                b != null && b._isBuffer === true && b !== Buffer.prototype
              ); // so Buffer.isBuffer(Buffer.prototype) will be false
            };

            Buffer.compare = function compare(a, b) {
              if (isInstance(a, Uint8Array))
                a = Buffer.from(a, a.offset, a.byteLength);
              if (isInstance(b, Uint8Array))
                b = Buffer.from(b, b.offset, b.byteLength);
              if (!Buffer.isBuffer(a) || !Buffer.isBuffer(b)) {
                throw new TypeError(
                  'The "buf1", "buf2" arguments must be one of type Buffer or Uint8Array'
                );
              }

              if (a === b) return 0;

              var x = a.length;
              var y = b.length;

              for (var i = 0, len = Math.min(x, y); i < len; ++i) {
                if (a[i] !== b[i]) {
                  x = a[i];
                  y = b[i];
                  break;
                }
              }

              if (x < y) return -1;
              if (y < x) return 1;
              return 0;
            };

            Buffer.isEncoding = function isEncoding(encoding) {
              switch (String(encoding).toLowerCase()) {
                case "hex":
                case "utf8":
                case "utf-8":
                case "ascii":
                case "latin1":
                case "binary":
                case "base64":
                case "ucs2":
                case "ucs-2":
                case "utf16le":
                case "utf-16le":
                  return true;
                default:
                  return false;
              }
            };

            Buffer.concat = function concat(list, length) {
              if (!Array.isArray(list)) {
                throw new TypeError(
                  '"list" argument must be an Array of Buffers'
                );
              }

              if (list.length === 0) {
                return Buffer.alloc(0);
              }

              var i;
              if (length === undefined) {
                length = 0;
                for (i = 0; i < list.length; ++i) {
                  length += list[i].length;
                }
              }

              var buffer = Buffer.allocUnsafe(length);
              var pos = 0;
              for (i = 0; i < list.length; ++i) {
                var buf = list[i];
                if (isInstance(buf, Uint8Array)) {
                  buf = Buffer.from(buf);
                }
                if (!Buffer.isBuffer(buf)) {
                  throw new TypeError(
                    '"list" argument must be an Array of Buffers'
                  );
                }
                buf.copy(buffer, pos);
                pos += buf.length;
              }
              return buffer;
            };

            function byteLength(string, encoding) {
              if (Buffer.isBuffer(string)) {
                return string.length;
              }
              if (
                ArrayBuffer.isView(string) ||
                isInstance(string, ArrayBuffer)
              ) {
                return string.byteLength;
              }
              if (typeof string !== "string") {
                throw new TypeError(
                  'The "string" argument must be one of type string, Buffer, or ArrayBuffer. ' +
                    "Received type " +
                    typeof string
                );
              }

              var len = string.length;
              var mustMatch = arguments.length > 2 && arguments[2] === true;
              if (!mustMatch && len === 0) return 0;

              // Use a for loop to avoid recursion
              var loweredCase = false;
              for (;;) {
                switch (encoding) {
                  case "ascii":
                  case "latin1":
                  case "binary":
                    return len;
                  case "utf8":
                  case "utf-8":
                    return utf8ToBytes(string).length;
                  case "ucs2":
                  case "ucs-2":
                  case "utf16le":
                  case "utf-16le":
                    return len * 2;
                  case "hex":
                    return len >>> 1;
                  case "base64":
                    return base64ToBytes(string).length;
                  default:
                    if (loweredCase) {
                      return mustMatch ? -1 : utf8ToBytes(string).length; // assume utf8
                    }
                    encoding = ("" + encoding).toLowerCase();
                    loweredCase = true;
                }
              }
            }
            Buffer.byteLength = byteLength;

            function slowToString(encoding, start, end) {
              var loweredCase = false;

              // No need to verify that "this.length <= MAX_UINT32" since it's a read-only
              // property of a typed array.

              // This behaves neither like String nor Uint8Array in that we set start/end
              // to their upper/lower bounds if the value passed is out of range.
              // undefined is handled specially as per ECMA-262 6th Edition,
              // Section 13.3.3.7 Runtime Semantics: KeyedBindingInitialization.
              if (start === undefined || start < 0) {
                start = 0;
              }
              // Return early if start > this.length. Done here to prevent potential uint32
              // coercion fail below.
              if (start > this.length) {
                return "";
              }

              if (end === undefined || end > this.length) {
                end = this.length;
              }

              if (end <= 0) {
                return "";
              }

              // Force coersion to uint32. This will also coerce falsey/NaN values to 0.
              end >>>= 0;
              start >>>= 0;

              if (end <= start) {
                return "";
              }

              if (!encoding) encoding = "utf8";

              while (true) {
                switch (encoding) {
                  case "hex":
                    return hexSlice(this, start, end);

                  case "utf8":
                  case "utf-8":
                    return utf8Slice(this, start, end);

                  case "ascii":
                    return asciiSlice(this, start, end);

                  case "latin1":
                  case "binary":
                    return latin1Slice(this, start, end);

                  case "base64":
                    return base64Slice(this, start, end);

                  case "ucs2":
                  case "ucs-2":
                  case "utf16le":
                  case "utf-16le":
                    return utf16leSlice(this, start, end);

                  default:
                    if (loweredCase)
                      throw new TypeError("Unknown encoding: " + encoding);
                    encoding = (encoding + "").toLowerCase();
                    loweredCase = true;
                }
              }
            }

            // This property is used by `Buffer.isBuffer` (and the `is-buffer` npm package)
            // to detect a Buffer instance. It's not possible to use `instanceof Buffer`
            // reliably in a browserify context because there could be multiple different
            // copies of the 'buffer' package in use. This method works even for Buffer
            // instances that were created from another copy of the `buffer` package.
            // See: https://github.com/feross/buffer/issues/154
            Buffer.prototype._isBuffer = true;

            function swap(b, n, m) {
              var i = b[n];
              b[n] = b[m];
              b[m] = i;
            }

            Buffer.prototype.swap16 = function swap16() {
              var len = this.length;
              if (len % 2 !== 0) {
                throw new RangeError(
                  "Buffer size must be a multiple of 16-bits"
                );
              }
              for (var i = 0; i < len; i += 2) {
                swap(this, i, i + 1);
              }
              return this;
            };

            Buffer.prototype.swap32 = function swap32() {
              var len = this.length;
              if (len % 4 !== 0) {
                throw new RangeError(
                  "Buffer size must be a multiple of 32-bits"
                );
              }
              for (var i = 0; i < len; i += 4) {
                swap(this, i, i + 3);
                swap(this, i + 1, i + 2);
              }
              return this;
            };

            Buffer.prototype.swap64 = function swap64() {
              var len = this.length;
              if (len % 8 !== 0) {
                throw new RangeError(
                  "Buffer size must be a multiple of 64-bits"
                );
              }
              for (var i = 0; i < len; i += 8) {
                swap(this, i, i + 7);
                swap(this, i + 1, i + 6);
                swap(this, i + 2, i + 5);
                swap(this, i + 3, i + 4);
              }
              return this;
            };

            Buffer.prototype.toString = function toString() {
              var length = this.length;
              if (length === 0) return "";
              if (arguments.length === 0) return utf8Slice(this, 0, length);
              return slowToString.apply(this, arguments);
            };

            Buffer.prototype.toLocaleString = Buffer.prototype.toString;

            Buffer.prototype.equals = function equals(b) {
              if (!Buffer.isBuffer(b))
                throw new TypeError("Argument must be a Buffer");
              if (this === b) return true;
              return Buffer.compare(this, b) === 0;
            };

            Buffer.prototype.inspect = function inspect() {
              var str = "";
              var max = exports.INSPECT_MAX_BYTES;
              str = this.toString("hex", 0, max)
                .replace(/(.{2})/g, "$1 ")
                .trim();
              if (this.length > max) str += " ... ";
              return "<Buffer " + str + ">";
            };

            Buffer.prototype.compare = function compare(
              target,
              start,
              end,
              thisStart,
              thisEnd
            ) {
              if (isInstance(target, Uint8Array)) {
                target = Buffer.from(target, target.offset, target.byteLength);
              }
              if (!Buffer.isBuffer(target)) {
                throw new TypeError(
                  'The "target" argument must be one of type Buffer or Uint8Array. ' +
                    "Received type " +
                    typeof target
                );
              }

              if (start === undefined) {
                start = 0;
              }
              if (end === undefined) {
                end = target ? target.length : 0;
              }
              if (thisStart === undefined) {
                thisStart = 0;
              }
              if (thisEnd === undefined) {
                thisEnd = this.length;
              }

              if (
                start < 0 ||
                end > target.length ||
                thisStart < 0 ||
                thisEnd > this.length
              ) {
                throw new RangeError("out of range index");
              }

              if (thisStart >= thisEnd && start >= end) {
                return 0;
              }
              if (thisStart >= thisEnd) {
                return -1;
              }
              if (start >= end) {
                return 1;
              }

              start >>>= 0;
              end >>>= 0;
              thisStart >>>= 0;
              thisEnd >>>= 0;

              if (this === target) return 0;

              var x = thisEnd - thisStart;
              var y = end - start;
              var len = Math.min(x, y);

              var thisCopy = this.slice(thisStart, thisEnd);
              var targetCopy = target.slice(start, end);

              for (var i = 0; i < len; ++i) {
                if (thisCopy[i] !== targetCopy[i]) {
                  x = thisCopy[i];
                  y = targetCopy[i];
                  break;
                }
              }

              if (x < y) return -1;
              if (y < x) return 1;
              return 0;
            };

            // Finds either the first index of `val` in `buffer` at offset >= `byteOffset`,
            // OR the last index of `val` in `buffer` at offset <= `byteOffset`.
            //
            // Arguments:
            // - buffer - a Buffer to search
            // - val - a string, Buffer, or number
            // - byteOffset - an index into `buffer`; will be clamped to an int32
            // - encoding - an optional encoding, relevant is val is a string
            // - dir - true for indexOf, false for lastIndexOf
            function bidirectionalIndexOf(
              buffer,
              val,
              byteOffset,
              encoding,
              dir
            ) {
              // Empty buffer means no match
              if (buffer.length === 0) return -1;

              // Normalize byteOffset
              if (typeof byteOffset === "string") {
                encoding = byteOffset;
                byteOffset = 0;
              } else if (byteOffset > 0x7fffffff) {
                byteOffset = 0x7fffffff;
              } else if (byteOffset < -0x80000000) {
                byteOffset = -0x80000000;
              }
              byteOffset = +byteOffset; // Coerce to Number.
              if (numberIsNaN(byteOffset)) {
                // byteOffset: it it's undefined, null, NaN, "foo", etc, search whole buffer
                byteOffset = dir ? 0 : buffer.length - 1;
              }

              // Normalize byteOffset: negative offsets start from the end of the buffer
              if (byteOffset < 0) byteOffset = buffer.length + byteOffset;
              if (byteOffset >= buffer.length) {
                if (dir) return -1;
                else byteOffset = buffer.length - 1;
              } else if (byteOffset < 0) {
                if (dir) byteOffset = 0;
                else return -1;
              }

              // Normalize val
              if (typeof val === "string") {
                val = Buffer.from(val, encoding);
              }

              // Finally, search either indexOf (if dir is true) or lastIndexOf
              if (Buffer.isBuffer(val)) {
                // Special case: looking for empty string/buffer always fails
                if (val.length === 0) {
                  return -1;
                }
                return arrayIndexOf(buffer, val, byteOffset, encoding, dir);
              } else if (typeof val === "number") {
                val = val & 0xff; // Search for a byte value [0-255]
                if (typeof Uint8Array.prototype.indexOf === "function") {
                  if (dir) {
                    return Uint8Array.prototype.indexOf.call(
                      buffer,
                      val,
                      byteOffset
                    );
                  } else {
                    return Uint8Array.prototype.lastIndexOf.call(
                      buffer,
                      val,
                      byteOffset
                    );
                  }
                }
                return arrayIndexOf(buffer, [val], byteOffset, encoding, dir);
              }

              throw new TypeError("val must be string, number or Buffer");
            }

            function arrayIndexOf(arr, val, byteOffset, encoding, dir) {
              var indexSize = 1;
              var arrLength = arr.length;
              var valLength = val.length;

              if (encoding !== undefined) {
                encoding = String(encoding).toLowerCase();
                if (
                  encoding === "ucs2" ||
                  encoding === "ucs-2" ||
                  encoding === "utf16le" ||
                  encoding === "utf-16le"
                ) {
                  if (arr.length < 2 || val.length < 2) {
                    return -1;
                  }
                  indexSize = 2;
                  arrLength /= 2;
                  valLength /= 2;
                  byteOffset /= 2;
                }
              }

              function read(buf, i) {
                if (indexSize === 1) {
                  return buf[i];
                } else {
                  return buf.readUInt16BE(i * indexSize);
                }
              }

              var i;
              if (dir) {
                var foundIndex = -1;
                for (i = byteOffset; i < arrLength; i++) {
                  if (
                    read(arr, i) ===
                    read(val, foundIndex === -1 ? 0 : i - foundIndex)
                  ) {
                    if (foundIndex === -1) foundIndex = i;
                    if (i - foundIndex + 1 === valLength)
                      return foundIndex * indexSize;
                  } else {
                    if (foundIndex !== -1) i -= i - foundIndex;
                    foundIndex = -1;
                  }
                }
              } else {
                if (byteOffset + valLength > arrLength)
                  byteOffset = arrLength - valLength;
                for (i = byteOffset; i >= 0; i--) {
                  var found = true;
                  for (var j = 0; j < valLength; j++) {
                    if (read(arr, i + j) !== read(val, j)) {
                      found = false;
                      break;
                    }
                  }
                  if (found) return i;
                }
              }

              return -1;
            }

            Buffer.prototype.includes = function includes(
              val,
              byteOffset,
              encoding
            ) {
              return this.indexOf(val, byteOffset, encoding) !== -1;
            };

            Buffer.prototype.indexOf = function indexOf(
              val,
              byteOffset,
              encoding
            ) {
              return bidirectionalIndexOf(
                this,
                val,
                byteOffset,
                encoding,
                true
              );
            };

            Buffer.prototype.lastIndexOf = function lastIndexOf(
              val,
              byteOffset,
              encoding
            ) {
              return bidirectionalIndexOf(
                this,
                val,
                byteOffset,
                encoding,
                false
              );
            };

            function hexWrite(buf, string, offset, length) {
              offset = Number(offset) || 0;
              var remaining = buf.length - offset;
              if (!length) {
                length = remaining;
              } else {
                length = Number(length);
                if (length > remaining) {
                  length = remaining;
                }
              }

              var strLen = string.length;

              if (length > strLen / 2) {
                length = strLen / 2;
              }
              for (var i = 0; i < length; ++i) {
                var parsed = parseInt(string.substr(i * 2, 2), 16);
                if (numberIsNaN(parsed)) return i;
                buf[offset + i] = parsed;
              }
              return i;
            }

            function utf8Write(buf, string, offset, length) {
              return blitBuffer(
                utf8ToBytes(string, buf.length - offset),
                buf,
                offset,
                length
              );
            }

            function asciiWrite(buf, string, offset, length) {
              return blitBuffer(asciiToBytes(string), buf, offset, length);
            }

            function latin1Write(buf, string, offset, length) {
              return asciiWrite(buf, string, offset, length);
            }

            function base64Write(buf, string, offset, length) {
              return blitBuffer(base64ToBytes(string), buf, offset, length);
            }

            function ucs2Write(buf, string, offset, length) {
              return blitBuffer(
                utf16leToBytes(string, buf.length - offset),
                buf,
                offset,
                length
              );
            }

            Buffer.prototype.write = function write(
              string,
              offset,
              length,
              encoding
            ) {
              // Buffer#write(string)
              if (offset === undefined) {
                encoding = "utf8";
                length = this.length;
                offset = 0;
                // Buffer#write(string, encoding)
              } else if (length === undefined && typeof offset === "string") {
                encoding = offset;
                length = this.length;
                offset = 0;
                // Buffer#write(string, offset[, length][, encoding])
              } else if (isFinite(offset)) {
                offset = offset >>> 0;
                if (isFinite(length)) {
                  length = length >>> 0;
                  if (encoding === undefined) encoding = "utf8";
                } else {
                  encoding = length;
                  length = undefined;
                }
              } else {
                throw new Error(
                  "Buffer.write(string, encoding, offset[, length]) is no longer supported"
                );
              }

              var remaining = this.length - offset;
              if (length === undefined || length > remaining)
                length = remaining;

              if (
                (string.length > 0 && (length < 0 || offset < 0)) ||
                offset > this.length
              ) {
                throw new RangeError("Attempt to write outside buffer bounds");
              }

              if (!encoding) encoding = "utf8";

              var loweredCase = false;
              for (;;) {
                switch (encoding) {
                  case "hex":
                    return hexWrite(this, string, offset, length);

                  case "utf8":
                  case "utf-8":
                    return utf8Write(this, string, offset, length);

                  case "ascii":
                    return asciiWrite(this, string, offset, length);

                  case "latin1":
                  case "binary":
                    return latin1Write(this, string, offset, length);

                  case "base64":
                    // Warning: maxLength not taken into account in base64Write
                    return base64Write(this, string, offset, length);

                  case "ucs2":
                  case "ucs-2":
                  case "utf16le":
                  case "utf-16le":
                    return ucs2Write(this, string, offset, length);

                  default:
                    if (loweredCase)
                      throw new TypeError("Unknown encoding: " + encoding);
                    encoding = ("" + encoding).toLowerCase();
                    loweredCase = true;
                }
              }
            };

            Buffer.prototype.toJSON = function toJSON() {
              return {
                type: "Buffer",
                data: Array.prototype.slice.call(this._arr || this, 0),
              };
            };

            function base64Slice(buf, start, end) {
              if (start === 0 && end === buf.length) {
                return base64.fromByteArray(buf);
              } else {
                return base64.fromByteArray(buf.slice(start, end));
              }
            }

            function utf8Slice(buf, start, end) {
              end = Math.min(buf.length, end);
              var res = [];

              var i = start;
              while (i < end) {
                var firstByte = buf[i];
                var codePoint = null;
                var bytesPerSequence =
                  firstByte > 0xef
                    ? 4
                    : firstByte > 0xdf
                    ? 3
                    : firstByte > 0xbf
                    ? 2
                    : 1;

                if (i + bytesPerSequence <= end) {
                  var secondByte, thirdByte, fourthByte, tempCodePoint;

                  switch (bytesPerSequence) {
                    case 1:
                      if (firstByte < 0x80) {
                        codePoint = firstByte;
                      }
                      break;
                    case 2:
                      secondByte = buf[i + 1];
                      if ((secondByte & 0xc0) === 0x80) {
                        tempCodePoint =
                          ((firstByte & 0x1f) << 0x6) | (secondByte & 0x3f);
                        if (tempCodePoint > 0x7f) {
                          codePoint = tempCodePoint;
                        }
                      }
                      break;
                    case 3:
                      secondByte = buf[i + 1];
                      thirdByte = buf[i + 2];
                      if (
                        (secondByte & 0xc0) === 0x80 &&
                        (thirdByte & 0xc0) === 0x80
                      ) {
                        tempCodePoint =
                          ((firstByte & 0xf) << 0xc) |
                          ((secondByte & 0x3f) << 0x6) |
                          (thirdByte & 0x3f);
                        if (
                          tempCodePoint > 0x7ff &&
                          (tempCodePoint < 0xd800 || tempCodePoint > 0xdfff)
                        ) {
                          codePoint = tempCodePoint;
                        }
                      }
                      break;
                    case 4:
                      secondByte = buf[i + 1];
                      thirdByte = buf[i + 2];
                      fourthByte = buf[i + 3];
                      if (
                        (secondByte & 0xc0) === 0x80 &&
                        (thirdByte & 0xc0) === 0x80 &&
                        (fourthByte & 0xc0) === 0x80
                      ) {
                        tempCodePoint =
                          ((firstByte & 0xf) << 0x12) |
                          ((secondByte & 0x3f) << 0xc) |
                          ((thirdByte & 0x3f) << 0x6) |
                          (fourthByte & 0x3f);
                        if (
                          tempCodePoint > 0xffff &&
                          tempCodePoint < 0x110000
                        ) {
                          codePoint = tempCodePoint;
                        }
                      }
                  }
                }

                if (codePoint === null) {
                  // we did not generate a valid codePoint so insert a
                  // replacement char (U+FFFD) and advance only 1 byte
                  codePoint = 0xfffd;
                  bytesPerSequence = 1;
                } else if (codePoint > 0xffff) {
                  // encode to utf16 (surrogate pair dance)
                  codePoint -= 0x10000;
                  res.push(((codePoint >>> 10) & 0x3ff) | 0xd800);
                  codePoint = 0xdc00 | (codePoint & 0x3ff);
                }

                res.push(codePoint);
                i += bytesPerSequence;
              }

              return decodeCodePointsArray(res);
            }

            // Based on http://stackoverflow.com/a/22747272/680742, the browser with
            // the lowest limit is Chrome, with 0x10000 args.
            // We go 1 magnitude less, for safety
            var MAX_ARGUMENTS_LENGTH = 0x1000;

            function decodeCodePointsArray(codePoints) {
              var len = codePoints.length;
              if (len <= MAX_ARGUMENTS_LENGTH) {
                return String.fromCharCode.apply(String, codePoints); // avoid extra slice()
              }

              // Decode in chunks to avoid "call stack size exceeded".
              var res = "";
              var i = 0;
              while (i < len) {
                res += String.fromCharCode.apply(
                  String,
                  codePoints.slice(i, (i += MAX_ARGUMENTS_LENGTH))
                );
              }
              return res;
            }

            function asciiSlice(buf, start, end) {
              var ret = "";
              end = Math.min(buf.length, end);

              for (var i = start; i < end; ++i) {
                ret += String.fromCharCode(buf[i] & 0x7f);
              }
              return ret;
            }

            function latin1Slice(buf, start, end) {
              var ret = "";
              end = Math.min(buf.length, end);

              for (var i = start; i < end; ++i) {
                ret += String.fromCharCode(buf[i]);
              }
              return ret;
            }

            function hexSlice(buf, start, end) {
              var len = buf.length;

              if (!start || start < 0) start = 0;
              if (!end || end < 0 || end > len) end = len;

              var out = "";
              for (var i = start; i < end; ++i) {
                out += toHex(buf[i]);
              }
              return out;
            }

            function utf16leSlice(buf, start, end) {
              var bytes = buf.slice(start, end);
              var res = "";
              for (var i = 0; i < bytes.length; i += 2) {
                res += String.fromCharCode(bytes[i] + bytes[i + 1] * 256);
              }
              return res;
            }

            Buffer.prototype.slice = function slice(start, end) {
              var len = this.length;
              start = ~~start;
              end = end === undefined ? len : ~~end;

              if (start < 0) {
                start += len;
                if (start < 0) start = 0;
              } else if (start > len) {
                start = len;
              }

              if (end < 0) {
                end += len;
                if (end < 0) end = 0;
              } else if (end > len) {
                end = len;
              }

              if (end < start) end = start;

              var newBuf = this.subarray(start, end);
              // Return an augmented `Uint8Array` instance
              newBuf.__proto__ = Buffer.prototype;
              return newBuf;
            };

            /*
             * Need to make sure that buffer isn't trying to write out of bounds.
             */
            function checkOffset(offset, ext, length) {
              if (offset % 1 !== 0 || offset < 0)
                throw new RangeError("offset is not uint");
              if (offset + ext > length)
                throw new RangeError("Trying to access beyond buffer length");
            }

            Buffer.prototype.readUIntLE = function readUIntLE(
              offset,
              byteLength,
              noAssert
            ) {
              offset = offset >>> 0;
              byteLength = byteLength >>> 0;
              if (!noAssert) checkOffset(offset, byteLength, this.length);

              var val = this[offset];
              var mul = 1;
              var i = 0;
              while (++i < byteLength && (mul *= 0x100)) {
                val += this[offset + i] * mul;
              }

              return val;
            };

            Buffer.prototype.readUIntBE = function readUIntBE(
              offset,
              byteLength,
              noAssert
            ) {
              offset = offset >>> 0;
              byteLength = byteLength >>> 0;
              if (!noAssert) {
                checkOffset(offset, byteLength, this.length);
              }

              var val = this[offset + --byteLength];
              var mul = 1;
              while (byteLength > 0 && (mul *= 0x100)) {
                val += this[offset + --byteLength] * mul;
              }

              return val;
            };

            Buffer.prototype.readUInt8 = function readUInt8(offset, noAssert) {
              offset = offset >>> 0;
              if (!noAssert) checkOffset(offset, 1, this.length);
              return this[offset];
            };

            Buffer.prototype.readUInt16LE = function readUInt16LE(
              offset,
              noAssert
            ) {
              offset = offset >>> 0;
              if (!noAssert) checkOffset(offset, 2, this.length);
              return this[offset] | (this[offset + 1] << 8);
            };

            Buffer.prototype.readUInt16BE = function readUInt16BE(
              offset,
              noAssert
            ) {
              offset = offset >>> 0;
              if (!noAssert) checkOffset(offset, 2, this.length);
              return (this[offset] << 8) | this[offset + 1];
            };

            Buffer.prototype.readUInt32LE = function readUInt32LE(
              offset,
              noAssert
            ) {
              offset = offset >>> 0;
              if (!noAssert) checkOffset(offset, 4, this.length);

              return (
                (this[offset] |
                  (this[offset + 1] << 8) |
                  (this[offset + 2] << 16)) +
                this[offset + 3] * 0x1000000
              );
            };

            Buffer.prototype.readUInt32BE = function readUInt32BE(
              offset,
              noAssert
            ) {
              offset = offset >>> 0;
              if (!noAssert) checkOffset(offset, 4, this.length);

              return (
                this[offset] * 0x1000000 +
                ((this[offset + 1] << 16) |
                  (this[offset + 2] << 8) |
                  this[offset + 3])
              );
            };

            Buffer.prototype.readIntLE = function readIntLE(
              offset,
              byteLength,
              noAssert
            ) {
              offset = offset >>> 0;
              byteLength = byteLength >>> 0;
              if (!noAssert) checkOffset(offset, byteLength, this.length);

              var val = this[offset];
              var mul = 1;
              var i = 0;
              while (++i < byteLength && (mul *= 0x100)) {
                val += this[offset + i] * mul;
              }
              mul *= 0x80;

              if (val >= mul) val -= Math.pow(2, 8 * byteLength);

              return val;
            };

            Buffer.prototype.readIntBE = function readIntBE(
              offset,
              byteLength,
              noAssert
            ) {
              offset = offset >>> 0;
              byteLength = byteLength >>> 0;
              if (!noAssert) checkOffset(offset, byteLength, this.length);

              var i = byteLength;
              var mul = 1;
              var val = this[offset + --i];
              while (i > 0 && (mul *= 0x100)) {
                val += this[offset + --i] * mul;
              }
              mul *= 0x80;

              if (val >= mul) val -= Math.pow(2, 8 * byteLength);

              return val;
            };

            Buffer.prototype.readInt8 = function readInt8(offset, noAssert) {
              offset = offset >>> 0;
              if (!noAssert) checkOffset(offset, 1, this.length);
              if (!(this[offset] & 0x80)) return this[offset];
              return (0xff - this[offset] + 1) * -1;
            };

            Buffer.prototype.readInt16LE = function readInt16LE(
              offset,
              noAssert
            ) {
              offset = offset >>> 0;
              if (!noAssert) checkOffset(offset, 2, this.length);
              var val = this[offset] | (this[offset + 1] << 8);
              return val & 0x8000 ? val | 0xffff0000 : val;
            };

            Buffer.prototype.readInt16BE = function readInt16BE(
              offset,
              noAssert
            ) {
              offset = offset >>> 0;
              if (!noAssert) checkOffset(offset, 2, this.length);
              var val = this[offset + 1] | (this[offset] << 8);
              return val & 0x8000 ? val | 0xffff0000 : val;
            };

            Buffer.prototype.readInt32LE = function readInt32LE(
              offset,
              noAssert
            ) {
              offset = offset >>> 0;
              if (!noAssert) checkOffset(offset, 4, this.length);

              return (
                this[offset] |
                (this[offset + 1] << 8) |
                (this[offset + 2] << 16) |
                (this[offset + 3] << 24)
              );
            };

            Buffer.prototype.readInt32BE = function readInt32BE(
              offset,
              noAssert
            ) {
              offset = offset >>> 0;
              if (!noAssert) checkOffset(offset, 4, this.length);

              return (
                (this[offset] << 24) |
                (this[offset + 1] << 16) |
                (this[offset + 2] << 8) |
                this[offset + 3]
              );
            };

            Buffer.prototype.readFloatLE = function readFloatLE(
              offset,
              noAssert
            ) {
              offset = offset >>> 0;
              if (!noAssert) checkOffset(offset, 4, this.length);
              return ieee754.read(this, offset, true, 23, 4);
            };

            Buffer.prototype.readFloatBE = function readFloatBE(
              offset,
              noAssert
            ) {
              offset = offset >>> 0;
              if (!noAssert) checkOffset(offset, 4, this.length);
              return ieee754.read(this, offset, false, 23, 4);
            };

            Buffer.prototype.readDoubleLE = function readDoubleLE(
              offset,
              noAssert
            ) {
              offset = offset >>> 0;
              if (!noAssert) checkOffset(offset, 8, this.length);
              return ieee754.read(this, offset, true, 52, 8);
            };

            Buffer.prototype.readDoubleBE = function readDoubleBE(
              offset,
              noAssert
            ) {
              offset = offset >>> 0;
              if (!noAssert) checkOffset(offset, 8, this.length);
              return ieee754.read(this, offset, false, 52, 8);
            };

            function checkInt(buf, value, offset, ext, max, min) {
              if (!Buffer.isBuffer(buf))
                throw new TypeError(
                  '"buffer" argument must be a Buffer instance'
                );
              if (value > max || value < min)
                throw new RangeError('"value" argument is out of bounds');
              if (offset + ext > buf.length)
                throw new RangeError("Index out of range");
            }

            Buffer.prototype.writeUIntLE = function writeUIntLE(
              value,
              offset,
              byteLength,
              noAssert
            ) {
              value = +value;
              offset = offset >>> 0;
              byteLength = byteLength >>> 0;
              if (!noAssert) {
                var maxBytes = Math.pow(2, 8 * byteLength) - 1;
                checkInt(this, value, offset, byteLength, maxBytes, 0);
              }

              var mul = 1;
              var i = 0;
              this[offset] = value & 0xff;
              while (++i < byteLength && (mul *= 0x100)) {
                this[offset + i] = (value / mul) & 0xff;
              }

              return offset + byteLength;
            };

            Buffer.prototype.writeUIntBE = function writeUIntBE(
              value,
              offset,
              byteLength,
              noAssert
            ) {
              value = +value;
              offset = offset >>> 0;
              byteLength = byteLength >>> 0;
              if (!noAssert) {
                var maxBytes = Math.pow(2, 8 * byteLength) - 1;
                checkInt(this, value, offset, byteLength, maxBytes, 0);
              }

              var i = byteLength - 1;
              var mul = 1;
              this[offset + i] = value & 0xff;
              while (--i >= 0 && (mul *= 0x100)) {
                this[offset + i] = (value / mul) & 0xff;
              }

              return offset + byteLength;
            };

            Buffer.prototype.writeUInt8 = function writeUInt8(
              value,
              offset,
              noAssert
            ) {
              value = +value;
              offset = offset >>> 0;
              if (!noAssert) checkInt(this, value, offset, 1, 0xff, 0);
              this[offset] = value & 0xff;
              return offset + 1;
            };

            Buffer.prototype.writeUInt16LE = function writeUInt16LE(
              value,
              offset,
              noAssert
            ) {
              value = +value;
              offset = offset >>> 0;
              if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0);
              this[offset] = value & 0xff;
              this[offset + 1] = value >>> 8;
              return offset + 2;
            };

            Buffer.prototype.writeUInt16BE = function writeUInt16BE(
              value,
              offset,
              noAssert
            ) {
              value = +value;
              offset = offset >>> 0;
              if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0);
              this[offset] = value >>> 8;
              this[offset + 1] = value & 0xff;
              return offset + 2;
            };

            Buffer.prototype.writeUInt32LE = function writeUInt32LE(
              value,
              offset,
              noAssert
            ) {
              value = +value;
              offset = offset >>> 0;
              if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0);
              this[offset + 3] = value >>> 24;
              this[offset + 2] = value >>> 16;
              this[offset + 1] = value >>> 8;
              this[offset] = value & 0xff;
              return offset + 4;
            };

            Buffer.prototype.writeUInt32BE = function writeUInt32BE(
              value,
              offset,
              noAssert
            ) {
              value = +value;
              offset = offset >>> 0;
              if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0);
              this[offset] = value >>> 24;
              this[offset + 1] = value >>> 16;
              this[offset + 2] = value >>> 8;
              this[offset + 3] = value & 0xff;
              return offset + 4;
            };

            Buffer.prototype.writeIntLE = function writeIntLE(
              value,
              offset,
              byteLength,
              noAssert
            ) {
              value = +value;
              offset = offset >>> 0;
              if (!noAssert) {
                var limit = Math.pow(2, 8 * byteLength - 1);

                checkInt(this, value, offset, byteLength, limit - 1, -limit);
              }

              var i = 0;
              var mul = 1;
              var sub = 0;
              this[offset] = value & 0xff;
              while (++i < byteLength && (mul *= 0x100)) {
                if (value < 0 && sub === 0 && this[offset + i - 1] !== 0) {
                  sub = 1;
                }
                this[offset + i] = (((value / mul) >> 0) - sub) & 0xff;
              }

              return offset + byteLength;
            };

            Buffer.prototype.writeIntBE = function writeIntBE(
              value,
              offset,
              byteLength,
              noAssert
            ) {
              value = +value;
              offset = offset >>> 0;
              if (!noAssert) {
                var limit = Math.pow(2, 8 * byteLength - 1);

                checkInt(this, value, offset, byteLength, limit - 1, -limit);
              }

              var i = byteLength - 1;
              var mul = 1;
              var sub = 0;
              this[offset + i] = value & 0xff;
              while (--i >= 0 && (mul *= 0x100)) {
                if (value < 0 && sub === 0 && this[offset + i + 1] !== 0) {
                  sub = 1;
                }
                this[offset + i] = (((value / mul) >> 0) - sub) & 0xff;
              }

              return offset + byteLength;
            };

            Buffer.prototype.writeInt8 = function writeInt8(
              value,
              offset,
              noAssert
            ) {
              value = +value;
              offset = offset >>> 0;
              if (!noAssert) checkInt(this, value, offset, 1, 0x7f, -0x80);
              if (value < 0) value = 0xff + value + 1;
              this[offset] = value & 0xff;
              return offset + 1;
            };

            Buffer.prototype.writeInt16LE = function writeInt16LE(
              value,
              offset,
              noAssert
            ) {
              value = +value;
              offset = offset >>> 0;
              if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000);
              this[offset] = value & 0xff;
              this[offset + 1] = value >>> 8;
              return offset + 2;
            };

            Buffer.prototype.writeInt16BE = function writeInt16BE(
              value,
              offset,
              noAssert
            ) {
              value = +value;
              offset = offset >>> 0;
              if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000);
              this[offset] = value >>> 8;
              this[offset + 1] = value & 0xff;
              return offset + 2;
            };

            Buffer.prototype.writeInt32LE = function writeInt32LE(
              value,
              offset,
              noAssert
            ) {
              value = +value;
              offset = offset >>> 0;
              if (!noAssert)
                checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000);
              this[offset] = value & 0xff;
              this[offset + 1] = value >>> 8;
              this[offset + 2] = value >>> 16;
              this[offset + 3] = value >>> 24;
              return offset + 4;
            };

            Buffer.prototype.writeInt32BE = function writeInt32BE(
              value,
              offset,
              noAssert
            ) {
              value = +value;
              offset = offset >>> 0;
              if (!noAssert)
                checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000);
              if (value < 0) value = 0xffffffff + value + 1;
              this[offset] = value >>> 24;
              this[offset + 1] = value >>> 16;
              this[offset + 2] = value >>> 8;
              this[offset + 3] = value & 0xff;
              return offset + 4;
            };

            function checkIEEE754(buf, value, offset, ext, max, min) {
              if (offset + ext > buf.length)
                throw new RangeError("Index out of range");
              if (offset < 0) throw new RangeError("Index out of range");
            }

            function writeFloat(buf, value, offset, littleEndian, noAssert) {
              value = +value;
              offset = offset >>> 0;
              if (!noAssert) {
                checkIEEE754(
                  buf,
                  value,
                  offset,
                  4,
                  3.4028234663852886e38,
                  -3.4028234663852886e38
                );
              }
              ieee754.write(buf, value, offset, littleEndian, 23, 4);
              return offset + 4;
            }

            Buffer.prototype.writeFloatLE = function writeFloatLE(
              value,
              offset,
              noAssert
            ) {
              return writeFloat(this, value, offset, true, noAssert);
            };

            Buffer.prototype.writeFloatBE = function writeFloatBE(
              value,
              offset,
              noAssert
            ) {
              return writeFloat(this, value, offset, false, noAssert);
            };

            function writeDouble(buf, value, offset, littleEndian, noAssert) {
              value = +value;
              offset = offset >>> 0;
              if (!noAssert) {
                checkIEEE754(
                  buf,
                  value,
                  offset,
                  8,
                  1.7976931348623157e308,
                  -1.7976931348623157e308
                );
              }
              ieee754.write(buf, value, offset, littleEndian, 52, 8);
              return offset + 8;
            }

            Buffer.prototype.writeDoubleLE = function writeDoubleLE(
              value,
              offset,
              noAssert
            ) {
              return writeDouble(this, value, offset, true, noAssert);
            };

            Buffer.prototype.writeDoubleBE = function writeDoubleBE(
              value,
              offset,
              noAssert
            ) {
              return writeDouble(this, value, offset, false, noAssert);
            };

            // copy(targetBuffer, targetStart=0, sourceStart=0, sourceEnd=buffer.length)
            Buffer.prototype.copy = function copy(
              target,
              targetStart,
              start,
              end
            ) {
              if (!Buffer.isBuffer(target))
                throw new TypeError("argument should be a Buffer");
              if (!start) start = 0;
              if (!end && end !== 0) end = this.length;
              if (targetStart >= target.length) targetStart = target.length;
              if (!targetStart) targetStart = 0;
              if (end > 0 && end < start) end = start;

              // Copy 0 bytes; we're done
              if (end === start) return 0;
              if (target.length === 0 || this.length === 0) return 0;

              // Fatal error conditions
              if (targetStart < 0) {
                throw new RangeError("targetStart out of bounds");
              }
              if (start < 0 || start >= this.length)
                throw new RangeError("Index out of range");
              if (end < 0) throw new RangeError("sourceEnd out of bounds");

              // Are we oob?
              if (end > this.length) end = this.length;
              if (target.length - targetStart < end - start) {
                end = target.length - targetStart + start;
              }

              var len = end - start;

              if (
                this === target &&
                typeof Uint8Array.prototype.copyWithin === "function"
              ) {
                // Use built-in when available, missing from IE11
                this.copyWithin(targetStart, start, end);
              } else if (
                this === target &&
                start < targetStart &&
                targetStart < end
              ) {
                // descending copy from end
                for (var i = len - 1; i >= 0; --i) {
                  target[i + targetStart] = this[i + start];
                }
              } else {
                Uint8Array.prototype.set.call(
                  target,
                  this.subarray(start, end),
                  targetStart
                );
              }

              return len;
            };

            // Usage:
            //    buffer.fill(number[, offset[, end]])
            //    buffer.fill(buffer[, offset[, end]])
            //    buffer.fill(string[, offset[, end]][, encoding])
            Buffer.prototype.fill = function fill(val, start, end, encoding) {
              // Handle string cases:
              if (typeof val === "string") {
                if (typeof start === "string") {
                  encoding = start;
                  start = 0;
                  end = this.length;
                } else if (typeof end === "string") {
                  encoding = end;
                  end = this.length;
                }
                if (encoding !== undefined && typeof encoding !== "string") {
                  throw new TypeError("encoding must be a string");
                }
                if (
                  typeof encoding === "string" &&
                  !Buffer.isEncoding(encoding)
                ) {
                  throw new TypeError("Unknown encoding: " + encoding);
                }
                if (val.length === 1) {
                  var code = val.charCodeAt(0);
                  if (
                    (encoding === "utf8" && code < 128) ||
                    encoding === "latin1"
                  ) {
                    // Fast path: If `val` fits into a single byte, use that numeric value.
                    val = code;
                  }
                }
              } else if (typeof val === "number") {
                val = val & 255;
              }

              // Invalid ranges are not set to a default, so can range check early.
              if (start < 0 || this.length < start || this.length < end) {
                throw new RangeError("Out of range index");
              }

              if (end <= start) {
                return this;
              }

              start = start >>> 0;
              end = end === undefined ? this.length : end >>> 0;

              if (!val) val = 0;

              var i;
              if (typeof val === "number") {
                for (i = start; i < end; ++i) {
                  this[i] = val;
                }
              } else {
                var bytes = Buffer.isBuffer(val)
                  ? val
                  : Buffer.from(val, encoding);
                var len = bytes.length;
                if (len === 0) {
                  throw new TypeError(
                    'The value "' + val + '" is invalid for argument "value"'
                  );
                }
                for (i = 0; i < end - start; ++i) {
                  this[i + start] = bytes[i % len];
                }
              }

              return this;
            };

            // HELPER FUNCTIONS
            // ================

            var INVALID_BASE64_RE = /[^+/0-9A-Za-z-_]/g;

            function base64clean(str) {
              // Node takes equal signs as end of the Base64 encoding
              str = str.split("=")[0];
              // Node strips out invalid characters like \n and \t from the string, base64-js does not
              str = str.trim().replace(INVALID_BASE64_RE, "");
              // Node converts strings with length < 2 to ''
              if (str.length < 2) return "";
              // Node allows for non-padded base64 strings (missing trailing ===), base64-js does not
              while (str.length % 4 !== 0) {
                str = str + "=";
              }
              return str;
            }

            function toHex(n) {
              if (n < 16) return "0" + n.toString(16);
              return n.toString(16);
            }

            function utf8ToBytes(string, units) {
              units = units || Infinity;
              var codePoint;
              var length = string.length;
              var leadSurrogate = null;
              var bytes = [];

              for (var i = 0; i < length; ++i) {
                codePoint = string.charCodeAt(i);

                // is surrogate component
                if (codePoint > 0xd7ff && codePoint < 0xe000) {
                  // last char was a lead
                  if (!leadSurrogate) {
                    // no lead yet
                    if (codePoint > 0xdbff) {
                      // unexpected trail
                      if ((units -= 3) > -1) bytes.push(0xef, 0xbf, 0xbd);
                      continue;
                    } else if (i + 1 === length) {
                      // unpaired lead
                      if ((units -= 3) > -1) bytes.push(0xef, 0xbf, 0xbd);
                      continue;
                    }

                    // valid lead
                    leadSurrogate = codePoint;

                    continue;
                  }

                  // 2 leads in a row
                  if (codePoint < 0xdc00) {
                    if ((units -= 3) > -1) bytes.push(0xef, 0xbf, 0xbd);
                    leadSurrogate = codePoint;
                    continue;
                  }

                  // valid surrogate pair
                  codePoint =
                    (((leadSurrogate - 0xd800) << 10) | (codePoint - 0xdc00)) +
                    0x10000;
                } else if (leadSurrogate) {
                  // valid bmp char, but last char was a lead
                  if ((units -= 3) > -1) bytes.push(0xef, 0xbf, 0xbd);
                }

                leadSurrogate = null;

                // encode utf8
                if (codePoint < 0x80) {
                  if ((units -= 1) < 0) break;
                  bytes.push(codePoint);
                } else if (codePoint < 0x800) {
                  if ((units -= 2) < 0) break;
                  bytes.push(
                    (codePoint >> 0x6) | 0xc0,
                    (codePoint & 0x3f) | 0x80
                  );
                } else if (codePoint < 0x10000) {
                  if ((units -= 3) < 0) break;
                  bytes.push(
                    (codePoint >> 0xc) | 0xe0,
                    ((codePoint >> 0x6) & 0x3f) | 0x80,
                    (codePoint & 0x3f) | 0x80
                  );
                } else if (codePoint < 0x110000) {
                  if ((units -= 4) < 0) break;
                  bytes.push(
                    (codePoint >> 0x12) | 0xf0,
                    ((codePoint >> 0xc) & 0x3f) | 0x80,
                    ((codePoint >> 0x6) & 0x3f) | 0x80,
                    (codePoint & 0x3f) | 0x80
                  );
                } else {
                  throw new Error("Invalid code point");
                }
              }

              return bytes;
            }

            function asciiToBytes(str) {
              var byteArray = [];
              for (var i = 0; i < str.length; ++i) {
                // Node's code seems to be doing this and not & 0x7F..
                byteArray.push(str.charCodeAt(i) & 0xff);
              }
              return byteArray;
            }

            function utf16leToBytes(str, units) {
              var c, hi, lo;
              var byteArray = [];
              for (var i = 0; i < str.length; ++i) {
                if ((units -= 2) < 0) break;

                c = str.charCodeAt(i);
                hi = c >> 8;
                lo = c % 256;
                byteArray.push(lo);
                byteArray.push(hi);
              }

              return byteArray;
            }

            function base64ToBytes(str) {
              return base64.toByteArray(base64clean(str));
            }

            function blitBuffer(src, dst, offset, length) {
              for (var i = 0; i < length; ++i) {
                if (i + offset >= dst.length || i >= src.length) break;
                dst[i + offset] = src[i];
              }
              return i;
            }

            // ArrayBuffer or Uint8Array objects from other contexts (i.e. iframes) do not pass
            // the `instanceof` check but they should be treated as of that type.
            // See: https://github.com/feross/buffer/issues/166
            function isInstance(obj, type) {
              return (
                obj instanceof type ||
                (obj != null &&
                  obj.constructor != null &&
                  obj.constructor.name != null &&
                  obj.constructor.name === type.name)
              );
            }
            function numberIsNaN(obj) {
              // For IE11 support
              return obj !== obj; // eslint-disable-line no-self-compare
            }
          }).call(this);
        }).call(this, require("buffer").Buffer);
      },
      { "base64-js": 7, buffer: 8, ieee754: 37 },
    ],
    9: [
      function (require, module, exports) {
        "use strict";
        Object.defineProperty(exports, "__esModule", { value: true });
        exports.hasCORS = void 0;
        // imported from https://github.com/component/has-cors
        let value = false;
        try {
          value =
            typeof XMLHttpRequest !== "undefined" &&
            "withCredentials" in new XMLHttpRequest();
        } catch (err) {
          // if XMLHttp support is disabled in IE then it will throw
          // when trying to create
        }
        exports.hasCORS = value;
      },
      {},
    ],
    10: [
      function (require, module, exports) {
        "use strict";
        // imported from https://github.com/galkn/querystring
        /**
         * Compiles a querystring
         * Returns string representation of the object
         *
         * @param {Object}
         * @api private
         */
        Object.defineProperty(exports, "__esModule", { value: true });
        exports.decode = exports.encode = void 0;
        function encode(obj) {
          let str = "";
          for (let i in obj) {
            if (obj.hasOwnProperty(i)) {
              if (str.length) str += "&";
              str += encodeURIComponent(i) + "=" + encodeURIComponent(obj[i]);
            }
          }
          return str;
        }
        exports.encode = encode;
        /**
         * Parses a simple querystring into an object
         *
         * @param {String} qs
         * @api private
         */
        function decode(qs) {
          let qry = {};
          let pairs = qs.split("&");
          for (let i = 0, l = pairs.length; i < l; i++) {
            let pair = pairs[i].split("=");
            qry[decodeURIComponent(pair[0])] = decodeURIComponent(pair[1]);
          }
          return qry;
        }
        exports.decode = decode;
      },
      {},
    ],
    11: [
      function (require, module, exports) {
        "use strict";
        Object.defineProperty(exports, "__esModule", { value: true });
        exports.parse = void 0;
        // imported from https://github.com/galkn/parseuri
        /**
         * Parses an URI
         *
         * @author Steven Levithan <stevenlevithan.com> (MIT license)
         * @api private
         */
        const re =
          /^(?:(?![^:@]+:[^:@\/]*@)(http|https|ws|wss):\/\/)?((?:(([^:@]*)(?::([^:@]*))?)?@)?((?:[a-f0-9]{0,4}:){2,7}[a-f0-9]{0,4}|[^:\/?#]*)(?::(\d*))?)(((\/(?:[^?#](?![^?#\/]*\.[^?#\/.]+(?:[?#]|$)))*\/?)?([^?#\/]*))(?:\?([^#]*))?(?:#(.*))?)/;
        const parts = [
          "source",
          "protocol",
          "authority",
          "userInfo",
          "user",
          "password",
          "host",
          "port",
          "relative",
          "path",
          "directory",
          "file",
          "query",
          "anchor",
        ];
        function parse(str) {
          const src = str,
            b = str.indexOf("["),
            e = str.indexOf("]");
          if (b != -1 && e != -1) {
            str =
              str.substring(0, b) +
              str.substring(b, e).replace(/:/g, ";") +
              str.substring(e, str.length);
          }
          let m = re.exec(str || ""),
            uri = {},
            i = 14;
          while (i--) {
            uri[parts[i]] = m[i] || "";
          }
          if (b != -1 && e != -1) {
            uri.source = src;
            uri.host = uri.host
              .substring(1, uri.host.length - 1)
              .replace(/;/g, ":");
            uri.authority = uri.authority
              .replace("[", "")
              .replace("]", "")
              .replace(/;/g, ":");
            uri.ipv6uri = true;
          }
          uri.pathNames = pathNames(uri, uri["path"]);
          uri.queryKey = queryKey(uri, uri["query"]);
          return uri;
        }
        exports.parse = parse;
        function pathNames(obj, path) {
          const regx = /\/{2,9}/g,
            names = path.replace(regx, "/").split("/");
          if (path.slice(0, 1) == "/" || path.length === 0) {
            names.splice(0, 1);
          }
          if (path.slice(-1) == "/") {
            names.splice(names.length - 1, 1);
          }
          return names;
        }
        function queryKey(uri, query) {
          const data = {};
          query.replace(/(?:^|&)([^&=]*)=?([^&]*)/g, function ($0, $1, $2) {
            if ($1) {
              data[$1] = $2;
            }
          });
          return data;
        }
      },
      {},
    ],
    12: [
      function (require, module, exports) {
        // imported from https://github.com/unshiftio/yeast
        "use strict";
        Object.defineProperty(exports, "__esModule", { value: true });
        exports.yeast = exports.decode = exports.encode = void 0;
        const alphabet =
            "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz-_".split(
              ""
            ),
          length = 64,
          map = {};
        let seed = 0,
          i = 0,
          prev;
        /**
         * Return a string representing the specified number.
         *
         * @param {Number} num The number to convert.
         * @returns {String} The string representation of the number.
         * @api public
         */
        function encode(num) {
          let encoded = "";
          do {
            encoded = alphabet[num % length] + encoded;
            num = Math.floor(num / length);
          } while (num > 0);
          return encoded;
        }
        exports.encode = encode;
        /**
         * Return the integer value specified by the given string.
         *
         * @param {String} str The string to convert.
         * @returns {Number} The integer value represented by the string.
         * @api public
         */
        function decode(str) {
          let decoded = 0;
          for (i = 0; i < str.length; i++) {
            decoded = decoded * length + map[str.charAt(i)];
          }
          return decoded;
        }
        exports.decode = decode;
        /**
         * Yeast: A tiny growing id generator.
         *
         * @returns {String} A unique id.
         * @api public
         */
        function yeast() {
          const now = encode(+new Date());
          if (now !== prev) return (seed = 0), (prev = now);
          return now + "." + encode(seed++);
        }
        exports.yeast = yeast;
        //
        // Map each character to its index.
        //
        for (; i < length; i++) map[alphabet[i]] = i;
      },
      {},
    ],
    13: [
      function (require, module, exports) {
        "use strict";
        Object.defineProperty(exports, "__esModule", { value: true });
        exports.globalThisShim = void 0;
        exports.globalThisShim = (() => {
          if (typeof self !== "undefined") {
            return self;
          } else if (typeof window !== "undefined") {
            return window;
          } else {
            return Function("return this")();
          }
        })();
      },
      {},
    ],
    14: [
      function (require, module, exports) {
        "use strict";
        Object.defineProperty(exports, "__esModule", { value: true });
        exports.nextTick =
          exports.parse =
          exports.installTimerFunctions =
          exports.transports =
          exports.Transport =
          exports.protocol =
          exports.Socket =
            void 0;
        const socket_js_1 = require("./socket.js");
        Object.defineProperty(exports, "Socket", {
          enumerable: true,
          get: function () {
            return socket_js_1.Socket;
          },
        });
        exports.protocol = socket_js_1.Socket.protocol;
        var transport_js_1 = require("./transport.js");
        Object.defineProperty(exports, "Transport", {
          enumerable: true,
          get: function () {
            return transport_js_1.Transport;
          },
        });
        var index_js_1 = require("./transports/index.js");
        Object.defineProperty(exports, "transports", {
          enumerable: true,
          get: function () {
            return index_js_1.transports;
          },
        });
        var util_js_1 = require("./util.js");
        Object.defineProperty(exports, "installTimerFunctions", {
          enumerable: true,
          get: function () {
            return util_js_1.installTimerFunctions;
          },
        });
        var parseuri_js_1 = require("./contrib/parseuri.js");
        Object.defineProperty(exports, "parse", {
          enumerable: true,
          get: function () {
            return parseuri_js_1.parse;
          },
        });
        var websocket_constructor_js_1 = require("./transports/websocket-constructor.js");
        Object.defineProperty(exports, "nextTick", {
          enumerable: true,
          get: function () {
            return websocket_constructor_js_1.nextTick;
          },
        });
      },
      {
        "./contrib/parseuri.js": 11,
        "./socket.js": 15,
        "./transport.js": 16,
        "./transports/index.js": 17,
        "./transports/websocket-constructor.js": 19,
        "./util.js": 22,
      },
    ],
    15: [
      function (require, module, exports) {
        "use strict";
        var __importDefault =
          (this && this.__importDefault) ||
          function (mod) {
            return mod && mod.__esModule ? mod : { default: mod };
          };
        Object.defineProperty(exports, "__esModule", { value: true });
        exports.Socket = void 0;
        const index_js_1 = require("./transports/index.js");
        const util_js_1 = require("./util.js");
        const parseqs_js_1 = require("./contrib/parseqs.js");
        const parseuri_js_1 = require("./contrib/parseuri.js");
        const debug_1 = __importDefault(require("debug")); // debug()
        const component_emitter_1 = require("@socket.io/component-emitter");
        const engine_io_parser_1 = require("engine.io-parser");
        const debug = (0, debug_1.default)("engine.io-client:socket"); // debug()
        class Socket extends component_emitter_1.Emitter {
          /**
           * Socket constructor.
           *
           * @param {String|Object} uri or options
           * @param {Object} opts - options
           * @api public
           */
          constructor(uri, opts = {}) {
            super();
            if (uri && "object" === typeof uri) {
              opts = uri;
              uri = null;
            }
            if (uri) {
              uri = (0, parseuri_js_1.parse)(uri);
              opts.hostname = uri.host;
              opts.secure = uri.protocol === "https" || uri.protocol === "wss";
              opts.port = uri.port;
              if (uri.query) opts.query = uri.query;
            } else if (opts.host) {
              opts.hostname = (0, parseuri_js_1.parse)(opts.host).host;
            }
            (0, util_js_1.installTimerFunctions)(this, opts);
            this.secure =
              null != opts.secure
                ? opts.secure
                : typeof location !== "undefined" &&
                  "https:" === location.protocol;
            if (opts.hostname && !opts.port) {
              // if no port is specified manually, use the protocol default
              opts.port = this.secure ? "443" : "80";
            }
            this.hostname =
              opts.hostname ||
              (typeof location !== "undefined"
                ? location.hostname
                : "localhost");
            this.port =
              opts.port ||
              (typeof location !== "undefined" && location.port
                ? location.port
                : this.secure
                ? "443"
                : "80");
            this.transports = opts.transports || ["polling", "websocket"];
            this.readyState = "";
            this.writeBuffer = [];
            this.prevBufferLen = 0;
            this.opts = Object.assign(
              {
                path: "/engine.io",
                agent: false,
                withCredentials: false,
                upgrade: true,
                timestampParam: "t",
                rememberUpgrade: false,
                rejectUnauthorized: true,
                perMessageDeflate: {
                  threshold: 1024,
                },
                transportOptions: {},
                closeOnBeforeunload: true,
              },
              opts
            );
            this.opts.path = this.opts.path.replace(/\/$/, "") + "/";
            if (typeof this.opts.query === "string") {
              this.opts.query = (0, parseqs_js_1.decode)(this.opts.query);
            }
            // set on handshake
            this.id = null;
            this.upgrades = null;
            this.pingInterval = null;
            this.pingTimeout = null;
            // set on heartbeat
            this.pingTimeoutTimer = null;
            if (typeof addEventListener === "function") {
              if (this.opts.closeOnBeforeunload) {
                // Firefox closes the connection when the "beforeunload" event is emitted but not Chrome. This event listener
                // ensures every browser behaves the same (no "disconnect" event at the Socket.IO level when the page is
                // closed/reloaded)
                this.beforeunloadEventListener = () => {
                  if (this.transport) {
                    // silently close the transport
                    this.transport.removeAllListeners();
                    this.transport.close();
                  }
                };
                addEventListener(
                  "beforeunload",
                  this.beforeunloadEventListener,
                  false
                );
              }
              if (this.hostname !== "localhost") {
                this.offlineEventListener = () => {
                  this.onClose("transport close", {
                    description: "network connection lost",
                  });
                };
                addEventListener("offline", this.offlineEventListener, false);
              }
            }
            this.open();
          }
          /**
           * Creates transport of the given type.
           *
           * @param {String} transport name
           * @return {Transport}
           * @api private
           */
          createTransport(name) {
            debug('creating transport "%s"', name);
            const query = Object.assign({}, this.opts.query);
            // append engine.io protocol identifier
            query.EIO = engine_io_parser_1.protocol;
            // transport name
            query.transport = name;
            // session id if we already have one
            if (this.id) query.sid = this.id;
            const opts = Object.assign(
              {},
              this.opts.transportOptions[name],
              this.opts,
              {
                query,
                socket: this,
                hostname: this.hostname,
                secure: this.secure,
                port: this.port,
              }
            );
            debug("options: %j", opts);
            return new index_js_1.transports[name](opts);
          }
          /**
           * Initializes transport to use and starts probe.
           *
           * @api private
           */
          open() {
            let transport;
            if (
              this.opts.rememberUpgrade &&
              Socket.priorWebsocketSuccess &&
              this.transports.indexOf("websocket") !== -1
            ) {
              transport = "websocket";
            } else if (0 === this.transports.length) {
              // Emit error on next tick so it can be listened to
              this.setTimeoutFn(() => {
                this.emitReserved("error", "No transports available");
              }, 0);
              return;
            } else {
              transport = this.transports[0];
            }
            this.readyState = "opening";
            // Retry with the next transport if the transport is disabled (jsonp: false)
            try {
              transport = this.createTransport(transport);
            } catch (e) {
              debug("error while creating transport: %s", e);
              this.transports.shift();
              this.open();
              return;
            }
            transport.open();
            this.setTransport(transport);
          }
          /**
           * Sets the current transport. Disables the existing one (if any).
           *
           * @api private
           */
          setTransport(transport) {
            debug("setting transport %s", transport.name);
            if (this.transport) {
              debug("clearing existing transport %s", this.transport.name);
              this.transport.removeAllListeners();
            }
            // set up transport
            this.transport = transport;
            // set up transport listeners
            transport
              .on("drain", this.onDrain.bind(this))
              .on("packet", this.onPacket.bind(this))
              .on("error", this.onError.bind(this))
              .on("close", (reason) => this.onClose("transport close", reason));
          }
          /**
           * Probes a transport.
           *
           * @param {String} transport name
           * @api private
           */
          probe(name) {
            debug('probing transport "%s"', name);
            let transport = this.createTransport(name);
            let failed = false;
            Socket.priorWebsocketSuccess = false;
            const onTransportOpen = () => {
              if (failed) return;
              debug('probe transport "%s" opened', name);
              transport.send([{ type: "ping", data: "probe" }]);
              transport.once("packet", (msg) => {
                if (failed) return;
                if ("pong" === msg.type && "probe" === msg.data) {
                  debug('probe transport "%s" pong', name);
                  this.upgrading = true;
                  this.emitReserved("upgrading", transport);
                  if (!transport) return;
                  Socket.priorWebsocketSuccess = "websocket" === transport.name;
                  debug('pausing current transport "%s"', this.transport.name);
                  this.transport.pause(() => {
                    if (failed) return;
                    if ("closed" === this.readyState) return;
                    debug("changing transport and sending upgrade packet");
                    cleanup();
                    this.setTransport(transport);
                    transport.send([{ type: "upgrade" }]);
                    this.emitReserved("upgrade", transport);
                    transport = null;
                    this.upgrading = false;
                    this.flush();
                  });
                } else {
                  debug('probe transport "%s" failed', name);
                  const err = new Error("probe error");
                  // @ts-ignore
                  err.transport = transport.name;
                  this.emitReserved("upgradeError", err);
                }
              });
            };
            function freezeTransport() {
              if (failed) return;
              // Any callback called by transport should be ignored since now
              failed = true;
              cleanup();
              transport.close();
              transport = null;
            }
            // Handle any error that happens while probing
            const onerror = (err) => {
              const error = new Error("probe error: " + err);
              // @ts-ignore
              error.transport = transport.name;
              freezeTransport();
              debug(
                'probe transport "%s" failed because of error: %s',
                name,
                err
              );
              this.emitReserved("upgradeError", error);
            };
            function onTransportClose() {
              onerror("transport closed");
            }
            // When the socket is closed while we're probing
            function onclose() {
              onerror("socket closed");
            }
            // When the socket is upgraded while we're probing
            function onupgrade(to) {
              if (transport && to.name !== transport.name) {
                debug('"%s" works - aborting "%s"', to.name, transport.name);
                freezeTransport();
              }
            }
            // Remove all listeners on the transport and on self
            const cleanup = () => {
              transport.removeListener("open", onTransportOpen);
              transport.removeListener("error", onerror);
              transport.removeListener("close", onTransportClose);
              this.off("close", onclose);
              this.off("upgrading", onupgrade);
            };
            transport.once("open", onTransportOpen);
            transport.once("error", onerror);
            transport.once("close", onTransportClose);
            this.once("close", onclose);
            this.once("upgrading", onupgrade);
            transport.open();
          }
          /**
           * Called when connection is deemed open.
           *
           * @api private
           */
          onOpen() {
            debug("socket open");
            this.readyState = "open";
            Socket.priorWebsocketSuccess = "websocket" === this.transport.name;
            this.emitReserved("open");
            this.flush();
            // we check for `readyState` in case an `open`
            // listener already closed the socket
            if (
              "open" === this.readyState &&
              this.opts.upgrade &&
              this.transport.pause
            ) {
              debug("starting upgrade probes");
              let i = 0;
              const l = this.upgrades.length;
              for (; i < l; i++) {
                this.probe(this.upgrades[i]);
              }
            }
          }
          /**
           * Handles a packet.
           *
           * @api private
           */
          onPacket(packet) {
            if (
              "opening" === this.readyState ||
              "open" === this.readyState ||
              "closing" === this.readyState
            ) {
              debug(
                'socket receive: type "%s", data "%s"',
                packet.type,
                packet.data
              );
              this.emitReserved("packet", packet);
              // Socket is live - any packet counts
              this.emitReserved("heartbeat");
              switch (packet.type) {
                case "open":
                  this.onHandshake(JSON.parse(packet.data));
                  break;
                case "ping":
                  this.resetPingTimeout();
                  this.sendPacket("pong");
                  this.emitReserved("ping");
                  this.emitReserved("pong");
                  break;
                case "error":
                  const err = new Error("server error");
                  // @ts-ignore
                  err.code = packet.data;
                  this.onError(err);
                  break;
                case "message":
                  this.emitReserved("data", packet.data);
                  this.emitReserved("message", packet.data);
                  break;
              }
            } else {
              debug(
                'packet received with socket readyState "%s"',
                this.readyState
              );
            }
          }
          /**
           * Called upon handshake completion.
           *
           * @param {Object} data - handshake obj
           * @api private
           */
          onHandshake(data) {
            this.emitReserved("handshake", data);
            this.id = data.sid;
            this.transport.query.sid = data.sid;
            this.upgrades = this.filterUpgrades(data.upgrades);
            this.pingInterval = data.pingInterval;
            this.pingTimeout = data.pingTimeout;
            this.maxPayload = data.maxPayload;
            this.onOpen();
            // In case open handler closes socket
            if ("closed" === this.readyState) return;
            this.resetPingTimeout();
          }
          /**
           * Sets and resets ping timeout timer based on server pings.
           *
           * @api private
           */
          resetPingTimeout() {
            this.clearTimeoutFn(this.pingTimeoutTimer);
            this.pingTimeoutTimer = this.setTimeoutFn(() => {
              this.onClose("ping timeout");
            }, this.pingInterval + this.pingTimeout);
            if (this.opts.autoUnref) {
              this.pingTimeoutTimer.unref();
            }
          }
          /**
           * Called on `drain` event
           *
           * @api private
           */
          onDrain() {
            this.writeBuffer.splice(0, this.prevBufferLen);
            // setting prevBufferLen = 0 is very important
            // for example, when upgrading, upgrade packet is sent over,
            // and a nonzero prevBufferLen could cause problems on `drain`
            this.prevBufferLen = 0;
            if (0 === this.writeBuffer.length) {
              this.emitReserved("drain");
            } else {
              this.flush();
            }
          }
          /**
           * Flush write buffers.
           *
           * @api private
           */
          flush() {
            if (
              "closed" !== this.readyState &&
              this.transport.writable &&
              !this.upgrading &&
              this.writeBuffer.length
            ) {
              const packets = this.getWritablePackets();
              debug("flushing %d packets in socket", packets.length);
              this.transport.send(packets);
              // keep track of current length of writeBuffer
              // splice writeBuffer and callbackBuffer on `drain`
              this.prevBufferLen = packets.length;
              this.emitReserved("flush");
            }
          }
          /**
           * Ensure the encoded size of the writeBuffer is below the maxPayload value sent by the server (only for HTTP
           * long-polling)
           *
           * @private
           */
          getWritablePackets() {
            const shouldCheckPayloadSize =
              this.maxPayload &&
              this.transport.name === "polling" &&
              this.writeBuffer.length > 1;
            if (!shouldCheckPayloadSize) {
              return this.writeBuffer;
            }
            let payloadSize = 1; // first packet type
            for (let i = 0; i < this.writeBuffer.length; i++) {
              const data = this.writeBuffer[i].data;
              if (data) {
                payloadSize += (0, util_js_1.byteLength)(data);
              }
              if (i > 0 && payloadSize > this.maxPayload) {
                debug(
                  "only send %d out of %d packets",
                  i,
                  this.writeBuffer.length
                );
                return this.writeBuffer.slice(0, i);
              }
              payloadSize += 2; // separator + packet type
            }
            debug("payload size is %d (max: %d)", payloadSize, this.maxPayload);
            return this.writeBuffer;
          }
          /**
           * Sends a message.
           *
           * @param {String} message.
           * @param {Function} callback function.
           * @param {Object} options.
           * @return {Socket} for chaining.
           * @api public
           */
          write(msg, options, fn) {
            this.sendPacket("message", msg, options, fn);
            return this;
          }
          send(msg, options, fn) {
            this.sendPacket("message", msg, options, fn);
            return this;
          }
          /**
           * Sends a packet.
           *
           * @param {String} packet type.
           * @param {String} data.
           * @param {Object} options.
           * @param {Function} callback function.
           * @api private
           */
          sendPacket(type, data, options, fn) {
            if ("function" === typeof data) {
              fn = data;
              data = undefined;
            }
            if ("function" === typeof options) {
              fn = options;
              options = null;
            }
            if ("closing" === this.readyState || "closed" === this.readyState) {
              return;
            }
            options = options || {};
            options.compress = false !== options.compress;
            const packet = {
              type: type,
              data: data,
              options: options,
            };
            this.emitReserved("packetCreate", packet);
            this.writeBuffer.push(packet);
            if (fn) this.once("flush", fn);
            this.flush();
          }
          /**
           * Closes the connection.
           *
           * @api public
           */
          close() {
            const close = () => {
              this.onClose("forced close");
              debug("socket closing - telling transport to close");
              this.transport.close();
            };
            const cleanupAndClose = () => {
              this.off("upgrade", cleanupAndClose);
              this.off("upgradeError", cleanupAndClose);
              close();
            };
            const waitForUpgrade = () => {
              // wait for upgrade to finish since we can't send packets while pausing a transport
              this.once("upgrade", cleanupAndClose);
              this.once("upgradeError", cleanupAndClose);
            };
            if ("opening" === this.readyState || "open" === this.readyState) {
              this.readyState = "closing";
              if (this.writeBuffer.length) {
                this.once("drain", () => {
                  if (this.upgrading) {
                    waitForUpgrade();
                  } else {
                    close();
                  }
                });
              } else if (this.upgrading) {
                waitForUpgrade();
              } else {
                close();
              }
            }
            return this;
          }
          /**
           * Called upon transport error
           *
           * @api private
           */
          onError(err) {
            debug("socket error %j", err);
            Socket.priorWebsocketSuccess = false;
            this.emitReserved("error", err);
            this.onClose("transport error", err);
          }
          /**
           * Called upon transport close.
           *
           * @api private
           */
          onClose(reason, description) {
            if (
              "opening" === this.readyState ||
              "open" === this.readyState ||
              "closing" === this.readyState
            ) {
              debug('socket close with reason: "%s"', reason);
              // clear timers
              this.clearTimeoutFn(this.pingTimeoutTimer);
              // stop event from firing again for transport
              this.transport.removeAllListeners("close");
              // ensure transport won't stay open
              this.transport.close();
              // ignore further transport communication
              this.transport.removeAllListeners();
              if (typeof removeEventListener === "function") {
                removeEventListener(
                  "beforeunload",
                  this.beforeunloadEventListener,
                  false
                );
                removeEventListener(
                  "offline",
                  this.offlineEventListener,
                  false
                );
              }
              // set ready state
              this.readyState = "closed";
              // clear session id
              this.id = null;
              // emit close event
              this.emitReserved("close", reason, description);
              // clean buffers after, so users can still
              // grab the buffers on `close` event
              this.writeBuffer = [];
              this.prevBufferLen = 0;
            }
          }
          /**
           * Filters upgrades, returning only those matching client transports.
           *
           * @param {Array} server upgrades
           * @api private
           *
           */
          filterUpgrades(upgrades) {
            const filteredUpgrades = [];
            let i = 0;
            const j = upgrades.length;
            for (; i < j; i++) {
              if (~this.transports.indexOf(upgrades[i]))
                filteredUpgrades.push(upgrades[i]);
            }
            return filteredUpgrades;
          }
        }
        exports.Socket = Socket;
        Socket.protocol = engine_io_parser_1.protocol;
      },
      {
        "./contrib/parseqs.js": 10,
        "./contrib/parseuri.js": 11,
        "./transports/index.js": 17,
        "./util.js": 22,
        "@socket.io/component-emitter": 1,
        debug: 23,
        "engine.io-parser": 30,
      },
    ],
    16: [
      function (require, module, exports) {
        "use strict";
        var __importDefault =
          (this && this.__importDefault) ||
          function (mod) {
            return mod && mod.__esModule ? mod : { default: mod };
          };
        Object.defineProperty(exports, "__esModule", { value: true });
        exports.Transport = void 0;
        const engine_io_parser_1 = require("engine.io-parser");
        const component_emitter_1 = require("@socket.io/component-emitter");
        const util_js_1 = require("./util.js");
        const debug_1 = __importDefault(require("debug")); // debug()
        const debug = (0, debug_1.default)("engine.io-client:transport"); // debug()
        class TransportError extends Error {
          constructor(reason, description, context) {
            super(reason);
            this.description = description;
            this.context = context;
            this.type = "TransportError";
          }
        }
        class Transport extends component_emitter_1.Emitter {
          /**
           * Transport abstract constructor.
           *
           * @param {Object} options.
           * @api private
           */
          constructor(opts) {
            super();
            this.writable = false;
            (0, util_js_1.installTimerFunctions)(this, opts);
            this.opts = opts;
            this.query = opts.query;
            this.readyState = "";
            this.socket = opts.socket;
          }
          /**
           * Emits an error.
           *
           * @param {String} reason
           * @param description
           * @param context - the error context
           * @return {Transport} for chaining
           * @api protected
           */
          onError(reason, description, context) {
            super.emitReserved(
              "error",
              new TransportError(reason, description, context)
            );
            return this;
          }
          /**
           * Opens the transport.
           *
           * @api public
           */
          open() {
            if ("closed" === this.readyState || "" === this.readyState) {
              this.readyState = "opening";
              this.doOpen();
            }
            return this;
          }
          /**
           * Closes the transport.
           *
           * @api public
           */
          close() {
            if ("opening" === this.readyState || "open" === this.readyState) {
              this.doClose();
              this.onClose();
            }
            return this;
          }
          /**
           * Sends multiple packets.
           *
           * @param {Array} packets
           * @api public
           */
          send(packets) {
            if ("open" === this.readyState) {
              this.write(packets);
            } else {
              // this might happen if the transport was silently closed in the beforeunload event handler
              debug("transport is not open, discarding packets");
            }
          }
          /**
           * Called upon open
           *
           * @api protected
           */
          onOpen() {
            this.readyState = "open";
            this.writable = true;
            super.emitReserved("open");
          }
          /**
           * Called with data.
           *
           * @param {String} data
           * @api protected
           */
          onData(data) {
            const packet = (0, engine_io_parser_1.decodePacket)(
              data,
              this.socket.binaryType
            );
            this.onPacket(packet);
          }
          /**
           * Called with a decoded packet.
           *
           * @api protected
           */
          onPacket(packet) {
            super.emitReserved("packet", packet);
          }
          /**
           * Called upon close.
           *
           * @api protected
           */
          onClose(details) {
            this.readyState = "closed";
            super.emitReserved("close", details);
          }
        }
        exports.Transport = Transport;
      },
      {
        "./util.js": 22,
        "@socket.io/component-emitter": 1,
        debug: 23,
        "engine.io-parser": 30,
      },
    ],
    17: [
      function (require, module, exports) {
        "use strict";
        Object.defineProperty(exports, "__esModule", { value: true });
        exports.transports = void 0;
        const polling_js_1 = require("./polling.js");
        const websocket_js_1 = require("./websocket.js");
        exports.transports = {
          websocket: websocket_js_1.WS,
          polling: polling_js_1.Polling,
        };
      },
      { "./polling.js": 18, "./websocket.js": 20 },
    ],
    18: [
      function (require, module, exports) {
        "use strict";
        var __importDefault =
          (this && this.__importDefault) ||
          function (mod) {
            return mod && mod.__esModule ? mod : { default: mod };
          };
        Object.defineProperty(exports, "__esModule", { value: true });
        exports.Request = exports.Polling = void 0;
        const transport_js_1 = require("../transport.js");
        const debug_1 = __importDefault(require("debug")); // debug()
        const yeast_js_1 = require("../contrib/yeast.js");
        const parseqs_js_1 = require("../contrib/parseqs.js");
        const engine_io_parser_1 = require("engine.io-parser");
        const xmlhttprequest_js_1 = require("./xmlhttprequest.js");
        const component_emitter_1 = require("@socket.io/component-emitter");
        const util_js_1 = require("../util.js");
        const globalThis_js_1 = require("../globalThis.js");
        const debug = (0, debug_1.default)("engine.io-client:polling"); // debug()
        function empty() {}
        const hasXHR2 = (function () {
          const xhr = new xmlhttprequest_js_1.XHR({
            xdomain: false,
          });
          return null != xhr.responseType;
        })();
        class Polling extends transport_js_1.Transport {
          /**
           * XHR Polling constructor.
           *
           * @param {Object} opts
           * @api public
           */
          constructor(opts) {
            super(opts);
            this.polling = false;
            if (typeof location !== "undefined") {
              const isSSL = "https:" === location.protocol;
              let port = location.port;
              // some user agents have empty `location.port`
              if (!port) {
                port = isSSL ? "443" : "80";
              }
              this.xd =
                (typeof location !== "undefined" &&
                  opts.hostname !== location.hostname) ||
                port !== opts.port;
              this.xs = opts.secure !== isSSL;
            }
            /**
             * XHR supports binary
             */
            const forceBase64 = opts && opts.forceBase64;
            this.supportsBinary = hasXHR2 && !forceBase64;
          }
          /**
           * Transport name.
           */
          get name() {
            return "polling";
          }
          /**
           * Opens the socket (triggers polling). We write a PING message to determine
           * when the transport is open.
           *
           * @api private
           */
          doOpen() {
            this.poll();
          }
          /**
           * Pauses polling.
           *
           * @param {Function} callback upon buffers are flushed and transport is paused
           * @api private
           */
          pause(onPause) {
            this.readyState = "pausing";
            const pause = () => {
              debug("paused");
              this.readyState = "paused";
              onPause();
            };
            if (this.polling || !this.writable) {
              let total = 0;
              if (this.polling) {
                debug("we are currently polling - waiting to pause");
                total++;
                this.once("pollComplete", function () {
                  debug("pre-pause polling complete");
                  --total || pause();
                });
              }
              if (!this.writable) {
                debug("we are currently writing - waiting to pause");
                total++;
                this.once("drain", function () {
                  debug("pre-pause writing complete");
                  --total || pause();
                });
              }
            } else {
              pause();
            }
          }
          /**
           * Starts polling cycle.
           *
           * @api public
           */
          poll() {
            debug("polling");
            this.polling = true;
            this.doPoll();
            this.emitReserved("poll");
          }
          /**
           * Overloads onData to detect payloads.
           *
           * @api private
           */
          onData(data) {
            debug("polling got data %s", data);
            const callback = (packet) => {
              // if its the first message we consider the transport open
              if ("opening" === this.readyState && packet.type === "open") {
                this.onOpen();
              }
              // if its a close packet, we close the ongoing requests
              if ("close" === packet.type) {
                this.onClose({ description: "transport closed by the server" });
                return false;
              }
              // otherwise bypass onData and handle the message
              this.onPacket(packet);
            };
            // decode payload
            (0, engine_io_parser_1.decodePayload)(
              data,
              this.socket.binaryType
            ).forEach(callback);
            // if an event did not trigger closing
            if ("closed" !== this.readyState) {
              // if we got data we're not polling
              this.polling = false;
              this.emitReserved("pollComplete");
              if ("open" === this.readyState) {
                this.poll();
              } else {
                debug('ignoring poll - transport state "%s"', this.readyState);
              }
            }
          }
          /**
           * For polling, send a close packet.
           *
           * @api private
           */
          doClose() {
            const close = () => {
              debug("writing close packet");
              this.write([{ type: "close" }]);
            };
            if ("open" === this.readyState) {
              debug("transport open - closing");
              close();
            } else {
              // in case we're trying to close while
              // handshaking is in progress (GH-164)
              debug("transport not open - deferring close");
              this.once("open", close);
            }
          }
          /**
           * Writes a packets payload.
           *
           * @param {Array} data packets
           * @param {Function} drain callback
           * @api private
           */
          write(packets) {
            this.writable = false;
            (0, engine_io_parser_1.encodePayload)(packets, (data) => {
              this.doWrite(data, () => {
                this.writable = true;
                this.emitReserved("drain");
              });
            });
          }
          /**
           * Generates uri for connection.
           *
           * @api private
           */
          uri() {
            let query = this.query || {};
            const schema = this.opts.secure ? "https" : "http";
            let port = "";
            // cache busting is forced
            if (false !== this.opts.timestampRequests) {
              query[this.opts.timestampParam] = (0, yeast_js_1.yeast)();
            }
            if (!this.supportsBinary && !query.sid) {
              query.b64 = 1;
            }
            // avoid port if default for schema
            if (
              this.opts.port &&
              (("https" === schema && Number(this.opts.port) !== 443) ||
                ("http" === schema && Number(this.opts.port) !== 80))
            ) {
              port = ":" + this.opts.port;
            }
            const encodedQuery = (0, parseqs_js_1.encode)(query);
            const ipv6 = this.opts.hostname.indexOf(":") !== -1;
            return (
              schema +
              "://" +
              (ipv6 ? "[" + this.opts.hostname + "]" : this.opts.hostname) +
              port +
              this.opts.path +
              (encodedQuery.length ? "?" + encodedQuery : "")
            );
          }
          /**
           * Creates a request.
           *
           * @param {String} method
           * @api private
           */
          request(opts = {}) {
            Object.assign(opts, { xd: this.xd, xs: this.xs }, this.opts);
            return new Request(this.uri(), opts);
          }
          /**
           * Sends data.
           *
           * @param {String} data to send.
           * @param {Function} called upon flush.
           * @api private
           */
          doWrite(data, fn) {
            const req = this.request({
              method: "POST",
              data: data,
            });
            req.on("success", fn);
            req.on("error", (xhrStatus, context) => {
              this.onError("xhr post error", xhrStatus, context);
            });
          }
          /**
           * Starts a poll cycle.
           *
           * @api private
           */
          doPoll() {
            debug("xhr poll");
            const req = this.request();
            req.on("data", this.onData.bind(this));
            req.on("error", (xhrStatus, context) => {
              this.onError("xhr poll error", xhrStatus, context);
            });
            this.pollXhr = req;
          }
        }
        exports.Polling = Polling;
        class Request extends component_emitter_1.Emitter {
          /**
           * Request constructor
           *
           * @param {Object} options
           * @api public
           */
          constructor(uri, opts) {
            super();
            (0, util_js_1.installTimerFunctions)(this, opts);
            this.opts = opts;
            this.method = opts.method || "GET";
            this.uri = uri;
            this.async = false !== opts.async;
            this.data = undefined !== opts.data ? opts.data : null;
            this.create();
          }
          /**
           * Creates the XHR object and sends the request.
           *
           * @api private
           */
          create() {
            const opts = (0, util_js_1.pick)(
              this.opts,
              "agent",
              "pfx",
              "key",
              "passphrase",
              "cert",
              "ca",
              "ciphers",
              "rejectUnauthorized",
              "autoUnref"
            );
            opts.xdomain = !!this.opts.xd;
            opts.xscheme = !!this.opts.xs;
            const xhr = (this.xhr = new xmlhttprequest_js_1.XHR(opts));
            try {
              debug("xhr open %s: %s", this.method, this.uri);
              xhr.open(this.method, this.uri, this.async);
              try {
                if (this.opts.extraHeaders) {
                  xhr.setDisableHeaderCheck && xhr.setDisableHeaderCheck(true);
                  for (let i in this.opts.extraHeaders) {
                    if (this.opts.extraHeaders.hasOwnProperty(i)) {
                      xhr.setRequestHeader(i, this.opts.extraHeaders[i]);
                    }
                  }
                }
              } catch (e) {}
              if ("POST" === this.method) {
                try {
                  xhr.setRequestHeader(
                    "Content-type",
                    "text/plain;charset=UTF-8"
                  );
                } catch (e) {}
              }
              try {
                xhr.setRequestHeader("Accept", "*/*");
              } catch (e) {}
              // ie6 check
              if ("withCredentials" in xhr) {
                xhr.withCredentials = this.opts.withCredentials;
              }
              if (this.opts.requestTimeout) {
                xhr.timeout = this.opts.requestTimeout;
              }
              xhr.onreadystatechange = () => {
                if (4 !== xhr.readyState) return;
                if (200 === xhr.status || 1223 === xhr.status) {
                  this.onLoad();
                } else {
                  // make sure the `error` event handler that's user-set
                  // does not throw in the same tick and gets caught here
                  this.setTimeoutFn(() => {
                    this.onError(
                      typeof xhr.status === "number" ? xhr.status : 0
                    );
                  }, 0);
                }
              };
              debug("xhr data %s", this.data);
              xhr.send(this.data);
            } catch (e) {
              // Need to defer since .create() is called directly from the constructor
              // and thus the 'error' event can only be only bound *after* this exception
              // occurs.  Therefore, also, we cannot throw here at all.
              this.setTimeoutFn(() => {
                this.onError(e);
              }, 0);
              return;
            }
            if (typeof document !== "undefined") {
              this.index = Request.requestsCount++;
              Request.requests[this.index] = this;
            }
          }
          /**
           * Called upon error.
           *
           * @api private
           */
          onError(err) {
            this.emitReserved("error", err, this.xhr);
            this.cleanup(true);
          }
          /**
           * Cleans up house.
           *
           * @api private
           */
          cleanup(fromError) {
            if ("undefined" === typeof this.xhr || null === this.xhr) {
              return;
            }
            this.xhr.onreadystatechange = empty;
            if (fromError) {
              try {
                this.xhr.abort();
              } catch (e) {}
            }
            if (typeof document !== "undefined") {
              delete Request.requests[this.index];
            }
            this.xhr = null;
          }
          /**
           * Called upon load.
           *
           * @api private
           */
          onLoad() {
            const data = this.xhr.responseText;
            if (data !== null) {
              this.emitReserved("data", data);
              this.emitReserved("success");
              this.cleanup();
            }
          }
          /**
           * Aborts the request.
           *
           * @api public
           */
          abort() {
            this.cleanup();
          }
        }
        exports.Request = Request;
        Request.requestsCount = 0;
        Request.requests = {};
        /**
         * Aborts pending requests when unloading the window. This is needed to prevent
         * memory leaks (e.g. when using IE) and to ensure that no spurious error is
         * emitted.
         */
        if (typeof document !== "undefined") {
          // @ts-ignore
          if (typeof attachEvent === "function") {
            // @ts-ignore
            attachEvent("onunload", unloadHandler);
          } else if (typeof addEventListener === "function") {
            const terminationEvent =
              "onpagehide" in globalThis_js_1.globalThisShim
                ? "pagehide"
                : "unload";
            addEventListener(terminationEvent, unloadHandler, false);
          }
        }
        function unloadHandler() {
          for (let i in Request.requests) {
            if (Request.requests.hasOwnProperty(i)) {
              Request.requests[i].abort();
            }
          }
        }
      },
      {
        "../contrib/parseqs.js": 10,
        "../contrib/yeast.js": 12,
        "../globalThis.js": 13,
        "../transport.js": 16,
        "../util.js": 22,
        "./xmlhttprequest.js": 21,
        "@socket.io/component-emitter": 1,
        debug: 23,
        "engine.io-parser": 30,
      },
    ],
    19: [
      function (require, module, exports) {
        "use strict";
        Object.defineProperty(exports, "__esModule", { value: true });
        exports.defaultBinaryType =
          exports.usingBrowserWebSocket =
          exports.WebSocket =
          exports.nextTick =
            void 0;
        const globalThis_js_1 = require("../globalThis.js");
        exports.nextTick = (() => {
          const isPromiseAvailable =
            typeof Promise === "function" &&
            typeof Promise.resolve === "function";
          if (isPromiseAvailable) {
            return (cb) => Promise.resolve().then(cb);
          } else {
            return (cb, setTimeoutFn) => setTimeoutFn(cb, 0);
          }
        })();
        exports.WebSocket =
          globalThis_js_1.globalThisShim.WebSocket ||
          globalThis_js_1.globalThisShim.MozWebSocket;
        exports.usingBrowserWebSocket = true;
        exports.defaultBinaryType = "arraybuffer";
      },
      { "../globalThis.js": 13 },
    ],
    20: [
      function (require, module, exports) {
        (function (Buffer) {
          (function () {
            "use strict";
            var __importDefault =
              (this && this.__importDefault) ||
              function (mod) {
                return mod && mod.__esModule ? mod : { default: mod };
              };
            Object.defineProperty(exports, "__esModule", { value: true });
            exports.WS = void 0;
            const transport_js_1 = require("../transport.js");
            const parseqs_js_1 = require("../contrib/parseqs.js");
            const yeast_js_1 = require("../contrib/yeast.js");
            const util_js_1 = require("../util.js");
            const websocket_constructor_js_1 = require("./websocket-constructor.js");
            const debug_1 = __importDefault(require("debug")); // debug()
            const engine_io_parser_1 = require("engine.io-parser");
            const debug = (0, debug_1.default)("engine.io-client:websocket"); // debug()
            // detect ReactNative environment
            const isReactNative =
              typeof navigator !== "undefined" &&
              typeof navigator.product === "string" &&
              navigator.product.toLowerCase() === "reactnative";
            class WS extends transport_js_1.Transport {
              /**
               * WebSocket transport constructor.
               *
               * @api {Object} connection options
               * @api public
               */
              constructor(opts) {
                super(opts);
                this.supportsBinary = !opts.forceBase64;
              }
              /**
               * Transport name.
               *
               * @api public
               */
              get name() {
                return "websocket";
              }
              /**
               * Opens socket.
               *
               * @api private
               */
              doOpen() {
                if (!this.check()) {
                  // let probe timeout
                  return;
                }
                const uri = this.uri();
                const protocols = this.opts.protocols;
                // React Native only supports the 'headers' option, and will print a warning if anything else is passed
                const opts = isReactNative
                  ? {}
                  : (0, util_js_1.pick)(
                      this.opts,
                      "agent",
                      "perMessageDeflate",
                      "pfx",
                      "key",
                      "passphrase",
                      "cert",
                      "ca",
                      "ciphers",
                      "rejectUnauthorized",
                      "localAddress",
                      "protocolVersion",
                      "origin",
                      "maxPayload",
                      "family",
                      "checkServerIdentity"
                    );
                if (this.opts.extraHeaders) {
                  opts.headers = this.opts.extraHeaders;
                }
                try {
                  this.ws =
                    websocket_constructor_js_1.usingBrowserWebSocket &&
                    !isReactNative
                      ? protocols
                        ? new websocket_constructor_js_1.WebSocket(
                            uri,
                            protocols
                          )
                        : new websocket_constructor_js_1.WebSocket(uri)
                      : new websocket_constructor_js_1.WebSocket(
                          uri,
                          protocols,
                          opts
                        );
                } catch (err) {
                  return this.emitReserved("error", err);
                }
                this.ws.binaryType =
                  this.socket.binaryType ||
                  websocket_constructor_js_1.defaultBinaryType;
                this.addEventListeners();
              }
              /**
               * Adds event listeners to the socket
               *
               * @api private
               */
              addEventListeners() {
                this.ws.onopen = () => {
                  if (this.opts.autoUnref) {
                    this.ws._socket.unref();
                  }
                  this.onOpen();
                };
                this.ws.onclose = (closeEvent) =>
                  this.onClose({
                    description: "websocket connection closed",
                    context: closeEvent,
                  });
                this.ws.onmessage = (ev) => this.onData(ev.data);
                this.ws.onerror = (e) => this.onError("websocket error", e);
              }
              /**
               * Writes data to socket.
               *
               * @param {Array} array of packets.
               * @api private
               */
              write(packets) {
                this.writable = false;
                // encodePacket efficient as it uses WS framing
                // no need for encodePayload
                for (let i = 0; i < packets.length; i++) {
                  const packet = packets[i];
                  const lastPacket = i === packets.length - 1;
                  (0, engine_io_parser_1.encodePacket)(
                    packet,
                    this.supportsBinary,
                    (data) => {
                      // always create a new object (GH-437)
                      const opts = {};
                      if (!websocket_constructor_js_1.usingBrowserWebSocket) {
                        if (packet.options) {
                          opts.compress = packet.options.compress;
                        }
                        if (this.opts.perMessageDeflate) {
                          const len =
                            // @ts-ignore
                            "string" === typeof data
                              ? Buffer.byteLength(data)
                              : data.length;
                          if (len < this.opts.perMessageDeflate.threshold) {
                            opts.compress = false;
                          }
                        }
                      }
                      // Sometimes the websocket has already been closed but the browser didn't
                      // have a chance of informing us about it yet, in that case send will
                      // throw an error
                      try {
                        if (websocket_constructor_js_1.usingBrowserWebSocket) {
                          // TypeError is thrown when passing the second argument on Safari
                          this.ws.send(data);
                        } else {
                          this.ws.send(data, opts);
                        }
                      } catch (e) {
                        debug("websocket closed before onclose event");
                      }
                      if (lastPacket) {
                        // fake drain
                        // defer to next tick to allow Socket to clear writeBuffer
                        (0, websocket_constructor_js_1.nextTick)(() => {
                          this.writable = true;
                          this.emitReserved("drain");
                        }, this.setTimeoutFn);
                      }
                    }
                  );
                }
              }
              /**
               * Closes socket.
               *
               * @api private
               */
              doClose() {
                if (typeof this.ws !== "undefined") {
                  this.ws.close();
                  this.ws = null;
                }
              }
              /**
               * Generates uri for connection.
               *
               * @api private
               */
              uri() {
                let query = this.query || {};
                const schema = this.opts.secure ? "wss" : "ws";
                let port = "";
                // avoid port if default for schema
                if (
                  this.opts.port &&
                  (("wss" === schema && Number(this.opts.port) !== 443) ||
                    ("ws" === schema && Number(this.opts.port) !== 80))
                ) {
                  port = ":" + this.opts.port;
                }
                // append timestamp to URI
                if (this.opts.timestampRequests) {
                  query[this.opts.timestampParam] = (0, yeast_js_1.yeast)();
                }
                // communicate binary support capabilities
                if (!this.supportsBinary) {
                  query.b64 = 1;
                }
                const encodedQuery = (0, parseqs_js_1.encode)(query);
                const ipv6 = this.opts.hostname.indexOf(":") !== -1;
                return (
                  schema +
                  "://" +
                  (ipv6 ? "[" + this.opts.hostname + "]" : this.opts.hostname) +
                  port +
                  this.opts.path +
                  (encodedQuery.length ? "?" + encodedQuery : "")
                );
              }
              /**
               * Feature detection for WebSocket.
               *
               * @return {Boolean} whether this transport is available.
               * @api public
               */
              check() {
                return !!websocket_constructor_js_1.WebSocket;
              }
            }
            exports.WS = WS;
          }).call(this);
        }).call(this, require("buffer").Buffer);
      },
      {
        "../contrib/parseqs.js": 10,
        "../contrib/yeast.js": 12,
        "../transport.js": 16,
        "../util.js": 22,
        "./websocket-constructor.js": 19,
        buffer: 8,
        debug: 23,
        "engine.io-parser": 30,
      },
    ],
    21: [
      function (require, module, exports) {
        "use strict";
        // browser shim for xmlhttprequest module
        Object.defineProperty(exports, "__esModule", { value: true });
        exports.XHR = void 0;
        const has_cors_js_1 = require("../contrib/has-cors.js");
        const globalThis_js_1 = require("../globalThis.js");
        function XHR(opts) {
          const xdomain = opts.xdomain;
          // XMLHttpRequest can be disabled on IE
          try {
            if (
              "undefined" !== typeof XMLHttpRequest &&
              (!xdomain || has_cors_js_1.hasCORS)
            ) {
              return new XMLHttpRequest();
            }
          } catch (e) {}
          if (!xdomain) {
            try {
              return new globalThis_js_1.globalThisShim[
                ["Active"].concat("Object").join("X")
              ]("Microsoft.XMLHTTP");
            } catch (e) {}
          }
        }
        exports.XHR = XHR;
      },
      { "../contrib/has-cors.js": 9, "../globalThis.js": 13 },
    ],
    22: [
      function (require, module, exports) {
        "use strict";
        Object.defineProperty(exports, "__esModule", { value: true });
        exports.byteLength =
          exports.installTimerFunctions =
          exports.pick =
            void 0;
        const globalThis_js_1 = require("./globalThis.js");
        function pick(obj, ...attr) {
          return attr.reduce((acc, k) => {
            if (obj.hasOwnProperty(k)) {
              acc[k] = obj[k];
            }
            return acc;
          }, {});
        }
        exports.pick = pick;
        // Keep a reference to the real timeout functions so they can be used when overridden
        const NATIVE_SET_TIMEOUT = setTimeout;
        const NATIVE_CLEAR_TIMEOUT = clearTimeout;
        function installTimerFunctions(obj, opts) {
          if (opts.useNativeTimers) {
            obj.setTimeoutFn = NATIVE_SET_TIMEOUT.bind(
              globalThis_js_1.globalThisShim
            );
            obj.clearTimeoutFn = NATIVE_CLEAR_TIMEOUT.bind(
              globalThis_js_1.globalThisShim
            );
          } else {
            obj.setTimeoutFn = setTimeout.bind(globalThis_js_1.globalThisShim);
            obj.clearTimeoutFn = clearTimeout.bind(
              globalThis_js_1.globalThisShim
            );
          }
        }
        exports.installTimerFunctions = installTimerFunctions;
        // base64 encoded buffers are about 33% bigger (https://en.wikipedia.org/wiki/Base64)
        const BASE64_OVERHEAD = 1.33;
        // we could also have used `new Blob([obj]).size`, but it isn't supported in IE9
        function byteLength(obj) {
          if (typeof obj === "string") {
            return utf8Length(obj);
          }
          // arraybuffer or blob
          return Math.ceil((obj.byteLength || obj.size) * BASE64_OVERHEAD);
        }
        exports.byteLength = byteLength;
        function utf8Length(str) {
          let c = 0,
            length = 0;
          for (let i = 0, l = str.length; i < l; i++) {
            c = str.charCodeAt(i);
            if (c < 0x80) {
              length += 1;
            } else if (c < 0x800) {
              length += 2;
            } else if (c < 0xd800 || c >= 0xe000) {
              length += 3;
            } else {
              i++;
              length += 4;
            }
          }
          return length;
        }
      },
      { "./globalThis.js": 13 },
    ],
    23: [
      function (require, module, exports) {
        (function (process) {
          (function () {
            /* eslint-env browser */

            /**
             * This is the web browser implementation of `debug()`.
             */

            exports.formatArgs = formatArgs;
            exports.save = save;
            exports.load = load;
            exports.useColors = useColors;
            exports.storage = localstorage();
            exports.destroy = (() => {
              let warned = false;

              return () => {
                if (!warned) {
                  warned = true;
                  console.warn(
                    "Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`."
                  );
                }
              };
            })();

            /**
             * Colors.
             */

            exports.colors = [
              "#0000CC",
              "#0000FF",
              "#0033CC",
              "#0033FF",
              "#0066CC",
              "#0066FF",
              "#0099CC",
              "#0099FF",
              "#00CC00",
              "#00CC33",
              "#00CC66",
              "#00CC99",
              "#00CCCC",
              "#00CCFF",
              "#3300CC",
              "#3300FF",
              "#3333CC",
              "#3333FF",
              "#3366CC",
              "#3366FF",
              "#3399CC",
              "#3399FF",
              "#33CC00",
              "#33CC33",
              "#33CC66",
              "#33CC99",
              "#33CCCC",
              "#33CCFF",
              "#6600CC",
              "#6600FF",
              "#6633CC",
              "#6633FF",
              "#66CC00",
              "#66CC33",
              "#9900CC",
              "#9900FF",
              "#9933CC",
              "#9933FF",
              "#99CC00",
              "#99CC33",
              "#CC0000",
              "#CC0033",
              "#CC0066",
              "#CC0099",
              "#CC00CC",
              "#CC00FF",
              "#CC3300",
              "#CC3333",
              "#CC3366",
              "#CC3399",
              "#CC33CC",
              "#CC33FF",
              "#CC6600",
              "#CC6633",
              "#CC9900",
              "#CC9933",
              "#CCCC00",
              "#CCCC33",
              "#FF0000",
              "#FF0033",
              "#FF0066",
              "#FF0099",
              "#FF00CC",
              "#FF00FF",
              "#FF3300",
              "#FF3333",
              "#FF3366",
              "#FF3399",
              "#FF33CC",
              "#FF33FF",
              "#FF6600",
              "#FF6633",
              "#FF9900",
              "#FF9933",
              "#FFCC00",
              "#FFCC33",
            ];

            /**
             * Currently only WebKit-based Web Inspectors, Firefox >= v31,
             * and the Firebug extension (any Firefox version) are known
             * to support "%c" CSS customizations.
             *
             * TODO: add a `localStorage` variable to explicitly enable/disable colors
             */

            // eslint-disable-next-line complexity
            function useColors() {
              // NB: In an Electron preload script, document will be defined but not fully
              // initialized. Since we know we're in Chrome, we'll just detect this case
              // explicitly
              if (
                typeof window !== "undefined" &&
                window.process &&
                (window.process.type === "renderer" || window.process.__nwjs)
              ) {
                return true;
              }

              // Internet Explorer and Edge do not support colors.
              if (
                typeof navigator !== "undefined" &&
                navigator.userAgent &&
                navigator.userAgent.toLowerCase().match(/(edge|trident)\/(\d+)/)
              ) {
                return false;
              }

              // Is webkit? http://stackoverflow.com/a/16459606/376773
              // document is undefined in react-native: https://github.com/facebook/react-native/pull/1632
              return (
                (typeof document !== "undefined" &&
                  document.documentElement &&
                  document.documentElement.style &&
                  document.documentElement.style.WebkitAppearance) ||
                // Is firebug? http://stackoverflow.com/a/398120/376773
                (typeof window !== "undefined" &&
                  window.console &&
                  (window.console.firebug ||
                    (window.console.exception && window.console.table))) ||
                // Is firefox >= v31?
                // https://developer.mozilla.org/en-US/docs/Tools/Web_Console#Styling_messages
                (typeof navigator !== "undefined" &&
                  navigator.userAgent &&
                  navigator.userAgent.toLowerCase().match(/firefox\/(\d+)/) &&
                  parseInt(RegExp.$1, 10) >= 31) ||
                // Double check webkit in userAgent just in case we are in a worker
                (typeof navigator !== "undefined" &&
                  navigator.userAgent &&
                  navigator.userAgent.toLowerCase().match(/applewebkit\/(\d+)/))
              );
            }

            /**
             * Colorize log arguments if enabled.
             *
             * @api public
             */

            function formatArgs(args) {
              args[0] =
                (this.useColors ? "%c" : "") +
                this.namespace +
                (this.useColors ? " %c" : " ") +
                args[0] +
                (this.useColors ? "%c " : " ") +
                "+" +
                module.exports.humanize(this.diff);

              if (!this.useColors) {
                return;
              }

              const c = "color: " + this.color;
              args.splice(1, 0, c, "color: inherit");

              // The final "%c" is somewhat tricky, because there could be other
              // arguments passed either before or after the %c, so we need to
              // figure out the correct index to insert the CSS into
              let index = 0;
              let lastC = 0;
              args[0].replace(/%[a-zA-Z%]/g, (match) => {
                if (match === "%%") {
                  return;
                }
                index++;
                if (match === "%c") {
                  // We only are interested in the *last* %c
                  // (the user may have provided their own)
                  lastC = index;
                }
              });

              args.splice(lastC, 0, c);
            }

            /**
             * Invokes `console.debug()` when available.
             * No-op when `console.debug` is not a "function".
             * If `console.debug` is not available, falls back
             * to `console.log`.
             *
             * @api public
             */
            exports.log = console.debug || console.log || (() => {});

            /**
             * Save `namespaces`.
             *
             * @param {String} namespaces
             * @api private
             */
            function save(namespaces) {
              try {
                if (namespaces) {
                  exports.storage.setItem("debug", namespaces);
                } else {
                  exports.storage.removeItem("debug");
                }
              } catch (error) {
                // Swallow
                // XXX (@Qix-) should we be logging these?
              }
            }

            /**
             * Load `namespaces`.
             *
             * @return {String} returns the previously persisted debug modes
             * @api private
             */
            function load() {
              let r;
              try {
                r = exports.storage.getItem("debug");
              } catch (error) {
                // Swallow
                // XXX (@Qix-) should we be logging these?
              }

              // If debug isn't set in LS, and we're in Electron, try to load $DEBUG
              if (!r && typeof process !== "undefined" && "env" in process) {
                r = process.env.DEBUG;
              }

              return r;
            }

            /**
             * Localstorage attempts to return the localstorage.
             *
             * This is necessary because safari throws
             * when a user disables cookies/localstorage
             * and you attempt to access it.
             *
             * @return {LocalStorage}
             * @api private
             */

            function localstorage() {
              try {
                // TVMLKit (Apple TV JS Runtime) does not have a window object, just localStorage in the global context
                // The Browser also has localStorage in the global context.
                return localStorage;
              } catch (error) {
                // Swallow
                // XXX (@Qix-) should we be logging these?
              }
            }

            module.exports = require("./common")(exports);

            const { formatters } = module.exports;

            /**
             * Map %j to `JSON.stringify()`, since no Web Inspectors do that by default.
             */

            formatters.j = function (v) {
              try {
                return JSON.stringify(v);
              } catch (error) {
                return "[UnexpectedJSONParseError]: " + error.message;
              }
            };
          }).call(this);
        }).call(this, require("_process"));
      },
      { "./common": 24, _process: 76 },
    ],
    24: [
      function (require, module, exports) {
        /**
         * This is the common logic for both the Node.js and web browser
         * implementations of `debug()`.
         */

        function setup(env) {
          createDebug.debug = createDebug;
          createDebug.default = createDebug;
          createDebug.coerce = coerce;
          createDebug.disable = disable;
          createDebug.enable = enable;
          createDebug.enabled = enabled;
          createDebug.humanize = require("ms");
          createDebug.destroy = destroy;

          Object.keys(env).forEach((key) => {
            createDebug[key] = env[key];
          });

          /**
           * The currently active debug mode names, and names to skip.
           */

          createDebug.names = [];
          createDebug.skips = [];

          /**
           * Map of special "%n" handling functions, for the debug "format" argument.
           *
           * Valid key names are a single, lower or upper-case letter, i.e. "n" and "N".
           */
          createDebug.formatters = {};

          /**
           * Selects a color for a debug namespace
           * @param {String} namespace The namespace string for the debug instance to be colored
           * @return {Number|String} An ANSI color code for the given namespace
           * @api private
           */
          function selectColor(namespace) {
            let hash = 0;

            for (let i = 0; i < namespace.length; i++) {
              hash = (hash << 5) - hash + namespace.charCodeAt(i);
              hash |= 0; // Convert to 32bit integer
            }

            return createDebug.colors[
              Math.abs(hash) % createDebug.colors.length
            ];
          }
          createDebug.selectColor = selectColor;

          /**
           * Create a debugger with the given `namespace`.
           *
           * @param {String} namespace
           * @return {Function}
           * @api public
           */
          function createDebug(namespace) {
            let prevTime;
            let enableOverride = null;
            let namespacesCache;
            let enabledCache;

            function debug(...args) {
              // Disabled?
              if (!debug.enabled) {
                return;
              }

              const self = debug;

              // Set `diff` timestamp
              const curr = Number(new Date());
              const ms = curr - (prevTime || curr);
              self.diff = ms;
              self.prev = prevTime;
              self.curr = curr;
              prevTime = curr;

              args[0] = createDebug.coerce(args[0]);

              if (typeof args[0] !== "string") {
                // Anything else let's inspect with %O
                args.unshift("%O");
              }

              // Apply any `formatters` transformations
              let index = 0;
              args[0] = args[0].replace(/%([a-zA-Z%])/g, (match, format) => {
                // If we encounter an escaped % then don't increase the array index
                if (match === "%%") {
                  return "%";
                }
                index++;
                const formatter = createDebug.formatters[format];
                if (typeof formatter === "function") {
                  const val = args[index];
                  match = formatter.call(self, val);

                  // Now we need to remove `args[index]` since it's inlined in the `format`
                  args.splice(index, 1);
                  index--;
                }
                return match;
              });

              // Apply env-specific formatting (colors, etc.)
              createDebug.formatArgs.call(self, args);

              const logFn = self.log || createDebug.log;
              logFn.apply(self, args);
            }

            debug.namespace = namespace;
            debug.useColors = createDebug.useColors();
            debug.color = createDebug.selectColor(namespace);
            debug.extend = extend;
            debug.destroy = createDebug.destroy; // XXX Temporary. Will be removed in the next major release.

            Object.defineProperty(debug, "enabled", {
              enumerable: true,
              configurable: false,
              get: () => {
                if (enableOverride !== null) {
                  return enableOverride;
                }
                if (namespacesCache !== createDebug.namespaces) {
                  namespacesCache = createDebug.namespaces;
                  enabledCache = createDebug.enabled(namespace);
                }

                return enabledCache;
              },
              set: (v) => {
                enableOverride = v;
              },
            });

            // Env-specific initialization logic for debug instances
            if (typeof createDebug.init === "function") {
              createDebug.init(debug);
            }

            return debug;
          }

          function extend(namespace, delimiter) {
            const newDebug = createDebug(
              this.namespace +
                (typeof delimiter === "undefined" ? ":" : delimiter) +
                namespace
            );
            newDebug.log = this.log;
            return newDebug;
          }

          /**
           * Enables a debug mode by namespaces. This can include modes
           * separated by a colon and wildcards.
           *
           * @param {String} namespaces
           * @api public
           */
          function enable(namespaces) {
            createDebug.save(namespaces);
            createDebug.namespaces = namespaces;

            createDebug.names = [];
            createDebug.skips = [];

            let i;
            const split = (
              typeof namespaces === "string" ? namespaces : ""
            ).split(/[\s,]+/);
            const len = split.length;

            for (i = 0; i < len; i++) {
              if (!split[i]) {
                // ignore empty strings
                continue;
              }

              namespaces = split[i].replace(/\*/g, ".*?");

              if (namespaces[0] === "-") {
                createDebug.skips.push(
                  new RegExp("^" + namespaces.slice(1) + "$")
                );
              } else {
                createDebug.names.push(new RegExp("^" + namespaces + "$"));
              }
            }
          }

          /**
           * Disable debug output.
           *
           * @return {String} namespaces
           * @api public
           */
          function disable() {
            const namespaces = [
              ...createDebug.names.map(toNamespace),
              ...createDebug.skips
                .map(toNamespace)
                .map((namespace) => "-" + namespace),
            ].join(",");
            createDebug.enable("");
            return namespaces;
          }

          /**
           * Returns true if the given mode name is enabled, false otherwise.
           *
           * @param {String} name
           * @return {Boolean}
           * @api public
           */
          function enabled(name) {
            if (name[name.length - 1] === "*") {
              return true;
            }

            let i;
            let len;

            for (i = 0, len = createDebug.skips.length; i < len; i++) {
              if (createDebug.skips[i].test(name)) {
                return false;
              }
            }

            for (i = 0, len = createDebug.names.length; i < len; i++) {
              if (createDebug.names[i].test(name)) {
                return true;
              }
            }

            return false;
          }

          /**
           * Convert regexp to namespace
           *
           * @param {RegExp} regxep
           * @return {String} namespace
           * @api private
           */
          function toNamespace(regexp) {
            return regexp
              .toString()
              .substring(2, regexp.toString().length - 2)
              .replace(/\.\*\?$/, "*");
          }

          /**
           * Coerce `val`.
           *
           * @param {Mixed} val
           * @return {Mixed}
           * @api private
           */
          function coerce(val) {
            if (val instanceof Error) {
              return val.stack || val.message;
            }
            return val;
          }

          /**
           * XXX DO NOT USE. This is a temporary stub function.
           * XXX It WILL be removed in the next major release.
           */
          function destroy() {
            console.warn(
              "Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`."
            );
          }

          createDebug.enable(createDebug.load());

          return createDebug;
        }

        module.exports = setup;
      },
      { ms: 25 },
    ],
    25: [
      function (require, module, exports) {
        /**
         * Helpers.
         */

        var s = 1000;
        var m = s * 60;
        var h = m * 60;
        var d = h * 24;
        var w = d * 7;
        var y = d * 365.25;

        /**
         * Parse or format the given `val`.
         *
         * Options:
         *
         *  - `long` verbose formatting [false]
         *
         * @param {String|Number} val
         * @param {Object} [options]
         * @throws {Error} throw an error if val is not a non-empty string or a number
         * @return {String|Number}
         * @api public
         */

        module.exports = function (val, options) {
          options = options || {};
          var type = typeof val;
          if (type === "string" && val.length > 0) {
            return parse(val);
          } else if (type === "number" && isFinite(val)) {
            return options.long ? fmtLong(val) : fmtShort(val);
          }
          throw new Error(
            "val is not a non-empty string or a valid number. val=" +
              JSON.stringify(val)
          );
        };

        /**
         * Parse the given `str` and return milliseconds.
         *
         * @param {String} str
         * @return {Number}
         * @api private
         */

        function parse(str) {
          str = String(str);
          if (str.length > 100) {
            return;
          }
          var match =
            /^(-?(?:\d+)?\.?\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|weeks?|w|years?|yrs?|y)?$/i.exec(
              str
            );
          if (!match) {
            return;
          }
          var n = parseFloat(match[1]);
          var type = (match[2] || "ms").toLowerCase();
          switch (type) {
            case "years":
            case "year":
            case "yrs":
            case "yr":
            case "y":
              return n * y;
            case "weeks":
            case "week":
            case "w":
              return n * w;
            case "days":
            case "day":
            case "d":
              return n * d;
            case "hours":
            case "hour":
            case "hrs":
            case "hr":
            case "h":
              return n * h;
            case "minutes":
            case "minute":
            case "mins":
            case "min":
            case "m":
              return n * m;
            case "seconds":
            case "second":
            case "secs":
            case "sec":
            case "s":
              return n * s;
            case "milliseconds":
            case "millisecond":
            case "msecs":
            case "msec":
            case "ms":
              return n;
            default:
              return undefined;
          }
        }

        /**
         * Short format for `ms`.
         *
         * @param {Number} ms
         * @return {String}
         * @api private
         */

        function fmtShort(ms) {
          var msAbs = Math.abs(ms);
          if (msAbs >= d) {
            return Math.round(ms / d) + "d";
          }
          if (msAbs >= h) {
            return Math.round(ms / h) + "h";
          }
          if (msAbs >= m) {
            return Math.round(ms / m) + "m";
          }
          if (msAbs >= s) {
            return Math.round(ms / s) + "s";
          }
          return ms + "ms";
        }

        /**
         * Long format for `ms`.
         *
         * @param {Number} ms
         * @return {String}
         * @api private
         */

        function fmtLong(ms) {
          var msAbs = Math.abs(ms);
          if (msAbs >= d) {
            return plural(ms, msAbs, d, "day");
          }
          if (msAbs >= h) {
            return plural(ms, msAbs, h, "hour");
          }
          if (msAbs >= m) {
            return plural(ms, msAbs, m, "minute");
          }
          if (msAbs >= s) {
            return plural(ms, msAbs, s, "second");
          }
          return ms + " ms";
        }

        /**
         * Pluralization helper.
         */

        function plural(ms, msAbs, n, name) {
          var isPlural = msAbs >= n * 1.5;
          return Math.round(ms / n) + " " + name + (isPlural ? "s" : "");
        }
      },
      {},
    ],
    26: [
      function (require, module, exports) {
        "use strict";
        Object.defineProperty(exports, "__esModule", { value: true });
        exports.ERROR_PACKET =
          exports.PACKET_TYPES_REVERSE =
          exports.PACKET_TYPES =
            void 0;
        const PACKET_TYPES = Object.create(null); // no Map = no polyfill
        exports.PACKET_TYPES = PACKET_TYPES;
        PACKET_TYPES["open"] = "0";
        PACKET_TYPES["close"] = "1";
        PACKET_TYPES["ping"] = "2";
        PACKET_TYPES["pong"] = "3";
        PACKET_TYPES["message"] = "4";
        PACKET_TYPES["upgrade"] = "5";
        PACKET_TYPES["noop"] = "6";
        const PACKET_TYPES_REVERSE = Object.create(null);
        exports.PACKET_TYPES_REVERSE = PACKET_TYPES_REVERSE;
        Object.keys(PACKET_TYPES).forEach((key) => {
          PACKET_TYPES_REVERSE[PACKET_TYPES[key]] = key;
        });
        const ERROR_PACKET = { type: "error", data: "parser error" };
        exports.ERROR_PACKET = ERROR_PACKET;
      },
      {},
    ],
    27: [
      function (require, module, exports) {
        "use strict";
        Object.defineProperty(exports, "__esModule", { value: true });
        exports.decode = exports.encode = void 0;
        const chars =
          "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
        // Use a lookup table to find the index.
        const lookup =
          typeof Uint8Array === "undefined" ? [] : new Uint8Array(256);
        for (let i = 0; i < chars.length; i++) {
          lookup[chars.charCodeAt(i)] = i;
        }
        const encode = (arraybuffer) => {
          let bytes = new Uint8Array(arraybuffer),
            i,
            len = bytes.length,
            base64 = "";
          for (i = 0; i < len; i += 3) {
            base64 += chars[bytes[i] >> 2];
            base64 += chars[((bytes[i] & 3) << 4) | (bytes[i + 1] >> 4)];
            base64 += chars[((bytes[i + 1] & 15) << 2) | (bytes[i + 2] >> 6)];
            base64 += chars[bytes[i + 2] & 63];
          }
          if (len % 3 === 2) {
            base64 = base64.substring(0, base64.length - 1) + "=";
          } else if (len % 3 === 1) {
            base64 = base64.substring(0, base64.length - 2) + "==";
          }
          return base64;
        };
        exports.encode = encode;
        const decode = (base64) => {
          let bufferLength = base64.length * 0.75,
            len = base64.length,
            i,
            p = 0,
            encoded1,
            encoded2,
            encoded3,
            encoded4;
          if (base64[base64.length - 1] === "=") {
            bufferLength--;
            if (base64[base64.length - 2] === "=") {
              bufferLength--;
            }
          }
          const arraybuffer = new ArrayBuffer(bufferLength),
            bytes = new Uint8Array(arraybuffer);
          for (i = 0; i < len; i += 4) {
            encoded1 = lookup[base64.charCodeAt(i)];
            encoded2 = lookup[base64.charCodeAt(i + 1)];
            encoded3 = lookup[base64.charCodeAt(i + 2)];
            encoded4 = lookup[base64.charCodeAt(i + 3)];
            bytes[p++] = (encoded1 << 2) | (encoded2 >> 4);
            bytes[p++] = ((encoded2 & 15) << 4) | (encoded3 >> 2);
            bytes[p++] = ((encoded3 & 3) << 6) | (encoded4 & 63);
          }
          return arraybuffer;
        };
        exports.decode = decode;
      },
      {},
    ],
    28: [
      function (require, module, exports) {
        "use strict";
        Object.defineProperty(exports, "__esModule", { value: true });
        const commons_js_1 = require("./commons.js");
        const base64_arraybuffer_js_1 = require("./contrib/base64-arraybuffer.js");
        const withNativeArrayBuffer = typeof ArrayBuffer === "function";
        const decodePacket = (encodedPacket, binaryType) => {
          if (typeof encodedPacket !== "string") {
            return {
              type: "message",
              data: mapBinary(encodedPacket, binaryType),
            };
          }
          const type = encodedPacket.charAt(0);
          if (type === "b") {
            return {
              type: "message",
              data: decodeBase64Packet(encodedPacket.substring(1), binaryType),
            };
          }
          const packetType = commons_js_1.PACKET_TYPES_REVERSE[type];
          if (!packetType) {
            return commons_js_1.ERROR_PACKET;
          }
          return encodedPacket.length > 1
            ? {
                type: commons_js_1.PACKET_TYPES_REVERSE[type],
                data: encodedPacket.substring(1),
              }
            : {
                type: commons_js_1.PACKET_TYPES_REVERSE[type],
              };
        };
        const decodeBase64Packet = (data, binaryType) => {
          if (withNativeArrayBuffer) {
            const decoded = (0, base64_arraybuffer_js_1.decode)(data);
            return mapBinary(decoded, binaryType);
          } else {
            return { base64: true, data }; // fallback for old browsers
          }
        };
        const mapBinary = (data, binaryType) => {
          switch (binaryType) {
            case "blob":
              return data instanceof ArrayBuffer ? new Blob([data]) : data;
            case "arraybuffer":
            default:
              return data; // assuming the data is already an ArrayBuffer
          }
        };
        exports.default = decodePacket;
      },
      { "./commons.js": 26, "./contrib/base64-arraybuffer.js": 27 },
    ],
    29: [
      function (require, module, exports) {
        "use strict";
        Object.defineProperty(exports, "__esModule", { value: true });
        const commons_js_1 = require("./commons.js");
        const withNativeBlob =
          typeof Blob === "function" ||
          (typeof Blob !== "undefined" &&
            Object.prototype.toString.call(Blob) ===
              "[object BlobConstructor]");
        const withNativeArrayBuffer = typeof ArrayBuffer === "function";
        // ArrayBuffer.isView method is not defined in IE10
        const isView = (obj) => {
          return typeof ArrayBuffer.isView === "function"
            ? ArrayBuffer.isView(obj)
            : obj && obj.buffer instanceof ArrayBuffer;
        };
        const encodePacket = ({ type, data }, supportsBinary, callback) => {
          if (withNativeBlob && data instanceof Blob) {
            if (supportsBinary) {
              return callback(data);
            } else {
              return encodeBlobAsBase64(data, callback);
            }
          } else if (
            withNativeArrayBuffer &&
            (data instanceof ArrayBuffer || isView(data))
          ) {
            if (supportsBinary) {
              return callback(data);
            } else {
              return encodeBlobAsBase64(new Blob([data]), callback);
            }
          }
          // plain string
          return callback(commons_js_1.PACKET_TYPES[type] + (data || ""));
        };
        const encodeBlobAsBase64 = (data, callback) => {
          const fileReader = new FileReader();
          fileReader.onload = function () {
            const content = fileReader.result.split(",")[1];
            callback("b" + content);
          };
          return fileReader.readAsDataURL(data);
        };
        exports.default = encodePacket;
      },
      { "./commons.js": 26 },
    ],
    30: [
      function (require, module, exports) {
        "use strict";
        Object.defineProperty(exports, "__esModule", { value: true });
        exports.decodePayload =
          exports.decodePacket =
          exports.encodePayload =
          exports.encodePacket =
          exports.protocol =
            void 0;
        const encodePacket_js_1 = require("./encodePacket.js");
        exports.encodePacket = encodePacket_js_1.default;
        const decodePacket_js_1 = require("./decodePacket.js");
        exports.decodePacket = decodePacket_js_1.default;
        const SEPARATOR = String.fromCharCode(30); // see https://en.wikipedia.org/wiki/Delimiter#ASCII_delimited_text
        const encodePayload = (packets, callback) => {
          // some packets may be added to the array while encoding, so the initial length must be saved
          const length = packets.length;
          const encodedPackets = new Array(length);
          let count = 0;
          packets.forEach((packet, i) => {
            // force base64 encoding for binary packets
            (0, encodePacket_js_1.default)(packet, false, (encodedPacket) => {
              encodedPackets[i] = encodedPacket;
              if (++count === length) {
                callback(encodedPackets.join(SEPARATOR));
              }
            });
          });
        };
        exports.encodePayload = encodePayload;
        const decodePayload = (encodedPayload, binaryType) => {
          const encodedPackets = encodedPayload.split(SEPARATOR);
          const packets = [];
          for (let i = 0; i < encodedPackets.length; i++) {
            const decodedPacket = (0, decodePacket_js_1.default)(
              encodedPackets[i],
              binaryType
            );
            packets.push(decodedPacket);
            if (decodedPacket.type === "error") {
              break;
            }
          }
          return packets;
        };
        exports.decodePayload = decodePayload;
        exports.protocol = 4;
      },
      { "./decodePacket.js": 28, "./encodePacket.js": 29 },
    ],
    31: [
      function (require, module, exports) {
        // Copyright Joyent, Inc. and other Node contributors.
        //
        // Permission is hereby granted, free of charge, to any person obtaining a
        // copy of this software and associated documentation files (the
        // "Software"), to deal in the Software without restriction, including
        // without limitation the rights to use, copy, modify, merge, publish,
        // distribute, sublicense, and/or sell copies of the Software, and to permit
        // persons to whom the Software is furnished to do so, subject to the
        // following conditions:
        //
        // The above copyright notice and this permission notice shall be included
        // in all copies or substantial portions of the Software.
        //
        // THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
        // OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
        // MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
        // NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
        // DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
        // OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
        // USE OR OTHER DEALINGS IN THE SOFTWARE.

        "use strict";

        var R = typeof Reflect === "object" ? Reflect : null;
        var ReflectApply =
          R && typeof R.apply === "function"
            ? R.apply
            : function ReflectApply(target, receiver, args) {
                return Function.prototype.apply.call(target, receiver, args);
              };

        var ReflectOwnKeys;
        if (R && typeof R.ownKeys === "function") {
          ReflectOwnKeys = R.ownKeys;
        } else if (Object.getOwnPropertySymbols) {
          ReflectOwnKeys = function ReflectOwnKeys(target) {
            return Object.getOwnPropertyNames(target).concat(
              Object.getOwnPropertySymbols(target)
            );
          };
        } else {
          ReflectOwnKeys = function ReflectOwnKeys(target) {
            return Object.getOwnPropertyNames(target);
          };
        }

        function ProcessEmitWarning(warning) {
          if (console && console.warn) console.warn(warning);
        }

        var NumberIsNaN =
          Number.isNaN ||
          function NumberIsNaN(value) {
            return value !== value;
          };

        function EventEmitter() {
          EventEmitter.init.call(this);
        }
        module.exports = EventEmitter;
        module.exports.once = once;

        // Backwards-compat with node 0.10.x
        EventEmitter.EventEmitter = EventEmitter;

        EventEmitter.prototype._events = undefined;
        EventEmitter.prototype._eventsCount = 0;
        EventEmitter.prototype._maxListeners = undefined;

        // By default EventEmitters will print a warning if more than 10 listeners are
        // added to it. This is a useful default which helps finding memory leaks.
        var defaultMaxListeners = 10;

        function checkListener(listener) {
          if (typeof listener !== "function") {
            throw new TypeError(
              'The "listener" argument must be of type Function. Received type ' +
                typeof listener
            );
          }
        }

        Object.defineProperty(EventEmitter, "defaultMaxListeners", {
          enumerable: true,
          get: function () {
            return defaultMaxListeners;
          },
          set: function (arg) {
            if (typeof arg !== "number" || arg < 0 || NumberIsNaN(arg)) {
              throw new RangeError(
                'The value of "defaultMaxListeners" is out of range. It must be a non-negative number. Received ' +
                  arg +
                  "."
              );
            }
            defaultMaxListeners = arg;
          },
        });

        EventEmitter.init = function () {
          if (
            this._events === undefined ||
            this._events === Object.getPrototypeOf(this)._events
          ) {
            this._events = Object.create(null);
            this._eventsCount = 0;
          }

          this._maxListeners = this._maxListeners || undefined;
        };

        // Obviously not all Emitters should be limited to 10. This function allows
        // that to be increased. Set to zero for unlimited.
        EventEmitter.prototype.setMaxListeners = function setMaxListeners(n) {
          if (typeof n !== "number" || n < 0 || NumberIsNaN(n)) {
            throw new RangeError(
              'The value of "n" is out of range. It must be a non-negative number. Received ' +
                n +
                "."
            );
          }
          this._maxListeners = n;
          return this;
        };

        function _getMaxListeners(that) {
          if (that._maxListeners === undefined)
            return EventEmitter.defaultMaxListeners;
          return that._maxListeners;
        }

        EventEmitter.prototype.getMaxListeners = function getMaxListeners() {
          return _getMaxListeners(this);
        };

        EventEmitter.prototype.emit = function emit(type) {
          var args = [];
          for (var i = 1; i < arguments.length; i++) args.push(arguments[i]);
          var doError = type === "error";

          var events = this._events;
          if (events !== undefined)
            doError = doError && events.error === undefined;
          else if (!doError) return false;

          // If there is no 'error' event listener then throw.
          if (doError) {
            var er;
            if (args.length > 0) er = args[0];
            if (er instanceof Error) {
              // Note: The comments on the `throw` lines are intentional, they show
              // up in Node's output if this results in an unhandled exception.
              throw er; // Unhandled 'error' event
            }
            // At least give some kind of context to the user
            var err = new Error(
              "Unhandled error." + (er ? " (" + er.message + ")" : "")
            );
            err.context = er;
            throw err; // Unhandled 'error' event
          }

          var handler = events[type];

          if (handler === undefined) return false;

          if (typeof handler === "function") {
            ReflectApply(handler, this, args);
          } else {
            var len = handler.length;
            var listeners = arrayClone(handler, len);
            for (var i = 0; i < len; ++i)
              ReflectApply(listeners[i], this, args);
          }

          return true;
        };

        function _addListener(target, type, listener, prepend) {
          var m;
          var events;
          var existing;

          checkListener(listener);

          events = target._events;
          if (events === undefined) {
            events = target._events = Object.create(null);
            target._eventsCount = 0;
          } else {
            // To avoid recursion in the case that type === "newListener"! Before
            // adding it to the listeners, first emit "newListener".
            if (events.newListener !== undefined) {
              target.emit(
                "newListener",
                type,
                listener.listener ? listener.listener : listener
              );

              // Re-assign `events` because a newListener handler could have caused the
              // this._events to be assigned to a new object
              events = target._events;
            }
            existing = events[type];
          }

          if (existing === undefined) {
            // Optimize the case of one listener. Don't need the extra array object.
            existing = events[type] = listener;
            ++target._eventsCount;
          } else {
            if (typeof existing === "function") {
              // Adding the second element, need to change to array.
              existing = events[type] = prepend
                ? [listener, existing]
                : [existing, listener];
              // If we've already got an array, just append.
            } else if (prepend) {
              existing.unshift(listener);
            } else {
              existing.push(listener);
            }

            // Check for listener leak
            m = _getMaxListeners(target);
            if (m > 0 && existing.length > m && !existing.warned) {
              existing.warned = true;
              // No error code for this since it is a Warning
              // eslint-disable-next-line no-restricted-syntax
              var w = new Error(
                "Possible EventEmitter memory leak detected. " +
                  existing.length +
                  " " +
                  String(type) +
                  " listeners " +
                  "added. Use emitter.setMaxListeners() to " +
                  "increase limit"
              );
              w.name = "MaxListenersExceededWarning";
              w.emitter = target;
              w.type = type;
              w.count = existing.length;
              ProcessEmitWarning(w);
            }
          }

          return target;
        }

        EventEmitter.prototype.addListener = function addListener(
          type,
          listener
        ) {
          return _addListener(this, type, listener, false);
        };

        EventEmitter.prototype.on = EventEmitter.prototype.addListener;

        EventEmitter.prototype.prependListener = function prependListener(
          type,
          listener
        ) {
          return _addListener(this, type, listener, true);
        };

        function onceWrapper() {
          if (!this.fired) {
            this.target.removeListener(this.type, this.wrapFn);
            this.fired = true;
            if (arguments.length === 0) return this.listener.call(this.target);
            return this.listener.apply(this.target, arguments);
          }
        }

        function _onceWrap(target, type, listener) {
          var state = {
            fired: false,
            wrapFn: undefined,
            target: target,
            type: type,
            listener: listener,
          };
          var wrapped = onceWrapper.bind(state);
          wrapped.listener = listener;
          state.wrapFn = wrapped;
          return wrapped;
        }

        EventEmitter.prototype.once = function once(type, listener) {
          checkListener(listener);
          this.on(type, _onceWrap(this, type, listener));
          return this;
        };

        EventEmitter.prototype.prependOnceListener =
          function prependOnceListener(type, listener) {
            checkListener(listener);
            this.prependListener(type, _onceWrap(this, type, listener));
            return this;
          };

        // Emits a 'removeListener' event if and only if the listener was removed.
        EventEmitter.prototype.removeListener = function removeListener(
          type,
          listener
        ) {
          var list, events, position, i, originalListener;

          checkListener(listener);

          events = this._events;
          if (events === undefined) return this;

          list = events[type];
          if (list === undefined) return this;

          if (list === listener || list.listener === listener) {
            if (--this._eventsCount === 0) this._events = Object.create(null);
            else {
              delete events[type];
              if (events.removeListener)
                this.emit("removeListener", type, list.listener || listener);
            }
          } else if (typeof list !== "function") {
            position = -1;

            for (i = list.length - 1; i >= 0; i--) {
              if (list[i] === listener || list[i].listener === listener) {
                originalListener = list[i].listener;
                position = i;
                break;
              }
            }

            if (position < 0) return this;

            if (position === 0) list.shift();
            else {
              spliceOne(list, position);
            }

            if (list.length === 1) events[type] = list[0];

            if (events.removeListener !== undefined)
              this.emit("removeListener", type, originalListener || listener);
          }

          return this;
        };

        EventEmitter.prototype.off = EventEmitter.prototype.removeListener;

        EventEmitter.prototype.removeAllListeners = function removeAllListeners(
          type
        ) {
          var listeners, events, i;

          events = this._events;
          if (events === undefined) return this;

          // not listening for removeListener, no need to emit
          if (events.removeListener === undefined) {
            if (arguments.length === 0) {
              this._events = Object.create(null);
              this._eventsCount = 0;
            } else if (events[type] !== undefined) {
              if (--this._eventsCount === 0) this._events = Object.create(null);
              else delete events[type];
            }
            return this;
          }

          // emit removeListener for all listeners on all events
          if (arguments.length === 0) {
            var keys = Object.keys(events);
            var key;
            for (i = 0; i < keys.length; ++i) {
              key = keys[i];
              if (key === "removeListener") continue;
              this.removeAllListeners(key);
            }
            this.removeAllListeners("removeListener");
            this._events = Object.create(null);
            this._eventsCount = 0;
            return this;
          }

          listeners = events[type];

          if (typeof listeners === "function") {
            this.removeListener(type, listeners);
          } else if (listeners !== undefined) {
            // LIFO order
            for (i = listeners.length - 1; i >= 0; i--) {
              this.removeListener(type, listeners[i]);
            }
          }

          return this;
        };

        function _listeners(target, type, unwrap) {
          var events = target._events;

          if (events === undefined) return [];

          var evlistener = events[type];
          if (evlistener === undefined) return [];

          if (typeof evlistener === "function")
            return unwrap ? [evlistener.listener || evlistener] : [evlistener];

          return unwrap
            ? unwrapListeners(evlistener)
            : arrayClone(evlistener, evlistener.length);
        }

        EventEmitter.prototype.listeners = function listeners(type) {
          return _listeners(this, type, true);
        };

        EventEmitter.prototype.rawListeners = function rawListeners(type) {
          return _listeners(this, type, false);
        };

        EventEmitter.listenerCount = function (emitter, type) {
          if (typeof emitter.listenerCount === "function") {
            return emitter.listenerCount(type);
          } else {
            return listenerCount.call(emitter, type);
          }
        };

        EventEmitter.prototype.listenerCount = listenerCount;
        function listenerCount(type) {
          var events = this._events;

          if (events !== undefined) {
            var evlistener = events[type];

            if (typeof evlistener === "function") {
              return 1;
            } else if (evlistener !== undefined) {
              return evlistener.length;
            }
          }

          return 0;
        }

        EventEmitter.prototype.eventNames = function eventNames() {
          return this._eventsCount > 0 ? ReflectOwnKeys(this._events) : [];
        };

        function arrayClone(arr, n) {
          var copy = new Array(n);
          for (var i = 0; i < n; ++i) copy[i] = arr[i];
          return copy;
        }

        function spliceOne(list, index) {
          for (; index + 1 < list.length; index++)
            list[index] = list[index + 1];
          list.pop();
        }

        function unwrapListeners(arr) {
          var ret = new Array(arr.length);
          for (var i = 0; i < ret.length; ++i) {
            ret[i] = arr[i].listener || arr[i];
          }
          return ret;
        }

        function once(emitter, name) {
          return new Promise(function (resolve, reject) {
            function errorListener(err) {
              emitter.removeListener(name, resolver);
              reject(err);
            }

            function resolver() {
              if (typeof emitter.removeListener === "function") {
                emitter.removeListener("error", errorListener);
              }
              resolve([].slice.call(arguments));
            }

            eventTargetAgnosticAddListener(emitter, name, resolver, {
              once: true,
            });
            if (name !== "error") {
              addErrorHandlerIfEventEmitter(emitter, errorListener, {
                once: true,
              });
            }
          });
        }

        function addErrorHandlerIfEventEmitter(emitter, handler, flags) {
          if (typeof emitter.on === "function") {
            eventTargetAgnosticAddListener(emitter, "error", handler, flags);
          }
        }

        function eventTargetAgnosticAddListener(
          emitter,
          name,
          listener,
          flags
        ) {
          if (typeof emitter.on === "function") {
            if (flags.once) {
              emitter.once(name, listener);
            } else {
              emitter.on(name, listener);
            }
          } else if (typeof emitter.addEventListener === "function") {
            // EventTarget does not have `error` event semantics like Node
            // EventEmitters, we do not listen for `error` events here.
            emitter.addEventListener(name, function wrapListener(arg) {
              // IE does not have builtin `{ once: true }` support so we
              // have to do it manually.
              if (flags.once) {
                emitter.removeEventListener(name, wrapListener);
              }
              listener(arg);
            });
          } else {
            throw new TypeError(
              'The "emitter" argument must be of type EventEmitter. Received type ' +
                typeof emitter
            );
          }
        }
      },
      {},
    ],
    32: [
      function (require, module, exports) {
        "use strict";
        var __importDefault =
          (this && this.__importDefault) ||
          function (mod) {
            return mod && mod.__esModule ? mod : { default: mod };
          };
        Object.defineProperty(exports, "__esModule", { value: true });
        exports.Logger = void 0;
        const debug_1 = __importDefault(require("debug"));
        const APP_NAME = "h264-profile-level-id";
        class Logger {
          constructor(prefix) {
            if (prefix) {
              this._debug = (0, debug_1.default)(`${APP_NAME}:${prefix}`);
              this._warn = (0, debug_1.default)(`${APP_NAME}:WARN:${prefix}`);
              this._error = (0, debug_1.default)(`${APP_NAME}:ERROR:${prefix}`);
            } else {
              this._debug = (0, debug_1.default)(APP_NAME);
              this._warn = (0, debug_1.default)(`${APP_NAME}:WARN`);
              this._error = (0, debug_1.default)(`${APP_NAME}:ERROR`);
            }
            /* eslint-disable no-console */
            this._debug.log = console.info.bind(console);
            this._warn.log = console.warn.bind(console);
            this._error.log = console.error.bind(console);
            /* eslint-enable no-console */
          }
          get debug() {
            return this._debug;
          }
          get warn() {
            return this._warn;
          }
          get error() {
            return this._error;
          }
        }
        exports.Logger = Logger;
      },
      { debug: 34 },
    ],
    33: [
      function (require, module, exports) {
        "use strict";
        Object.defineProperty(exports, "__esModule", { value: true });
        exports.generateProfileLevelIdStringForAnswer =
          exports.isSameProfile =
          exports.parseSdpProfileLevelId =
          exports.levelToString =
          exports.profileToString =
          exports.profileLevelIdToString =
          exports.parseProfileLevelId =
          exports.ProfileLevelId =
          exports.Level =
          exports.Profile =
            void 0;
        const Logger_1 = require("./Logger");
        const logger = new Logger_1.Logger();
        /**
         * Supported profiles.
         */
        // ESLint absurdly complains about "'Profile' is already declared in
        // the upper scope".
        // eslint-disable-next-line no-shadow
        var Profile;
        (function (Profile) {
          Profile[(Profile["ConstrainedBaseline"] = 1)] = "ConstrainedBaseline";
          Profile[(Profile["Baseline"] = 2)] = "Baseline";
          Profile[(Profile["Main"] = 3)] = "Main";
          Profile[(Profile["ConstrainedHigh"] = 4)] = "ConstrainedHigh";
          Profile[(Profile["High"] = 5)] = "High";
          Profile[(Profile["PredictiveHigh444"] = 6)] = "PredictiveHigh444";
        })(Profile || (exports.Profile = Profile = {}));
        /**
         * Supported levels.
         */
        // ESLint absurdly complains about "'Level' is already declared in
        // the upper scope".
        // eslint-disable-next-line no-shadow
        var Level;
        (function (Level) {
          Level[(Level["L1_b"] = 0)] = "L1_b";
          Level[(Level["L1"] = 10)] = "L1";
          Level[(Level["L1_1"] = 11)] = "L1_1";
          Level[(Level["L1_2"] = 12)] = "L1_2";
          Level[(Level["L1_3"] = 13)] = "L1_3";
          Level[(Level["L2"] = 20)] = "L2";
          Level[(Level["L2_1"] = 21)] = "L2_1";
          Level[(Level["L2_2"] = 22)] = "L2_2";
          Level[(Level["L3"] = 30)] = "L3";
          Level[(Level["L3_1"] = 31)] = "L3_1";
          Level[(Level["L3_2"] = 32)] = "L3_2";
          Level[(Level["L4"] = 40)] = "L4";
          Level[(Level["L4_1"] = 41)] = "L4_1";
          Level[(Level["L4_2"] = 42)] = "L4_2";
          Level[(Level["L5"] = 50)] = "L5";
          Level[(Level["L5_1"] = 51)] = "L5_1";
          Level[(Level["L5_2"] = 52)] = "L5_2";
        })(Level || (exports.Level = Level = {}));
        /**
         * Represents a parsed h264 profile-level-id value.
         */
        class ProfileLevelId {
          constructor(profile, level) {
            this.profile = profile;
            this.level = level;
          }
        }
        exports.ProfileLevelId = ProfileLevelId;
        // Default ProfileLevelId.
        //
        // TODO: The default should really be profile Baseline and level 1 according to
        // the spec: https://tools.ietf.org/html/rfc6184#section-8.1. In order to not
        // break backwards compatibility with older versions of WebRTC where external
        // codecs don't have any parameters, use profile ConstrainedBaseline level 3_1
        // instead. This workaround will only be done in an interim period to allow
        // external clients to update their code.
        //
        // http://crbug/webrtc/6337.
        const DefaultProfileLevelId = new ProfileLevelId(
          Profile.ConstrainedBaseline,
          Level.L3_1
        );
        /**
         * Class for matching bit patterns such as "x1xx0000" where 'x' is allowed to
         * be either 0 or 1.
         */
        class BitPattern {
          constructor(str) {
            this.mask = ~byteMaskString("x", str);
            this.masked_value = byteMaskString("1", str);
          }
          isMatch(value) {
            return this.masked_value === (value & this.mask);
          }
        }
        /**
         * Class for converting between profile_idc/profile_iop to Profile.
         */
        class ProfilePattern {
          constructor(profile_idc, profile_iop, profile) {
            this.profile_idc = profile_idc;
            this.profile_iop = profile_iop;
            this.profile = profile;
          }
        }
        // This is from https://tools.ietf.org/html/rfc6184#section-8.1.
        const ProfilePatterns = [
          new ProfilePattern(
            0x42,
            new BitPattern("x1xx0000"),
            Profile.ConstrainedBaseline
          ),
          new ProfilePattern(
            0x4d,
            new BitPattern("1xxx0000"),
            Profile.ConstrainedBaseline
          ),
          new ProfilePattern(
            0x58,
            new BitPattern("11xx0000"),
            Profile.ConstrainedBaseline
          ),
          new ProfilePattern(
            0x42,
            new BitPattern("x0xx0000"),
            Profile.Baseline
          ),
          new ProfilePattern(
            0x58,
            new BitPattern("10xx0000"),
            Profile.Baseline
          ),
          new ProfilePattern(0x4d, new BitPattern("0x0x0000"), Profile.Main),
          new ProfilePattern(0x64, new BitPattern("00000000"), Profile.High),
          new ProfilePattern(
            0x64,
            new BitPattern("00001100"),
            Profile.ConstrainedHigh
          ),
          new ProfilePattern(
            0xf4,
            new BitPattern("00000000"),
            Profile.PredictiveHigh444
          ),
        ];
        /**
         * Parse profile level id that is represented as a string of 3 hex bytes.
         * Nothing will be returned if the string is not a recognized H264 profile
         * level id.
         */
        function parseProfileLevelId(str) {
          // For level_idc=11 and profile_idc=0x42, 0x4D, or 0x58, the constraint set3
          // flag specifies if level 1b or level 1.1 is used.
          const ConstraintSet3Flag = 0x10;
          // The string should consist of 3 bytes in hexadecimal format.
          if (typeof str !== "string" || str.length !== 6) {
            return undefined;
          }
          const profile_level_id_numeric = parseInt(str, 16);
          if (profile_level_id_numeric === 0) {
            return undefined;
          }
          // Separate into three bytes.
          const level_idc = profile_level_id_numeric & 0xff;
          const profile_iop = (profile_level_id_numeric >> 8) & 0xff;
          const profile_idc = (profile_level_id_numeric >> 16) & 0xff;
          // Parse level based on level_idc and constraint set 3 flag.
          let level;
          switch (level_idc) {
            case Level.L1_1: {
              level =
                (profile_iop & ConstraintSet3Flag) !== 0
                  ? Level.L1_b
                  : Level.L1_1;
              break;
            }
            case Level.L1:
            case Level.L1_2:
            case Level.L1_3:
            case Level.L2:
            case Level.L2_1:
            case Level.L2_2:
            case Level.L3:
            case Level.L3_1:
            case Level.L3_2:
            case Level.L4:
            case Level.L4_1:
            case Level.L4_2:
            case Level.L5:
            case Level.L5_1:
            case Level.L5_2: {
              level = level_idc;
              break;
            }
            // Unrecognized level_idc.
            default: {
              logger.warn(
                `parseProfileLevelId() | unrecognized level_idc [str:${str}, level_idc:${level_idc}]`
              );
              return undefined;
            }
          }
          // Parse profile_idc/profile_iop into a Profile enum.
          for (const pattern of ProfilePatterns) {
            if (
              profile_idc === pattern.profile_idc &&
              pattern.profile_iop.isMatch(profile_iop)
            ) {
              return new ProfileLevelId(pattern.profile, level);
            }
          }
          logger.warn(
            `parseProfileLevelId() | unrecognized profile_idc/profile_iop combination [str:${str}, profile_idc:${profile_idc}, profile_iop:${profile_iop}]`
          );
          return undefined;
        }
        exports.parseProfileLevelId = parseProfileLevelId;
        /**
         * Returns canonical string representation as three hex bytes of the profile
         * level id, or returns nothing for invalid profile level ids.
         */
        function profileLevelIdToString(profile_level_id) {
          // Handle special case level == 1b.
          if (profile_level_id.level == Level.L1_b) {
            switch (profile_level_id.profile) {
              case Profile.ConstrainedBaseline: {
                return "42f00b";
              }
              case Profile.Baseline: {
                return "42100b";
              }
              case Profile.Main: {
                return "4d100b";
              }
              // Level 1_b is not allowed for other profiles.
              default: {
                logger.warn(
                  `profileLevelIdToString() | Level 1_b not is allowed for profile ${profile_level_id.profile}`
                );
                return undefined;
              }
            }
          }
          let profile_idc_iop_string;
          switch (profile_level_id.profile) {
            case Profile.ConstrainedBaseline: {
              profile_idc_iop_string = "42e0";
              break;
            }
            case Profile.Baseline: {
              profile_idc_iop_string = "4200";
              break;
            }
            case Profile.Main: {
              profile_idc_iop_string = "4d00";
              break;
            }
            case Profile.ConstrainedHigh: {
              profile_idc_iop_string = "640c";
              break;
            }
            case Profile.High: {
              profile_idc_iop_string = "6400";
              break;
            }
            case Profile.PredictiveHigh444: {
              profile_idc_iop_string = "f400";
              break;
            }
            default: {
              logger.warn(
                `profileLevelIdToString() | unrecognized profile ${profile_level_id.profile}`
              );
              return undefined;
            }
          }
          let levelStr = profile_level_id.level.toString(16);
          if (levelStr.length === 1) {
            levelStr = `0${levelStr}`;
          }
          return `${profile_idc_iop_string}${levelStr}`;
        }
        exports.profileLevelIdToString = profileLevelIdToString;
        /**
         * Returns a human friendly name for the given profile.
         */
        function profileToString(profile) {
          switch (profile) {
            case Profile.ConstrainedBaseline: {
              return "ConstrainedBaseline";
            }
            case Profile.Baseline: {
              return "Baseline";
            }
            case Profile.Main: {
              return "Main";
            }
            case Profile.ConstrainedHigh: {
              return "ConstrainedHigh";
            }
            case Profile.High: {
              return "High";
            }
            case Profile.PredictiveHigh444: {
              return "PredictiveHigh444";
            }
            default: {
              logger.warn(
                `profileToString() | unrecognized profile ${profile}`
              );
              return undefined;
            }
          }
        }
        exports.profileToString = profileToString;
        /**
         * Returns a human friendly name for the given level.
         */
        function levelToString(level) {
          switch (level) {
            case Level.L1_b: {
              return "1b";
            }
            case Level.L1: {
              return "1";
            }
            case Level.L1_1: {
              return "1.1";
            }
            case Level.L1_2: {
              return "1.2";
            }
            case Level.L1_3: {
              return "1.3";
            }
            case Level.L2: {
              return "2";
            }
            case Level.L2_1: {
              return "2.1";
            }
            case Level.L2_2: {
              return "2.2";
            }
            case Level.L3: {
              return "3";
            }
            case Level.L3_1: {
              return "3.1";
            }
            case Level.L3_2: {
              return "3.2";
            }
            case Level.L4: {
              return "4";
            }
            case Level.L4_1: {
              return "4.1";
            }
            case Level.L4_2: {
              return "4.2";
            }
            case Level.L5: {
              return "5";
            }
            case Level.L5_1: {
              return "5.1";
            }
            case Level.L5_2: {
              return "5.2";
            }
            default: {
              logger.warn(`levelToString() | unrecognized level ${level}`);
              return undefined;
            }
          }
        }
        exports.levelToString = levelToString;
        /**
         * Parse profile level id that is represented as a string of 3 hex bytes
         * contained in an SDP key-value map. A default profile level id will be
         * returned if the profile-level-id key is missing. Nothing will be returned
         * if the key is present but the string is invalid.
         */
        function parseSdpProfileLevelId(params = {}) {
          const profile_level_id = params["profile-level-id"];
          return profile_level_id
            ? parseProfileLevelId(profile_level_id)
            : DefaultProfileLevelId;
        }
        exports.parseSdpProfileLevelId = parseSdpProfileLevelId;
        /**
         * Returns true if the parameters have the same H264 profile, i.e. the same
         * H264 profile (Baseline, High, etc).
         */
        function isSameProfile(params1 = {}, params2 = {}) {
          const profile_level_id_1 = parseSdpProfileLevelId(params1);
          const profile_level_id_2 = parseSdpProfileLevelId(params2);
          // Compare H264 profiles, but not levels.
          return Boolean(
            profile_level_id_1 &&
              profile_level_id_2 &&
              profile_level_id_1.profile === profile_level_id_2.profile
          );
        }
        exports.isSameProfile = isSameProfile;
        /**
         * Generate codec parameters that will be used as answer in an SDP negotiation
         * based on local supported parameters and remote offered parameters. Both
         * local_supported_params and remote_offered_params represent sendrecv media
         * descriptions, i.e they are a mix of both encode and decode capabilities. In
         * theory, when the profile in local_supported_params represent a strict
         * superset of the profile in remote_offered_params, we could limit the profile
         * in the answer to the profile in remote_offered_params.
         *
         * However, to simplify the code, each supported H264 profile should be listed
         * explicitly in the list of local supported codecs, even if they are redundant.
         * Then each local codec in the list should be tested one at a time against the
         * remote codec, and only when the profiles are equal should this function be
         * called. Therefore, this function does not need to handle profile intersection,
         * and the profile of local_supported_params and remote_offered_params must be
         * equal before calling this function. The parameters that are used when
         * negotiating are the level part of profile-level-id and
         * level-asymmetry-allowed.
         */
        function generateProfileLevelIdStringForAnswer(
          local_supported_params = {},
          remote_offered_params = {}
        ) {
          // If both local and remote params do not contain profile-level-id, they are
          // both using the default profile. In this case, don't return anything.
          if (
            !local_supported_params["profile-level-id"] &&
            !remote_offered_params["profile-level-id"]
          ) {
            logger.warn(
              "generateProfileLevelIdStringForAnswer() | profile-level-id missing in local and remote params"
            );
            return undefined;
          }
          // Parse profile-level-ids.
          const local_profile_level_id = parseSdpProfileLevelId(
            local_supported_params
          );
          const remote_profile_level_id = parseSdpProfileLevelId(
            remote_offered_params
          );
          // The local and remote codec must have valid and equal H264 Profiles.
          if (!local_profile_level_id) {
            throw new TypeError("invalid local_profile_level_id");
          }
          if (!remote_profile_level_id) {
            throw new TypeError("invalid remote_profile_level_id");
          }
          if (
            local_profile_level_id.profile !== remote_profile_level_id.profile
          ) {
            throw new TypeError("H264 Profile mismatch");
          }
          // Parse level information.
          const level_asymmetry_allowed =
            isLevelAsymmetryAllowed(local_supported_params) &&
            isLevelAsymmetryAllowed(remote_offered_params);
          const local_level = local_profile_level_id.level;
          const remote_level = remote_profile_level_id.level;
          const min_level = minLevel(local_level, remote_level);
          // Determine answer level. When level asymmetry is not allowed, level upgrade
          // is not allowed, i.e., the level in the answer must be equal to or lower
          // than the level in the offer.
          const answer_level = level_asymmetry_allowed
            ? local_level
            : min_level;
          logger.debug(
            `generateProfileLevelIdStringForAnswer() | result [profile:${local_profile_level_id.profile}, level:${answer_level}]`
          );
          // Return the resulting profile-level-id for the answer parameters.
          return profileLevelIdToString(
            new ProfileLevelId(local_profile_level_id.profile, answer_level)
          );
        }
        exports.generateProfileLevelIdStringForAnswer =
          generateProfileLevelIdStringForAnswer;
        /**
         * Convert a string of 8 characters into a byte where the positions containing
         * character c will have their bit set. For example, c = 'x', str = "x1xx0000"
         * will return 0b10110000.
         */
        function byteMaskString(c, str) {
          return (
            (Number(str[0] === c) << 7) |
            (Number(str[1] === c) << 6) |
            (Number(str[2] === c) << 5) |
            (Number(str[3] === c) << 4) |
            (Number(str[4] === c) << 3) |
            (Number(str[5] === c) << 2) |
            (Number(str[6] === c) << 1) |
            (Number(str[7] === c) << 0)
          );
        }
        // Compare H264 levels and handle the level 1b case.
        function isLessLevel(a, b) {
          if (a === Level.L1_b) {
            return b !== Level.L1 && b !== Level.L1_b;
          }
          if (b === Level.L1_b) {
            return a !== Level.L1;
          }
          return a < b;
        }
        function minLevel(a, b) {
          return isLessLevel(a, b) ? a : b;
        }
        function isLevelAsymmetryAllowed(params = {}) {
          const level_asymmetry_allowed = params["level-asymmetry-allowed"];
          return (
            level_asymmetry_allowed === true ||
            level_asymmetry_allowed === 1 ||
            level_asymmetry_allowed === "1"
          );
        }
      },
      { "./Logger": 32 },
    ],
    34: [
      function (require, module, exports) {
        arguments[4][23][0].apply(exports, arguments);
      },
      { "./common": 35, _process: 76, dup: 23 },
    ],
    35: [
      function (require, module, exports) {
        arguments[4][24][0].apply(exports, arguments);
      },
      { dup: 24, ms: 36 },
    ],
    36: [
      function (require, module, exports) {
        arguments[4][25][0].apply(exports, arguments);
      },
      { dup: 25 },
    ],
    37: [
      function (require, module, exports) {
        /*! ieee754. BSD-3-Clause License. Feross Aboukhadijeh <https://feross.org/opensource> */
        exports.read = function (buffer, offset, isLE, mLen, nBytes) {
          var e, m;
          var eLen = nBytes * 8 - mLen - 1;
          var eMax = (1 << eLen) - 1;
          var eBias = eMax >> 1;
          var nBits = -7;
          var i = isLE ? nBytes - 1 : 0;
          var d = isLE ? -1 : 1;
          var s = buffer[offset + i];

          i += d;

          e = s & ((1 << -nBits) - 1);
          s >>= -nBits;
          nBits += eLen;
          for (
            ;
            nBits > 0;
            e = e * 256 + buffer[offset + i], i += d, nBits -= 8
          ) {}

          m = e & ((1 << -nBits) - 1);
          e >>= -nBits;
          nBits += mLen;
          for (
            ;
            nBits > 0;
            m = m * 256 + buffer[offset + i], i += d, nBits -= 8
          ) {}

          if (e === 0) {
            e = 1 - eBias;
          } else if (e === eMax) {
            return m ? NaN : (s ? -1 : 1) * Infinity;
          } else {
            m = m + Math.pow(2, mLen);
            e = e - eBias;
          }
          return (s ? -1 : 1) * m * Math.pow(2, e - mLen);
        };

        exports.write = function (buffer, value, offset, isLE, mLen, nBytes) {
          var e, m, c;
          var eLen = nBytes * 8 - mLen - 1;
          var eMax = (1 << eLen) - 1;
          var eBias = eMax >> 1;
          var rt = mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0;
          var i = isLE ? 0 : nBytes - 1;
          var d = isLE ? 1 : -1;
          var s = value < 0 || (value === 0 && 1 / value < 0) ? 1 : 0;

          value = Math.abs(value);

          if (isNaN(value) || value === Infinity) {
            m = isNaN(value) ? 1 : 0;
            e = eMax;
          } else {
            e = Math.floor(Math.log(value) / Math.LN2);
            if (value * (c = Math.pow(2, -e)) < 1) {
              e--;
              c *= 2;
            }
            if (e + eBias >= 1) {
              value += rt / c;
            } else {
              value += rt * Math.pow(2, 1 - eBias);
            }
            if (value * c >= 2) {
              e++;
              c /= 2;
            }

            if (e + eBias >= eMax) {
              m = 0;
              e = eMax;
            } else if (e + eBias >= 1) {
              m = (value * c - 1) * Math.pow(2, mLen);
              e = e + eBias;
            } else {
              m = value * Math.pow(2, eBias - 1) * Math.pow(2, mLen);
              e = 0;
            }
          }

          for (
            ;
            mLen >= 8;
            buffer[offset + i] = m & 0xff, i += d, m /= 256, mLen -= 8
          ) {}

          e = (e << mLen) | m;
          eLen += mLen;
          for (
            ;
            eLen > 0;
            buffer[offset + i] = e & 0xff, i += d, e /= 256, eLen -= 8
          ) {}

          buffer[offset + i - d] |= s * 128;
        };
      },
      {},
    ],
    38: [
      function (require, module, exports) {
        "use strict";
        Object.defineProperty(exports, "__esModule", { value: true });
        exports.Consumer = void 0;
        const Logger_1 = require("./Logger");
        const EnhancedEventEmitter_1 = require("./EnhancedEventEmitter");
        const errors_1 = require("./errors");
        const logger = new Logger_1.Logger("Consumer");
        class Consumer extends EnhancedEventEmitter_1.EnhancedEventEmitter {
          constructor({
            id,
            localId,
            producerId,
            rtpReceiver,
            track,
            rtpParameters,
            appData,
          }) {
            super();
            // Closed flag.
            this._closed = false;
            // Observer instance.
            this._observer = new EnhancedEventEmitter_1.EnhancedEventEmitter();
            logger.debug("constructor()");
            this._id = id;
            this._localId = localId;
            this._producerId = producerId;
            this._rtpReceiver = rtpReceiver;
            this._track = track;
            this._rtpParameters = rtpParameters;
            this._paused = !track.enabled;
            this._appData = appData || {};
            this.onTrackEnded = this.onTrackEnded.bind(this);
            this.handleTrack();
          }
          /**
           * Consumer id.
           */
          get id() {
            return this._id;
          }
          /**
           * Local id.
           */
          get localId() {
            return this._localId;
          }
          /**
           * Associated Producer id.
           */
          get producerId() {
            return this._producerId;
          }
          /**
           * Whether the Consumer is closed.
           */
          get closed() {
            return this._closed;
          }
          /**
           * Media kind.
           */
          get kind() {
            return this._track.kind;
          }
          /**
           * Associated RTCRtpReceiver.
           */
          get rtpReceiver() {
            return this._rtpReceiver;
          }
          /**
           * The associated track.
           */
          get track() {
            return this._track;
          }
          /**
           * RTP parameters.
           */
          get rtpParameters() {
            return this._rtpParameters;
          }
          /**
           * Whether the Consumer is paused.
           */
          get paused() {
            return this._paused;
          }
          /**
           * App custom data.
           */
          get appData() {
            return this._appData;
          }
          /**
           * App custom data setter.
           */
          set appData(appData) {
            this._appData = appData;
          }
          get observer() {
            return this._observer;
          }
          /**
           * Closes the Consumer.
           */
          close() {
            if (this._closed) {
              return;
            }
            logger.debug("close()");
            this._closed = true;
            this.destroyTrack();
            this.emit("@close");
            // Emit observer event.
            this._observer.safeEmit("close");
          }
          /**
           * Transport was closed.
           */
          transportClosed() {
            if (this._closed) {
              return;
            }
            logger.debug("transportClosed()");
            this._closed = true;
            this.destroyTrack();
            this.safeEmit("transportclose");
            // Emit observer event.
            this._observer.safeEmit("close");
          }
          /**
           * Get associated RTCRtpReceiver stats.
           */
          async getStats() {
            if (this._closed) {
              throw new errors_1.InvalidStateError("closed");
            }
            return new Promise((resolve, reject) => {
              this.safeEmit("@getstats", resolve, reject);
            });
          }
          /**
           * Pauses receiving media.
           */
          pause() {
            logger.debug("pause()");
            if (this._closed) {
              logger.error("pause() | Consumer closed");
              return;
            }
            if (this._paused) {
              logger.debug("pause() | Consumer is already paused");
              return;
            }
            this._paused = true;
            this._track.enabled = false;
            this.emit("@pause");
            // Emit observer event.
            this._observer.safeEmit("pause");
          }
          /**
           * Resumes receiving media.
           */
          resume() {
            logger.debug("resume()");
            if (this._closed) {
              logger.error("resume() | Consumer closed");
              return;
            }
            if (!this._paused) {
              logger.debug("resume() | Consumer is already resumed");
              return;
            }
            this._paused = false;
            this._track.enabled = true;
            this.emit("@resume");
            // Emit observer event.
            this._observer.safeEmit("resume");
          }
          onTrackEnded() {
            logger.debug('track "ended" event');
            this.safeEmit("trackended");
            // Emit observer event.
            this._observer.safeEmit("trackended");
          }
          handleTrack() {
            this._track.addEventListener("ended", this.onTrackEnded);
          }
          destroyTrack() {
            try {
              this._track.removeEventListener("ended", this.onTrackEnded);
              this._track.stop();
            } catch (error) {}
          }
        }
        exports.Consumer = Consumer;
      },
      { "./EnhancedEventEmitter": 42, "./Logger": 43, "./errors": 48 },
    ],
    39: [
      function (require, module, exports) {
        "use strict";
        Object.defineProperty(exports, "__esModule", { value: true });
        exports.DataConsumer = void 0;
        const Logger_1 = require("./Logger");
        const EnhancedEventEmitter_1 = require("./EnhancedEventEmitter");
        const logger = new Logger_1.Logger("DataConsumer");
        class DataConsumer extends EnhancedEventEmitter_1.EnhancedEventEmitter {
          constructor({
            id,
            dataProducerId,
            dataChannel,
            sctpStreamParameters,
            appData,
          }) {
            super();
            // Closed flag.
            this._closed = false;
            // Observer instance.
            this._observer = new EnhancedEventEmitter_1.EnhancedEventEmitter();
            logger.debug("constructor()");
            this._id = id;
            this._dataProducerId = dataProducerId;
            this._dataChannel = dataChannel;
            this._sctpStreamParameters = sctpStreamParameters;
            this._appData = appData || {};
            this.handleDataChannel();
          }
          /**
           * DataConsumer id.
           */
          get id() {
            return this._id;
          }
          /**
           * Associated DataProducer id.
           */
          get dataProducerId() {
            return this._dataProducerId;
          }
          /**
           * Whether the DataConsumer is closed.
           */
          get closed() {
            return this._closed;
          }
          /**
           * SCTP stream parameters.
           */
          get sctpStreamParameters() {
            return this._sctpStreamParameters;
          }
          /**
           * DataChannel readyState.
           */
          get readyState() {
            return this._dataChannel.readyState;
          }
          /**
           * DataChannel label.
           */
          get label() {
            return this._dataChannel.label;
          }
          /**
           * DataChannel protocol.
           */
          get protocol() {
            return this._dataChannel.protocol;
          }
          /**
           * DataChannel binaryType.
           */
          get binaryType() {
            return this._dataChannel.binaryType;
          }
          /**
           * Set DataChannel binaryType.
           */
          set binaryType(binaryType) {
            this._dataChannel.binaryType = binaryType;
          }
          /**
           * App custom data.
           */
          get appData() {
            return this._appData;
          }
          /**
           * App custom data setter.
           */
          set appData(appData) {
            this._appData = appData;
          }
          get observer() {
            return this._observer;
          }
          /**
           * Closes the DataConsumer.
           */
          close() {
            if (this._closed) {
              return;
            }
            logger.debug("close()");
            this._closed = true;
            this._dataChannel.close();
            this.emit("@close");
            // Emit observer event.
            this._observer.safeEmit("close");
          }
          /**
           * Transport was closed.
           */
          transportClosed() {
            if (this._closed) {
              return;
            }
            logger.debug("transportClosed()");
            this._closed = true;
            this._dataChannel.close();
            this.safeEmit("transportclose");
            // Emit observer event.
            this._observer.safeEmit("close");
          }
          handleDataChannel() {
            this._dataChannel.addEventListener("open", () => {
              if (this._closed) {
                return;
              }
              logger.debug('DataChannel "open" event');
              this.safeEmit("open");
            });
            this._dataChannel.addEventListener("error", (event) => {
              if (this._closed) {
                return;
              }
              let { error } = event;
              if (!error) {
                error = new Error("unknown DataChannel error");
              }
              if (error.errorDetail === "sctp-failure") {
                logger.error(
                  "DataChannel SCTP error [sctpCauseCode:%s]: %s",
                  error.sctpCauseCode,
                  error.message
                );
              } else {
                logger.error('DataChannel "error" event: %o', error);
              }
              this.safeEmit("error", error);
            });
            this._dataChannel.addEventListener("close", () => {
              if (this._closed) {
                return;
              }
              logger.warn('DataChannel "close" event');
              this._closed = true;
              this.emit("@close");
              this.safeEmit("close");
              // Emit observer event.
              this._observer.safeEmit("close");
            });
            this._dataChannel.addEventListener("message", (event) => {
              if (this._closed) {
                return;
              }
              this.safeEmit("message", event.data);
            });
          }
        }
        exports.DataConsumer = DataConsumer;
      },
      { "./EnhancedEventEmitter": 42, "./Logger": 43 },
    ],
    40: [
      function (require, module, exports) {
        "use strict";
        Object.defineProperty(exports, "__esModule", { value: true });
        exports.DataProducer = void 0;
        const Logger_1 = require("./Logger");
        const EnhancedEventEmitter_1 = require("./EnhancedEventEmitter");
        const errors_1 = require("./errors");
        const logger = new Logger_1.Logger("DataProducer");
        class DataProducer extends EnhancedEventEmitter_1.EnhancedEventEmitter {
          constructor({ id, dataChannel, sctpStreamParameters, appData }) {
            super();
            // Closed flag.
            this._closed = false;
            // Observer instance.
            this._observer = new EnhancedEventEmitter_1.EnhancedEventEmitter();
            logger.debug("constructor()");
            this._id = id;
            this._dataChannel = dataChannel;
            this._sctpStreamParameters = sctpStreamParameters;
            this._appData = appData || {};
            this.handleDataChannel();
          }
          /**
           * DataProducer id.
           */
          get id() {
            return this._id;
          }
          /**
           * Whether the DataProducer is closed.
           */
          get closed() {
            return this._closed;
          }
          /**
           * SCTP stream parameters.
           */
          get sctpStreamParameters() {
            return this._sctpStreamParameters;
          }
          /**
           * DataChannel readyState.
           */
          get readyState() {
            return this._dataChannel.readyState;
          }
          /**
           * DataChannel label.
           */
          get label() {
            return this._dataChannel.label;
          }
          /**
           * DataChannel protocol.
           */
          get protocol() {
            return this._dataChannel.protocol;
          }
          /**
           * DataChannel bufferedAmount.
           */
          get bufferedAmount() {
            return this._dataChannel.bufferedAmount;
          }
          /**
           * DataChannel bufferedAmountLowThreshold.
           */
          get bufferedAmountLowThreshold() {
            return this._dataChannel.bufferedAmountLowThreshold;
          }
          /**
           * Set DataChannel bufferedAmountLowThreshold.
           */
          set bufferedAmountLowThreshold(bufferedAmountLowThreshold) {
            this._dataChannel.bufferedAmountLowThreshold =
              bufferedAmountLowThreshold;
          }
          /**
           * App custom data.
           */
          get appData() {
            return this._appData;
          }
          /**
           * App custom data setter.
           */
          set appData(appData) {
            this._appData = appData;
          }
          get observer() {
            return this._observer;
          }
          /**
           * Closes the DataProducer.
           */
          close() {
            if (this._closed) {
              return;
            }
            logger.debug("close()");
            this._closed = true;
            this._dataChannel.close();
            this.emit("@close");
            // Emit observer event.
            this._observer.safeEmit("close");
          }
          /**
           * Transport was closed.
           */
          transportClosed() {
            if (this._closed) {
              return;
            }
            logger.debug("transportClosed()");
            this._closed = true;
            this._dataChannel.close();
            this.safeEmit("transportclose");
            // Emit observer event.
            this._observer.safeEmit("close");
          }
          /**
           * Send a message.
           *
           * @param {String|Blob|ArrayBuffer|ArrayBufferView} data.
           */
          send(data) {
            logger.debug("send()");
            if (this._closed) {
              throw new errors_1.InvalidStateError("closed");
            }
            this._dataChannel.send(data);
          }
          handleDataChannel() {
            this._dataChannel.addEventListener("open", () => {
              if (this._closed) {
                return;
              }
              logger.debug('DataChannel "open" event');
              this.safeEmit("open");
            });
            this._dataChannel.addEventListener("error", (event) => {
              if (this._closed) {
                return;
              }
              let { error } = event;
              if (!error) {
                error = new Error("unknown DataChannel error");
              }
              if (error.errorDetail === "sctp-failure") {
                logger.error(
                  "DataChannel SCTP error [sctpCauseCode:%s]: %s",
                  error.sctpCauseCode,
                  error.message
                );
              } else {
                logger.error('DataChannel "error" event: %o', error);
              }
              this.safeEmit("error", error);
            });
            this._dataChannel.addEventListener("close", () => {
              if (this._closed) {
                return;
              }
              logger.warn('DataChannel "close" event');
              this._closed = true;
              this.emit("@close");
              this.safeEmit("close");
              // Emit observer event.
              this._observer.safeEmit("close");
            });
            this._dataChannel.addEventListener("message", () => {
              if (this._closed) {
                return;
              }
              logger.warn(
                'DataChannel "message" event in a DataProducer, message discarded'
              );
            });
            this._dataChannel.addEventListener("bufferedamountlow", () => {
              if (this._closed) {
                return;
              }
              this.safeEmit("bufferedamountlow");
            });
          }
        }
        exports.DataProducer = DataProducer;
      },
      { "./EnhancedEventEmitter": 42, "./Logger": 43, "./errors": 48 },
    ],
    41: [
      function (require, module, exports) {
        "use strict";
        var __createBinding =
          (this && this.__createBinding) ||
          (Object.create
            ? function (o, m, k, k2) {
                if (k2 === undefined) k2 = k;
                var desc = Object.getOwnPropertyDescriptor(m, k);
                if (
                  !desc ||
                  ("get" in desc
                    ? !m.__esModule
                    : desc.writable || desc.configurable)
                ) {
                  desc = {
                    enumerable: true,
                    get: function () {
                      return m[k];
                    },
                  };
                }
                Object.defineProperty(o, k2, desc);
              }
            : function (o, m, k, k2) {
                if (k2 === undefined) k2 = k;
                o[k2] = m[k];
              });
        var __setModuleDefault =
          (this && this.__setModuleDefault) ||
          (Object.create
            ? function (o, v) {
                Object.defineProperty(o, "default", {
                  enumerable: true,
                  value: v,
                });
              }
            : function (o, v) {
                o["default"] = v;
              });
        var __importStar =
          (this && this.__importStar) ||
          function (mod) {
            if (mod && mod.__esModule) return mod;
            var result = {};
            if (mod != null)
              for (var k in mod)
                if (
                  k !== "default" &&
                  Object.prototype.hasOwnProperty.call(mod, k)
                )
                  __createBinding(result, mod, k);
            __setModuleDefault(result, mod);
            return result;
          };
        Object.defineProperty(exports, "__esModule", { value: true });
        exports.Device = exports.detectDevice = void 0;
        const ua_parser_js_1 = require("ua-parser-js");
        const Logger_1 = require("./Logger");
        const EnhancedEventEmitter_1 = require("./EnhancedEventEmitter");
        const errors_1 = require("./errors");
        const utils = __importStar(require("./utils"));
        const ortc = __importStar(require("./ortc"));
        const Transport_1 = require("./Transport");
        const Chrome111_1 = require("./handlers/Chrome111");
        const Chrome74_1 = require("./handlers/Chrome74");
        const Chrome70_1 = require("./handlers/Chrome70");
        const Chrome67_1 = require("./handlers/Chrome67");
        const Chrome55_1 = require("./handlers/Chrome55");
        const Firefox60_1 = require("./handlers/Firefox60");
        const Safari12_1 = require("./handlers/Safari12");
        const Safari11_1 = require("./handlers/Safari11");
        const Edge11_1 = require("./handlers/Edge11");
        const ReactNativeUnifiedPlan_1 = require("./handlers/ReactNativeUnifiedPlan");
        const ReactNative_1 = require("./handlers/ReactNative");
        const logger = new Logger_1.Logger("Device");
        function detectDevice() {
          // React-Native.
          // NOTE: react-native-webrtc >= 1.75.0 is required.
          // NOTE: react-native-webrtc with Unified Plan requires version >= 106.0.0.
          if (
            typeof navigator === "object" &&
            navigator.product === "ReactNative"
          ) {
            logger.debug("detectDevice() | React-Native detected");
            if (typeof RTCPeerConnection === "undefined") {
              logger.warn(
                "detectDevice() | unsupported react-native-webrtc without RTCPeerConnection, forgot to call registerGlobals()?"
              );
              return undefined;
            }
            if (typeof RTCRtpTransceiver !== "undefined") {
              logger.debug(
                "detectDevice() | ReactNative UnifiedPlan handler chosen"
              );
              return "ReactNativeUnifiedPlan";
            } else {
              logger.debug("detectDevice() | ReactNative PlanB handler chosen");
              return "ReactNative";
            }
          }
          // Browser.
          else if (
            typeof navigator === "object" &&
            typeof navigator.userAgent === "string"
          ) {
            const ua = navigator.userAgent;
            const uaParser = new ua_parser_js_1.UAParser(ua);
            logger.debug(
              "detectDevice() | browser detected [ua:%s, parsed:%o]",
              ua,
              uaParser.getResult()
            );
            const browser = uaParser.getBrowser();
            const browserName = browser.name?.toLowerCase();
            const browserVersion = parseInt(browser.major ?? "0");
            const engine = uaParser.getEngine();
            const engineName = engine.name?.toLowerCase();
            const os = uaParser.getOS();
            const osName = os.name?.toLowerCase();
            const osVersion = parseFloat(os.version ?? "0");
            const device = uaParser.getDevice();
            const deviceModel = device.model?.toLowerCase();
            const isIOS = osName === "ios" || deviceModel === "ipad";
            const isChrome =
              browserName &&
              [
                "chrome",
                "chromium",
                "mobile chrome",
                "chrome webview",
                "chrome headless",
              ].includes(browserName);
            const isFirefox =
              browserName &&
              ["firefox", "mobile firefox", "mobile focus"].includes(
                browserName
              );
            const isSafari =
              browserName && ["safari", "mobile safari"].includes(browserName);
            const isEdge = browserName && ["edge"].includes(browserName);
            // Chrome, Chromium, and Edge.
            if ((isChrome || isEdge) && !isIOS && browserVersion >= 111) {
              return "Chrome111";
            } else if (
              (isChrome && !isIOS && browserVersion >= 74) ||
              (isEdge && !isIOS && browserVersion >= 88)
            ) {
              return "Chrome74";
            } else if (isChrome && !isIOS && browserVersion >= 70) {
              return "Chrome70";
            } else if (isChrome && !isIOS && browserVersion >= 67) {
              return "Chrome67";
            } else if (isChrome && !isIOS && browserVersion >= 55) {
              return "Chrome55";
            }
            // Firefox.
            else if (isFirefox && !isIOS && browserVersion >= 60) {
              return "Firefox60";
            }
            // Firefox on iOS (so Safari).
            else if (isFirefox && isIOS && osVersion >= 14.3) {
              return "Safari12";
            }
            // Safari with Unified-Plan support enabled.
            else if (
              isSafari &&
              browserVersion >= 12 &&
              typeof RTCRtpTransceiver !== "undefined" &&
              RTCRtpTransceiver.prototype.hasOwnProperty("currentDirection")
            ) {
              return "Safari12";
            }
            // Safari with Plab-B support.
            else if (isSafari && browserVersion >= 11) {
              return "Safari11";
            }
            // Old Edge with ORTC support.
            else if (
              isEdge &&
              !isIOS &&
              browserVersion >= 11 &&
              browserVersion <= 18
            ) {
              return "Edge11";
            }
            // Best effort for WebKit based browsers in iOS.
            else if (
              engineName === "webkit" &&
              isIOS &&
              typeof RTCRtpTransceiver !== "undefined" &&
              RTCRtpTransceiver.prototype.hasOwnProperty("currentDirection")
            ) {
              return "Safari12";
            }
            // Best effort for Chromium based browsers.
            else if (engineName === "blink") {
              const match = ua.match(/(?:(?:Chrome|Chromium))[ /](\w+)/i);
              if (match) {
                const version = Number(match[1]);
                if (version >= 111) {
                  return "Chrome111";
                } else if (version >= 74) {
                  return "Chrome74";
                } else if (version >= 70) {
                  return "Chrome70";
                } else if (version >= 67) {
                  return "Chrome67";
                } else {
                  return "Chrome55";
                }
              } else {
                return "Chrome111";
              }
            }
            // Unsupported browser.
            else {
              logger.warn(
                "detectDevice() | browser not supported [name:%s, version:%s]",
                browserName,
                browserVersion
              );
              return undefined;
            }
          }
          // Unknown device.
          else {
            logger.warn("detectDevice() | unknown device");
            return undefined;
          }
        }
        exports.detectDevice = detectDevice;
        class Device {
          /**
           * Create a new Device to connect to mediasoup server.
           *
           * @throws {UnsupportedError} if device is not supported.
           */
          constructor({ handlerName, handlerFactory, Handler } = {}) {
            // Loaded flag.
            this._loaded = false;
            // Observer instance.
            this._observer = new EnhancedEventEmitter_1.EnhancedEventEmitter();
            logger.debug("constructor()");
            // Handle deprecated option.
            if (Handler) {
              logger.warn(
                "constructor() | Handler option is DEPRECATED, use handlerName or handlerFactory instead"
              );
              if (typeof Handler === "string") {
                handlerName = Handler;
              } else {
                throw new TypeError(
                  "non string Handler option no longer supported, use handlerFactory instead"
                );
              }
            }
            if (handlerName && handlerFactory) {
              throw new TypeError(
                "just one of handlerName or handlerInterface can be given"
              );
            }
            if (handlerFactory) {
              this._handlerFactory = handlerFactory;
            } else {
              if (handlerName) {
                logger.debug("constructor() | handler given: %s", handlerName);
              } else {
                handlerName = detectDevice();
                if (handlerName) {
                  logger.debug(
                    "constructor() | detected handler: %s",
                    handlerName
                  );
                } else {
                  throw new errors_1.UnsupportedError("device not supported");
                }
              }
              switch (handlerName) {
                case "Chrome111": {
                  this._handlerFactory = Chrome111_1.Chrome111.createFactory();
                  break;
                }
                case "Chrome74": {
                  this._handlerFactory = Chrome74_1.Chrome74.createFactory();
                  break;
                }
                case "Chrome70": {
                  this._handlerFactory = Chrome70_1.Chrome70.createFactory();
                  break;
                }
                case "Chrome67": {
                  this._handlerFactory = Chrome67_1.Chrome67.createFactory();
                  break;
                }
                case "Chrome55": {
                  this._handlerFactory = Chrome55_1.Chrome55.createFactory();
                  break;
                }
                case "Firefox60": {
                  this._handlerFactory = Firefox60_1.Firefox60.createFactory();
                  break;
                }
                case "Safari12": {
                  this._handlerFactory = Safari12_1.Safari12.createFactory();
                  break;
                }
                case "Safari11": {
                  this._handlerFactory = Safari11_1.Safari11.createFactory();
                  break;
                }
                case "Edge11": {
                  this._handlerFactory = Edge11_1.Edge11.createFactory();
                  break;
                }
                case "ReactNativeUnifiedPlan": {
                  this._handlerFactory =
                    ReactNativeUnifiedPlan_1.ReactNativeUnifiedPlan.createFactory();
                  break;
                }
                case "ReactNative": {
                  this._handlerFactory =
                    ReactNative_1.ReactNative.createFactory();
                  break;
                }
                default: {
                  throw new TypeError(`unknown handlerName "${handlerName}"`);
                }
              }
            }
            // Create a temporal handler to get its name.
            const handler = this._handlerFactory();
            this._handlerName = handler.name;
            handler.close();
            this._extendedRtpCapabilities = undefined;
            this._recvRtpCapabilities = undefined;
            this._canProduceByKind = {
              audio: false,
              video: false,
            };
            this._sctpCapabilities = undefined;
          }
          /**
           * The RTC handler name.
           */
          get handlerName() {
            return this._handlerName;
          }
          /**
           * Whether the Device is loaded.
           */
          get loaded() {
            return this._loaded;
          }
          /**
           * RTP capabilities of the Device for receiving media.
           *
           * @throws {InvalidStateError} if not loaded.
           */
          get rtpCapabilities() {
            if (!this._loaded) {
              throw new errors_1.InvalidStateError("not loaded");
            }
            return this._recvRtpCapabilities;
          }
          /**
           * SCTP capabilities of the Device.
           *
           * @throws {InvalidStateError} if not loaded.
           */
          get sctpCapabilities() {
            if (!this._loaded) {
              throw new errors_1.InvalidStateError("not loaded");
            }
            return this._sctpCapabilities;
          }
          get observer() {
            return this._observer;
          }
          /**
           * Initialize the Device.
           */
          async load({ routerRtpCapabilities }) {
            logger.debug(
              "load() [routerRtpCapabilities:%o]",
              routerRtpCapabilities
            );
            routerRtpCapabilities = utils.clone(routerRtpCapabilities);
            // Temporal handler to get its capabilities.
            let handler;
            try {
              if (this._loaded) {
                throw new errors_1.InvalidStateError("already loaded");
              }
              // This may throw.
              ortc.validateRtpCapabilities(routerRtpCapabilities);
              handler = this._handlerFactory();
              const nativeRtpCapabilities =
                await handler.getNativeRtpCapabilities();
              logger.debug(
                "load() | got native RTP capabilities:%o",
                nativeRtpCapabilities
              );
              // This may throw.
              ortc.validateRtpCapabilities(nativeRtpCapabilities);
              // Get extended RTP capabilities.
              this._extendedRtpCapabilities = ortc.getExtendedRtpCapabilities(
                nativeRtpCapabilities,
                routerRtpCapabilities
              );
              logger.debug(
                "load() | got extended RTP capabilities:%o",
                this._extendedRtpCapabilities
              );
              // Check whether we can produce audio/video.
              this._canProduceByKind.audio = ortc.canSend(
                "audio",
                this._extendedRtpCapabilities
              );
              this._canProduceByKind.video = ortc.canSend(
                "video",
                this._extendedRtpCapabilities
              );
              // Generate our receiving RTP capabilities for receiving media.
              this._recvRtpCapabilities = ortc.getRecvRtpCapabilities(
                this._extendedRtpCapabilities
              );
              // This may throw.
              ortc.validateRtpCapabilities(this._recvRtpCapabilities);
              logger.debug(
                "load() | got receiving RTP capabilities:%o",
                this._recvRtpCapabilities
              );
              // Generate our SCTP capabilities.
              this._sctpCapabilities =
                await handler.getNativeSctpCapabilities();
              logger.debug(
                "load() | got native SCTP capabilities:%o",
                this._sctpCapabilities
              );
              // This may throw.
              ortc.validateSctpCapabilities(this._sctpCapabilities);
              logger.debug("load() succeeded");
              this._loaded = true;
              handler.close();
            } catch (error) {
              if (handler) {
                handler.close();
              }
              throw error;
            }
          }
          /**
           * Whether we can produce audio/video.
           *
           * @throws {InvalidStateError} if not loaded.
           * @throws {TypeError} if wrong arguments.
           */
          canProduce(kind) {
            if (!this._loaded) {
              throw new errors_1.InvalidStateError("not loaded");
            } else if (kind !== "audio" && kind !== "video") {
              throw new TypeError(`invalid kind "${kind}"`);
            }
            return this._canProduceByKind[kind];
          }
          /**
           * Creates a Transport for sending media.
           *
           * @throws {InvalidStateError} if not loaded.
           * @throws {TypeError} if wrong arguments.
           */
          createSendTransport({
            id,
            iceParameters,
            iceCandidates,
            dtlsParameters,
            sctpParameters,
            iceServers,
            iceTransportPolicy,
            additionalSettings,
            proprietaryConstraints,
            appData,
          }) {
            logger.debug("createSendTransport()");
            return this.createTransport({
              direction: "send",
              id: id,
              iceParameters: iceParameters,
              iceCandidates: iceCandidates,
              dtlsParameters: dtlsParameters,
              sctpParameters: sctpParameters,
              iceServers: iceServers,
              iceTransportPolicy: iceTransportPolicy,
              additionalSettings: additionalSettings,
              proprietaryConstraints: proprietaryConstraints,
              appData: appData,
            });
          }
          /**
           * Creates a Transport for receiving media.
           *
           * @throws {InvalidStateError} if not loaded.
           * @throws {TypeError} if wrong arguments.
           */
          createRecvTransport({
            id,
            iceParameters,
            iceCandidates,
            dtlsParameters,
            sctpParameters,
            iceServers,
            iceTransportPolicy,
            additionalSettings,
            proprietaryConstraints,
            appData,
          }) {
            logger.debug("createRecvTransport()");
            return this.createTransport({
              direction: "recv",
              id: id,
              iceParameters: iceParameters,
              iceCandidates: iceCandidates,
              dtlsParameters: dtlsParameters,
              sctpParameters: sctpParameters,
              iceServers: iceServers,
              iceTransportPolicy: iceTransportPolicy,
              additionalSettings: additionalSettings,
              proprietaryConstraints: proprietaryConstraints,
              appData: appData,
            });
          }
          createTransport({
            direction,
            id,
            iceParameters,
            iceCandidates,
            dtlsParameters,
            sctpParameters,
            iceServers,
            iceTransportPolicy,
            additionalSettings,
            proprietaryConstraints,
            appData,
          }) {
            if (!this._loaded) {
              throw new errors_1.InvalidStateError("not loaded");
            } else if (typeof id !== "string") {
              throw new TypeError("missing id");
            } else if (typeof iceParameters !== "object") {
              throw new TypeError("missing iceParameters");
            } else if (!Array.isArray(iceCandidates)) {
              throw new TypeError("missing iceCandidates");
            } else if (typeof dtlsParameters !== "object") {
              throw new TypeError("missing dtlsParameters");
            } else if (sctpParameters && typeof sctpParameters !== "object") {
              throw new TypeError("wrong sctpParameters");
            } else if (appData && typeof appData !== "object") {
              throw new TypeError("if given, appData must be an object");
            }
            // Create a new Transport.
            const transport = new Transport_1.Transport({
              direction,
              id,
              iceParameters,
              iceCandidates,
              dtlsParameters,
              sctpParameters,
              iceServers,
              iceTransportPolicy,
              additionalSettings,
              proprietaryConstraints,
              appData,
              handlerFactory: this._handlerFactory,
              extendedRtpCapabilities: this._extendedRtpCapabilities,
              canProduceByKind: this._canProduceByKind,
            });
            // Emit observer event.
            this._observer.safeEmit("newtransport", transport);
            return transport;
          }
        }
        exports.Device = Device;
      },
      {
        "./EnhancedEventEmitter": 42,
        "./Logger": 43,
        "./Transport": 47,
        "./errors": 48,
        "./handlers/Chrome111": 49,
        "./handlers/Chrome55": 50,
        "./handlers/Chrome67": 51,
        "./handlers/Chrome70": 52,
        "./handlers/Chrome74": 53,
        "./handlers/Edge11": 54,
        "./handlers/Firefox60": 55,
        "./handlers/ReactNative": 57,
        "./handlers/ReactNativeUnifiedPlan": 58,
        "./handlers/Safari11": 59,
        "./handlers/Safari12": 60,
        "./ortc": 69,
        "./utils": 72,
        "ua-parser-js": 97,
      },
    ],
    42: [
      function (require, module, exports) {
        "use strict";
        Object.defineProperty(exports, "__esModule", { value: true });
        exports.EnhancedEventEmitter = void 0;
        const events_1 = require("events");
        const Logger_1 = require("./Logger");
        const logger = new Logger_1.Logger("EnhancedEventEmitter");
        class EnhancedEventEmitter extends events_1.EventEmitter {
          constructor() {
            super();
            this.setMaxListeners(Infinity);
          }
          emit(eventName, ...args) {
            return super.emit(eventName, ...args);
          }
          /**
           * Special addition to the EventEmitter API.
           */
          safeEmit(eventName, ...args) {
            const numListeners = super.listenerCount(eventName);
            try {
              return super.emit(eventName, ...args);
            } catch (error) {
              logger.error(
                "safeEmit() | event listener threw an error [eventName:%s]:%o",
                eventName,
                error
              );
              return Boolean(numListeners);
            }
          }
          on(eventName, listener) {
            super.on(eventName, listener);
            return this;
          }
          off(eventName, listener) {
            super.off(eventName, listener);
            return this;
          }
          addListener(eventName, listener) {
            super.on(eventName, listener);
            return this;
          }
          prependListener(eventName, listener) {
            super.prependListener(eventName, listener);
            return this;
          }
          once(eventName, listener) {
            super.once(eventName, listener);
            return this;
          }
          prependOnceListener(eventName, listener) {
            super.prependOnceListener(eventName, listener);
            return this;
          }
          removeListener(eventName, listener) {
            super.off(eventName, listener);
            return this;
          }
          removeAllListeners(eventName) {
            super.removeAllListeners(eventName);
            return this;
          }
          listenerCount(eventName) {
            return super.listenerCount(eventName);
          }
          listeners(eventName) {
            return super.listeners(eventName);
          }
          rawListeners(eventName) {
            return super.rawListeners(eventName);
          }
        }
        exports.EnhancedEventEmitter = EnhancedEventEmitter;
      },
      { "./Logger": 43, events: 31 },
    ],
    43: [
      function (require, module, exports) {
        "use strict";
        var __importDefault =
          (this && this.__importDefault) ||
          function (mod) {
            return mod && mod.__esModule ? mod : { default: mod };
          };
        Object.defineProperty(exports, "__esModule", { value: true });
        exports.Logger = void 0;
        const debug_1 = __importDefault(require("debug"));
        const APP_NAME = "mediasoup-client";
        class Logger {
          constructor(prefix) {
            if (prefix) {
              this._debug = (0, debug_1.default)(`${APP_NAME}:${prefix}`);
              this._warn = (0, debug_1.default)(`${APP_NAME}:WARN:${prefix}`);
              this._error = (0, debug_1.default)(`${APP_NAME}:ERROR:${prefix}`);
            } else {
              this._debug = (0, debug_1.default)(APP_NAME);
              this._warn = (0, debug_1.default)(`${APP_NAME}:WARN`);
              this._error = (0, debug_1.default)(`${APP_NAME}:ERROR`);
            }
            /* eslint-disable no-console */
            this._debug.log = console.info.bind(console);
            this._warn.log = console.warn.bind(console);
            this._error.log = console.error.bind(console);
            /* eslint-enable no-console */
          }
          get debug() {
            return this._debug;
          }
          get warn() {
            return this._warn;
          }
          get error() {
            return this._error;
          }
        }
        exports.Logger = Logger;
      },
      { debug: 73 },
    ],
    44: [
      function (require, module, exports) {
        "use strict";
        Object.defineProperty(exports, "__esModule", { value: true });
        exports.Producer = void 0;
        const Logger_1 = require("./Logger");
        const EnhancedEventEmitter_1 = require("./EnhancedEventEmitter");
        const errors_1 = require("./errors");
        const logger = new Logger_1.Logger("Producer");
        class Producer extends EnhancedEventEmitter_1.EnhancedEventEmitter {
          constructor({
            id,
            localId,
            rtpSender,
            track,
            rtpParameters,
            stopTracks,
            disableTrackOnPause,
            zeroRtpOnPause,
            appData,
          }) {
            super();
            // Closed flag.
            this._closed = false;
            // Observer instance.
            this._observer = new EnhancedEventEmitter_1.EnhancedEventEmitter();
            logger.debug("constructor()");
            this._id = id;
            this._localId = localId;
            this._rtpSender = rtpSender;
            this._track = track;
            this._kind = track.kind;
            this._rtpParameters = rtpParameters;
            this._paused = disableTrackOnPause ? !track.enabled : false;
            this._maxSpatialLayer = undefined;
            this._stopTracks = stopTracks;
            this._disableTrackOnPause = disableTrackOnPause;
            this._zeroRtpOnPause = zeroRtpOnPause;
            this._appData = appData || {};
            this.onTrackEnded = this.onTrackEnded.bind(this);
            // NOTE: Minor issue. If zeroRtpOnPause is true, we cannot emit the
            // '@replacetrack' event here, so RTCRtpSender.track won't be null.
            this.handleTrack();
          }
          /**
           * Producer id.
           */
          get id() {
            return this._id;
          }
          /**
           * Local id.
           */
          get localId() {
            return this._localId;
          }
          /**
           * Whether the Producer is closed.
           */
          get closed() {
            return this._closed;
          }
          /**
           * Media kind.
           */
          get kind() {
            return this._kind;
          }
          /**
           * Associated RTCRtpSender.
           */
          get rtpSender() {
            return this._rtpSender;
          }
          /**
           * The associated track.
           */
          get track() {
            return this._track;
          }
          /**
           * RTP parameters.
           */
          get rtpParameters() {
            return this._rtpParameters;
          }
          /**
           * Whether the Producer is paused.
           */
          get paused() {
            return this._paused;
          }
          /**
           * Max spatial layer.
           *
           * @type {Number | undefined}
           */
          get maxSpatialLayer() {
            return this._maxSpatialLayer;
          }
          /**
           * App custom data.
           */
          get appData() {
            return this._appData;
          }
          /**
           * App custom data setter.
           */
          set appData(appData) {
            this._appData = appData;
          }
          get observer() {
            return this._observer;
          }
          /**
           * Closes the Producer.
           */
          close() {
            if (this._closed) {
              return;
            }
            logger.debug("close()");
            this._closed = true;
            this.destroyTrack();
            this.emit("@close");
            // Emit observer event.
            this._observer.safeEmit("close");
          }
          /**
           * Transport was closed.
           */
          transportClosed() {
            if (this._closed) {
              return;
            }
            logger.debug("transportClosed()");
            this._closed = true;
            this.destroyTrack();
            this.safeEmit("transportclose");
            // Emit observer event.
            this._observer.safeEmit("close");
          }
          /**
           * Get associated RTCRtpSender stats.
           */
          async getStats() {
            if (this._closed) {
              throw new errors_1.InvalidStateError("closed");
            }
            return new Promise((resolve, reject) => {
              this.safeEmit("@getstats", resolve, reject);
            });
          }
          /**
           * Pauses sending media.
           */
          pause() {
            logger.debug("pause()");
            if (this._closed) {
              logger.error("pause() | Producer closed");
              return;
            }
            this._paused = true;
            if (this._track && this._disableTrackOnPause) {
              this._track.enabled = false;
            }
            if (this._zeroRtpOnPause) {
              new Promise((resolve, reject) => {
                this.safeEmit("@pause", resolve, reject);
              }).catch(() => {});
            }
            // Emit observer event.
            this._observer.safeEmit("pause");
          }
          /**
           * Resumes sending media.
           */
          resume() {
            logger.debug("resume()");
            if (this._closed) {
              logger.error("resume() | Producer closed");
              return;
            }
            this._paused = false;
            if (this._track && this._disableTrackOnPause) {
              this._track.enabled = true;
            }
            if (this._zeroRtpOnPause) {
              new Promise((resolve, reject) => {
                this.safeEmit("@resume", resolve, reject);
              }).catch(() => {});
            }
            // Emit observer event.
            this._observer.safeEmit("resume");
          }
          /**
           * Replaces the current track with a new one or null.
           */
          async replaceTrack({ track }) {
            logger.debug("replaceTrack() [track:%o]", track);
            if (this._closed) {
              // This must be done here. Otherwise there is no chance to stop the given
              // track.
              if (track && this._stopTracks) {
                try {
                  track.stop();
                } catch (error) {}
              }
              throw new errors_1.InvalidStateError("closed");
            } else if (track && track.readyState === "ended") {
              throw new errors_1.InvalidStateError("track ended");
            }
            // Do nothing if this is the same track as the current handled one.
            if (track === this._track) {
              logger.debug("replaceTrack() | same track, ignored");
              return;
            }
            await new Promise((resolve, reject) => {
              this.safeEmit("@replacetrack", track, resolve, reject);
            });
            // Destroy the previous track.
            this.destroyTrack();
            // Set the new track.
            this._track = track;
            // If this Producer was paused/resumed and the state of the new
            // track does not match, fix it.
            if (this._track && this._disableTrackOnPause) {
              if (!this._paused) {
                this._track.enabled = true;
              } else if (this._paused) {
                this._track.enabled = false;
              }
            }
            // Handle the effective track.
            this.handleTrack();
          }
          /**
           * Sets the video max spatial layer to be sent.
           */
          async setMaxSpatialLayer(spatialLayer) {
            if (this._closed) {
              throw new errors_1.InvalidStateError("closed");
            } else if (this._kind !== "video") {
              throw new errors_1.UnsupportedError("not a video Producer");
            } else if (typeof spatialLayer !== "number") {
              throw new TypeError("invalid spatialLayer");
            }
            if (spatialLayer === this._maxSpatialLayer) {
              return;
            }
            await new Promise((resolve, reject) => {
              this.safeEmit(
                "@setmaxspatiallayer",
                spatialLayer,
                resolve,
                reject
              );
            }).catch(() => {});
            this._maxSpatialLayer = spatialLayer;
          }
          async setRtpEncodingParameters(params) {
            if (this._closed) {
              throw new errors_1.InvalidStateError("closed");
            } else if (typeof params !== "object") {
              throw new TypeError("invalid params");
            }
            await new Promise((resolve, reject) => {
              this.safeEmit(
                "@setrtpencodingparameters",
                params,
                resolve,
                reject
              );
            });
          }
          onTrackEnded() {
            logger.debug('track "ended" event');
            this.safeEmit("trackended");
            // Emit observer event.
            this._observer.safeEmit("trackended");
          }
          handleTrack() {
            if (!this._track) {
              return;
            }
            this._track.addEventListener("ended", this.onTrackEnded);
          }
          destroyTrack() {
            if (!this._track) {
              return;
            }
            try {
              this._track.removeEventListener("ended", this.onTrackEnded);
              // Just stop the track unless the app set stopTracks: false.
              if (this._stopTracks) {
                this._track.stop();
              }
            } catch (error) {}
          }
        }
        exports.Producer = Producer;
      },
      { "./EnhancedEventEmitter": 42, "./Logger": 43, "./errors": 48 },
    ],
    45: [
      function (require, module, exports) {
        "use strict";
        /**
         * The RTP capabilities define what mediasoup or an endpoint can receive at
         * media level.
         */
        Object.defineProperty(exports, "__esModule", { value: true });
      },
      {},
    ],
    46: [
      function (require, module, exports) {
        "use strict";
        Object.defineProperty(exports, "__esModule", { value: true });
      },
      {},
    ],
    47: [
      function (require, module, exports) {
        "use strict";
        var __createBinding =
          (this && this.__createBinding) ||
          (Object.create
            ? function (o, m, k, k2) {
                if (k2 === undefined) k2 = k;
                var desc = Object.getOwnPropertyDescriptor(m, k);
                if (
                  !desc ||
                  ("get" in desc
                    ? !m.__esModule
                    : desc.writable || desc.configurable)
                ) {
                  desc = {
                    enumerable: true,
                    get: function () {
                      return m[k];
                    },
                  };
                }
                Object.defineProperty(o, k2, desc);
              }
            : function (o, m, k, k2) {
                if (k2 === undefined) k2 = k;
                o[k2] = m[k];
              });
        var __setModuleDefault =
          (this && this.__setModuleDefault) ||
          (Object.create
            ? function (o, v) {
                Object.defineProperty(o, "default", {
                  enumerable: true,
                  value: v,
                });
              }
            : function (o, v) {
                o["default"] = v;
              });
        var __importStar =
          (this && this.__importStar) ||
          function (mod) {
            if (mod && mod.__esModule) return mod;
            var result = {};
            if (mod != null)
              for (var k in mod)
                if (
                  k !== "default" &&
                  Object.prototype.hasOwnProperty.call(mod, k)
                )
                  __createBinding(result, mod, k);
            __setModuleDefault(result, mod);
            return result;
          };
        var __importDefault =
          (this && this.__importDefault) ||
          function (mod) {
            return mod && mod.__esModule ? mod : { default: mod };
          };
        Object.defineProperty(exports, "__esModule", { value: true });
        exports.Transport = void 0;
        const awaitqueue_1 = require("awaitqueue");
        const queue_microtask_1 = __importDefault(require("queue-microtask"));
        const Logger_1 = require("./Logger");
        const EnhancedEventEmitter_1 = require("./EnhancedEventEmitter");
        const errors_1 = require("./errors");
        const utils = __importStar(require("./utils"));
        const ortc = __importStar(require("./ortc"));
        const Producer_1 = require("./Producer");
        const Consumer_1 = require("./Consumer");
        const DataProducer_1 = require("./DataProducer");
        const DataConsumer_1 = require("./DataConsumer");
        const logger = new Logger_1.Logger("Transport");
        class ConsumerCreationTask {
          constructor(consumerOptions) {
            this.consumerOptions = consumerOptions;
            this.promise = new Promise((resolve, reject) => {
              this.resolve = resolve;
              this.reject = reject;
            });
          }
        }
        class Transport extends EnhancedEventEmitter_1.EnhancedEventEmitter {
          constructor({
            direction,
            id,
            iceParameters,
            iceCandidates,
            dtlsParameters,
            sctpParameters,
            iceServers,
            iceTransportPolicy,
            additionalSettings,
            proprietaryConstraints,
            appData,
            handlerFactory,
            extendedRtpCapabilities,
            canProduceByKind,
          }) {
            super();
            // Closed flag.
            this._closed = false;
            // Transport ICE gathering state.
            this._iceGatheringState = "new";
            // Transport connection state.
            this._connectionState = "new";
            // Map of Producers indexed by id.
            this._producers = new Map();
            // Map of Consumers indexed by id.
            this._consumers = new Map();
            // Map of DataProducers indexed by id.
            this._dataProducers = new Map();
            // Map of DataConsumers indexed by id.
            this._dataConsumers = new Map();
            // Whether the Consumer for RTP probation has been created.
            this._probatorConsumerCreated = false;
            // AwaitQueue instance to make async tasks happen sequentially.
            this._awaitQueue = new awaitqueue_1.AwaitQueue();
            // Consumer creation tasks awaiting to be processed.
            this._pendingConsumerTasks = [];
            // Consumer creation in progress flag.
            this._consumerCreationInProgress = false;
            // Consumers pending to be paused.
            this._pendingPauseConsumers = new Map();
            // Consumer pause in progress flag.
            this._consumerPauseInProgress = false;
            // Consumers pending to be resumed.
            this._pendingResumeConsumers = new Map();
            // Consumer resume in progress flag.
            this._consumerResumeInProgress = false;
            // Consumers pending to be closed.
            this._pendingCloseConsumers = new Map();
            // Consumer close in progress flag.
            this._consumerCloseInProgress = false;
            // Observer instance.
            this._observer = new EnhancedEventEmitter_1.EnhancedEventEmitter();
            logger.debug("constructor() [id:%s, direction:%s]", id, direction);
            this._id = id;
            this._direction = direction;
            this._extendedRtpCapabilities = extendedRtpCapabilities;
            this._canProduceByKind = canProduceByKind;
            this._maxSctpMessageSize = sctpParameters
              ? sctpParameters.maxMessageSize
              : null;
            // Clone and sanitize additionalSettings.
            additionalSettings = utils.clone(additionalSettings) || {};
            delete additionalSettings.iceServers;
            delete additionalSettings.iceTransportPolicy;
            delete additionalSettings.bundlePolicy;
            delete additionalSettings.rtcpMuxPolicy;
            delete additionalSettings.sdpSemantics;
            this._handler = handlerFactory();
            this._handler.run({
              direction,
              iceParameters,
              iceCandidates,
              dtlsParameters,
              sctpParameters,
              iceServers,
              iceTransportPolicy,
              additionalSettings,
              proprietaryConstraints,
              extendedRtpCapabilities,
            });
            this._appData = appData || {};
            this.handleHandler();
          }
          /**
           * Transport id.
           */
          get id() {
            return this._id;
          }
          /**
           * Whether the Transport is closed.
           */
          get closed() {
            return this._closed;
          }
          /**
           * Transport direction.
           */
          get direction() {
            return this._direction;
          }
          /**
           * RTC handler instance.
           */
          get handler() {
            return this._handler;
          }
          /**
           * ICE gathering state.
           */
          get iceGatheringState() {
            return this._iceGatheringState;
          }
          /**
           * Connection state.
           */
          get connectionState() {
            return this._connectionState;
          }
          /**
           * App custom data.
           */
          get appData() {
            return this._appData;
          }
          /**
           * App custom data setter.
           */
          set appData(appData) {
            this._appData = appData;
          }
          get observer() {
            return this._observer;
          }
          /**
           * Close the Transport.
           */
          close() {
            if (this._closed) {
              return;
            }
            logger.debug("close()");
            this._closed = true;
            // Stop the AwaitQueue.
            this._awaitQueue.stop();
            // Close the handler.
            this._handler.close();
            // Change connection state to 'closed' since the handler may not emit
            // '@connectionstatechange' event.
            this._connectionState = "closed";
            // Close all Producers.
            for (const producer of this._producers.values()) {
              producer.transportClosed();
            }
            this._producers.clear();
            // Close all Consumers.
            for (const consumer of this._consumers.values()) {
              consumer.transportClosed();
            }
            this._consumers.clear();
            // Close all DataProducers.
            for (const dataProducer of this._dataProducers.values()) {
              dataProducer.transportClosed();
            }
            this._dataProducers.clear();
            // Close all DataConsumers.
            for (const dataConsumer of this._dataConsumers.values()) {
              dataConsumer.transportClosed();
            }
            this._dataConsumers.clear();
            // Emit observer event.
            this._observer.safeEmit("close");
          }
          /**
           * Get associated Transport (RTCPeerConnection) stats.
           *
           * @returns {RTCStatsReport}
           */
          async getStats() {
            if (this._closed) {
              throw new errors_1.InvalidStateError("closed");
            }
            return this._handler.getTransportStats();
          }
          /**
           * Restart ICE connection.
           */
          async restartIce({ iceParameters }) {
            logger.debug("restartIce()");
            if (this._closed) {
              throw new errors_1.InvalidStateError("closed");
            } else if (!iceParameters) {
              throw new TypeError("missing iceParameters");
            }
            // Enqueue command.
            return this._awaitQueue.push(
              async () => await this._handler.restartIce(iceParameters),
              "transport.restartIce()"
            );
          }
          /**
           * Update ICE servers.
           */
          async updateIceServers({ iceServers } = {}) {
            logger.debug("updateIceServers()");
            if (this._closed) {
              throw new errors_1.InvalidStateError("closed");
            } else if (!Array.isArray(iceServers)) {
              throw new TypeError("missing iceServers");
            }
            // Enqueue command.
            return this._awaitQueue.push(
              async () => this._handler.updateIceServers(iceServers),
              "transport.updateIceServers()"
            );
          }
          /**
           * Create a Producer.
           */
          async produce({
            track,
            encodings,
            codecOptions,
            codec,
            stopTracks = true,
            disableTrackOnPause = true,
            zeroRtpOnPause = false,
            appData = {},
          } = {}) {
            logger.debug("produce() [track:%o]", track);
            if (this._closed) {
              throw new errors_1.InvalidStateError("closed");
            } else if (!track) {
              throw new TypeError("missing track");
            } else if (this._direction !== "send") {
              throw new errors_1.UnsupportedError("not a sending Transport");
            } else if (!this._canProduceByKind[track.kind]) {
              throw new errors_1.UnsupportedError(
                `cannot produce ${track.kind}`
              );
            } else if (track.readyState === "ended") {
              throw new errors_1.InvalidStateError("track ended");
            } else if (
              this.listenerCount("connect") === 0 &&
              this._connectionState === "new"
            ) {
              throw new TypeError(
                'no "connect" listener set into this transport'
              );
            } else if (this.listenerCount("produce") === 0) {
              throw new TypeError(
                'no "produce" listener set into this transport'
              );
            } else if (appData && typeof appData !== "object") {
              throw new TypeError("if given, appData must be an object");
            }
            // Enqueue command.
            return (
              this._awaitQueue
                .push(async () => {
                  let normalizedEncodings;
                  if (encodings && !Array.isArray(encodings)) {
                    throw TypeError("encodings must be an array");
                  } else if (encodings && encodings.length === 0) {
                    normalizedEncodings = undefined;
                  } else if (encodings) {
                    normalizedEncodings = encodings.map((encoding) => {
                      const normalizedEncoding = { active: true };
                      if (encoding.active === false) {
                        normalizedEncoding.active = false;
                      }
                      if (typeof encoding.dtx === "boolean") {
                        normalizedEncoding.dtx = encoding.dtx;
                      }
                      if (typeof encoding.scalabilityMode === "string") {
                        normalizedEncoding.scalabilityMode =
                          encoding.scalabilityMode;
                      }
                      if (typeof encoding.scaleResolutionDownBy === "number") {
                        normalizedEncoding.scaleResolutionDownBy =
                          encoding.scaleResolutionDownBy;
                      }
                      if (typeof encoding.maxBitrate === "number") {
                        normalizedEncoding.maxBitrate = encoding.maxBitrate;
                      }
                      if (typeof encoding.maxFramerate === "number") {
                        normalizedEncoding.maxFramerate = encoding.maxFramerate;
                      }
                      if (typeof encoding.adaptivePtime === "boolean") {
                        normalizedEncoding.adaptivePtime =
                          encoding.adaptivePtime;
                      }
                      if (typeof encoding.priority === "string") {
                        normalizedEncoding.priority = encoding.priority;
                      }
                      if (typeof encoding.networkPriority === "string") {
                        normalizedEncoding.networkPriority =
                          encoding.networkPriority;
                      }
                      return normalizedEncoding;
                    });
                  }
                  const { localId, rtpParameters, rtpSender } =
                    await this._handler.send({
                      track,
                      encodings: normalizedEncodings,
                      codecOptions,
                      codec,
                    });
                  try {
                    // This will fill rtpParameters's missing fields with default values.
                    ortc.validateRtpParameters(rtpParameters);
                    const { id } = await new Promise((resolve, reject) => {
                      this.safeEmit(
                        "produce",
                        {
                          kind: track.kind,
                          rtpParameters,
                          appData,
                        },
                        resolve,
                        reject
                      );
                    });
                    const producer = new Producer_1.Producer({
                      id,
                      localId,
                      rtpSender,
                      track,
                      rtpParameters,
                      stopTracks,
                      disableTrackOnPause,
                      zeroRtpOnPause,
                      appData,
                    });
                    this._producers.set(producer.id, producer);
                    this.handleProducer(producer);
                    // Emit observer event.
                    this._observer.safeEmit("newproducer", producer);
                    return producer;
                  } catch (error) {
                    this._handler.stopSending(localId).catch(() => {});
                    throw error;
                  }
                }, "transport.produce()")
                // This catch is needed to stop the given track if the command above
                // failed due to closed Transport.
                .catch((error) => {
                  if (stopTracks) {
                    try {
                      track.stop();
                    } catch (error2) {}
                  }
                  throw error;
                })
            );
          }
          /**
           * Create a Consumer to consume a remote Producer.
           */
          async consume({
            id,
            producerId,
            kind,
            rtpParameters,
            streamId,
            appData = {},
          }) {
            logger.debug("consume()");
            rtpParameters = utils.clone(rtpParameters);
            if (this._closed) {
              throw new errors_1.InvalidStateError("closed");
            } else if (this._direction !== "recv") {
              throw new errors_1.UnsupportedError("not a receiving Transport");
            } else if (typeof id !== "string") {
              throw new TypeError("missing id");
            } else if (typeof producerId !== "string") {
              throw new TypeError("missing producerId");
            } else if (kind !== "audio" && kind !== "video") {
              throw new TypeError(`invalid kind '${kind}'`);
            } else if (
              this.listenerCount("connect") === 0 &&
              this._connectionState === "new"
            ) {
              throw new TypeError(
                'no "connect" listener set into this transport'
              );
            } else if (appData && typeof appData !== "object") {
              throw new TypeError("if given, appData must be an object");
            }
            // Ensure the device can consume it.
            const canConsume = ortc.canReceive(
              rtpParameters,
              this._extendedRtpCapabilities
            );
            if (!canConsume) {
              throw new errors_1.UnsupportedError(
                "cannot consume this Producer"
              );
            }
            const consumerCreationTask = new ConsumerCreationTask({
              id,
              producerId,
              kind,
              rtpParameters,
              streamId,
              appData,
            });
            // Store the Consumer creation task.
            this._pendingConsumerTasks.push(consumerCreationTask);
            // There is no Consumer creation in progress, create it now.
            (0, queue_microtask_1.default)(() => {
              if (this._closed) {
                return;
              }
              if (this._consumerCreationInProgress === false) {
                this.createPendingConsumers();
              }
            });
            return consumerCreationTask.promise;
          }
          /**
           * Create a DataProducer
           */
          async produceData({
            ordered = true,
            maxPacketLifeTime,
            maxRetransmits,
            label = "",
            protocol = "",
            appData = {},
          } = {}) {
            logger.debug("produceData()");
            if (this._closed) {
              throw new errors_1.InvalidStateError("closed");
            } else if (this._direction !== "send") {
              throw new errors_1.UnsupportedError("not a sending Transport");
            } else if (!this._maxSctpMessageSize) {
              throw new errors_1.UnsupportedError(
                "SCTP not enabled by remote Transport"
              );
            } else if (
              this.listenerCount("connect") === 0 &&
              this._connectionState === "new"
            ) {
              throw new TypeError(
                'no "connect" listener set into this transport'
              );
            } else if (this.listenerCount("producedata") === 0) {
              throw new TypeError(
                'no "producedata" listener set into this transport'
              );
            } else if (appData && typeof appData !== "object") {
              throw new TypeError("if given, appData must be an object");
            }
            if (maxPacketLifeTime || maxRetransmits) {
              ordered = false;
            }
            // Enqueue command.
            return this._awaitQueue.push(async () => {
              const { dataChannel, sctpStreamParameters } =
                await this._handler.sendDataChannel({
                  ordered,
                  maxPacketLifeTime,
                  maxRetransmits,
                  label,
                  protocol,
                });
              // This will fill sctpStreamParameters's missing fields with default values.
              ortc.validateSctpStreamParameters(sctpStreamParameters);
              const { id } = await new Promise((resolve, reject) => {
                this.safeEmit(
                  "producedata",
                  {
                    sctpStreamParameters,
                    label,
                    protocol,
                    appData,
                  },
                  resolve,
                  reject
                );
              });
              const dataProducer = new DataProducer_1.DataProducer({
                id,
                dataChannel,
                sctpStreamParameters,
                appData,
              });
              this._dataProducers.set(dataProducer.id, dataProducer);
              this.handleDataProducer(dataProducer);
              // Emit observer event.
              this._observer.safeEmit("newdataproducer", dataProducer);
              return dataProducer;
            }, "transport.produceData()");
          }
          /**
           * Create a DataConsumer
           */
          async consumeData({
            id,
            dataProducerId,
            sctpStreamParameters,
            label = "",
            protocol = "",
            appData = {},
          }) {
            logger.debug("consumeData()");
            sctpStreamParameters = utils.clone(sctpStreamParameters);
            if (this._closed) {
              throw new errors_1.InvalidStateError("closed");
            } else if (this._direction !== "recv") {
              throw new errors_1.UnsupportedError("not a receiving Transport");
            } else if (!this._maxSctpMessageSize) {
              throw new errors_1.UnsupportedError(
                "SCTP not enabled by remote Transport"
              );
            } else if (typeof id !== "string") {
              throw new TypeError("missing id");
            } else if (typeof dataProducerId !== "string") {
              throw new TypeError("missing dataProducerId");
            } else if (
              this.listenerCount("connect") === 0 &&
              this._connectionState === "new"
            ) {
              throw new TypeError(
                'no "connect" listener set into this transport'
              );
            } else if (appData && typeof appData !== "object") {
              throw new TypeError("if given, appData must be an object");
            }
            // This may throw.
            ortc.validateSctpStreamParameters(sctpStreamParameters);
            // Enqueue command.
            return this._awaitQueue.push(async () => {
              const { dataChannel } = await this._handler.receiveDataChannel({
                sctpStreamParameters,
                label,
                protocol,
              });
              const dataConsumer = new DataConsumer_1.DataConsumer({
                id,
                dataProducerId,
                dataChannel,
                sctpStreamParameters,
                appData,
              });
              this._dataConsumers.set(dataConsumer.id, dataConsumer);
              this.handleDataConsumer(dataConsumer);
              // Emit observer event.
              this._observer.safeEmit("newdataconsumer", dataConsumer);
              return dataConsumer;
            }, "transport.consumeData()");
          }
          // This method is guaranteed to never throw.
          async createPendingConsumers() {
            this._consumerCreationInProgress = true;
            this._awaitQueue
              .push(async () => {
                if (this._pendingConsumerTasks.length === 0) {
                  logger.debug(
                    "createPendingConsumers() | there is no Consumer to be created"
                  );
                  return;
                }
                const pendingConsumerTasks = [...this._pendingConsumerTasks];
                // Clear pending Consumer tasks.
                this._pendingConsumerTasks = [];
                // Video Consumer in order to create the probator.
                let videoConsumerForProbator = undefined;
                // Fill options list.
                const optionsList = [];
                for (const task of pendingConsumerTasks) {
                  const { id, kind, rtpParameters, streamId } =
                    task.consumerOptions;
                  optionsList.push({
                    trackId: id,
                    kind: kind,
                    rtpParameters,
                    streamId,
                  });
                }
                try {
                  const results = await this._handler.receive(optionsList);
                  for (let idx = 0; idx < results.length; ++idx) {
                    const task = pendingConsumerTasks[idx];
                    const result = results[idx];
                    const { id, producerId, kind, rtpParameters, appData } =
                      task.consumerOptions;
                    const { localId, rtpReceiver, track } = result;
                    const consumer = new Consumer_1.Consumer({
                      id: id,
                      localId,
                      producerId: producerId,
                      rtpReceiver,
                      track,
                      rtpParameters,
                      appData: appData,
                    });
                    this._consumers.set(consumer.id, consumer);
                    this.handleConsumer(consumer);
                    // If this is the first video Consumer and the Consumer for RTP probation
                    // has not yet been created, it's time to create it.
                    if (
                      !this._probatorConsumerCreated &&
                      !videoConsumerForProbator &&
                      kind === "video"
                    ) {
                      videoConsumerForProbator = consumer;
                    }
                    // Emit observer event.
                    this._observer.safeEmit("newconsumer", consumer);
                    task.resolve(consumer);
                  }
                } catch (error) {
                  for (const task of pendingConsumerTasks) {
                    task.reject(error);
                  }
                }
                // If RTP probation must be handled, do it now.
                if (videoConsumerForProbator) {
                  try {
                    const probatorRtpParameters =
                      ortc.generateProbatorRtpParameters(
                        videoConsumerForProbator.rtpParameters
                      );
                    await this._handler.receive([
                      {
                        trackId: "probator",
                        kind: "video",
                        rtpParameters: probatorRtpParameters,
                      },
                    ]);
                    logger.debug(
                      "createPendingConsumers() | Consumer for RTP probation created"
                    );
                    this._probatorConsumerCreated = true;
                  } catch (error) {
                    logger.error(
                      "createPendingConsumers() | failed to create Consumer for RTP probation:%o",
                      error
                    );
                  }
                }
              }, "transport.createPendingConsumers()")
              .then(() => {
                this._consumerCreationInProgress = false;
                // There are pending Consumer tasks, enqueue their creation.
                if (this._pendingConsumerTasks.length > 0) {
                  this.createPendingConsumers();
                }
              })
              // NOTE: We only get here when the await queue is closed.
              .catch(() => {});
          }
          pausePendingConsumers() {
            this._consumerPauseInProgress = true;
            this._awaitQueue
              .push(async () => {
                if (this._pendingPauseConsumers.size === 0) {
                  logger.debug(
                    "pausePendingConsumers() | there is no Consumer to be paused"
                  );
                  return;
                }
                const pendingPauseConsumers = Array.from(
                  this._pendingPauseConsumers.values()
                );
                // Clear pending pause Consumer map.
                this._pendingPauseConsumers.clear();
                try {
                  const localIds = pendingPauseConsumers.map(
                    (consumer) => consumer.localId
                  );
                  await this._handler.pauseReceiving(localIds);
                } catch (error) {
                  logger.error(
                    "pausePendingConsumers() | failed to pause Consumers:",
                    error
                  );
                }
              }, "transport.pausePendingConsumers")
              .then(() => {
                this._consumerPauseInProgress = false;
                // There are pending Consumers to be paused, do it.
                if (this._pendingPauseConsumers.size > 0) {
                  this.pausePendingConsumers();
                }
              })
              // NOTE: We only get here when the await queue is closed.
              .catch(() => {});
          }
          resumePendingConsumers() {
            this._consumerResumeInProgress = true;
            this._awaitQueue
              .push(async () => {
                if (this._pendingResumeConsumers.size === 0) {
                  logger.debug(
                    "resumePendingConsumers() | there is no Consumer to be resumed"
                  );
                  return;
                }
                const pendingResumeConsumers = Array.from(
                  this._pendingResumeConsumers.values()
                );
                // Clear pending resume Consumer map.
                this._pendingResumeConsumers.clear();
                try {
                  const localIds = pendingResumeConsumers.map(
                    (consumer) => consumer.localId
                  );
                  await this._handler.resumeReceiving(localIds);
                } catch (error) {
                  logger.error(
                    "resumePendingConsumers() | failed to resume Consumers:",
                    error
                  );
                }
              }, "transport.resumePendingConsumers")
              .then(() => {
                this._consumerResumeInProgress = false;
                // There are pending Consumer to be resumed, do it.
                if (this._pendingResumeConsumers.size > 0) {
                  this.resumePendingConsumers();
                }
              })
              // NOTE: We only get here when the await queue is closed.
              .catch(() => {});
          }
          closePendingConsumers() {
            this._consumerCloseInProgress = true;
            this._awaitQueue
              .push(async () => {
                if (this._pendingCloseConsumers.size === 0) {
                  logger.debug(
                    "closePendingConsumers() | there is no Consumer to be closed"
                  );
                  return;
                }
                const pendingCloseConsumers = Array.from(
                  this._pendingCloseConsumers.values()
                );
                // Clear pending close Consumer map.
                this._pendingCloseConsumers.clear();
                try {
                  await this._handler.stopReceiving(
                    pendingCloseConsumers.map((consumer) => consumer.localId)
                  );
                } catch (error) {
                  logger.error(
                    "closePendingConsumers() | failed to close Consumers:",
                    error
                  );
                }
              }, "transport.closePendingConsumers")
              .then(() => {
                this._consumerCloseInProgress = false;
                // There are pending Consumer to be resumed, do it.
                if (this._pendingCloseConsumers.size > 0) {
                  this.closePendingConsumers();
                }
              })
              // NOTE: We only get here when the await queue is closed.
              .catch(() => {});
          }
          handleHandler() {
            const handler = this._handler;
            handler.on("@connect", ({ dtlsParameters }, callback, errback) => {
              if (this._closed) {
                errback(new errors_1.InvalidStateError("closed"));
                return;
              }
              this.safeEmit("connect", { dtlsParameters }, callback, errback);
            });
            handler.on("@icegatheringstatechange", (iceGatheringState) => {
              if (iceGatheringState === this._iceGatheringState) {
                return;
              }
              logger.debug(
                "ICE gathering state changed to %s",
                iceGatheringState
              );
              this._iceGatheringState = iceGatheringState;
              if (!this._closed) {
                this.safeEmit("icegatheringstatechange", iceGatheringState);
              }
            });
            handler.on("@connectionstatechange", (connectionState) => {
              if (connectionState === this._connectionState) {
                return;
              }
              logger.debug("connection state changed to %s", connectionState);
              this._connectionState = connectionState;
              if (!this._closed) {
                this.safeEmit("connectionstatechange", connectionState);
              }
            });
          }
          handleProducer(producer) {
            producer.on("@close", () => {
              this._producers.delete(producer.id);
              if (this._closed) {
                return;
              }
              this._awaitQueue
                .push(
                  async () => await this._handler.stopSending(producer.localId),
                  "producer @close event"
                )
                .catch((error) =>
                  logger.warn("producer.close() failed:%o", error)
                );
            });
            producer.on("@pause", (callback, errback) => {
              this._awaitQueue
                .push(
                  async () =>
                    await this._handler.pauseSending(producer.localId),
                  "producer @pause event"
                )
                .then(callback)
                .catch(errback);
            });
            producer.on("@resume", (callback, errback) => {
              this._awaitQueue
                .push(
                  async () =>
                    await this._handler.resumeSending(producer.localId),
                  "producer @resume event"
                )
                .then(callback)
                .catch(errback);
            });
            producer.on("@replacetrack", (track, callback, errback) => {
              this._awaitQueue
                .push(
                  async () =>
                    await this._handler.replaceTrack(producer.localId, track),
                  "producer @replacetrack event"
                )
                .then(callback)
                .catch(errback);
            });
            producer.on(
              "@setmaxspatiallayer",
              (spatialLayer, callback, errback) => {
                this._awaitQueue
                  .push(
                    async () =>
                      await this._handler.setMaxSpatialLayer(
                        producer.localId,
                        spatialLayer
                      ),
                    "producer @setmaxspatiallayer event"
                  )
                  .then(callback)
                  .catch(errback);
              }
            );
            producer.on(
              "@setrtpencodingparameters",
              (params, callback, errback) => {
                this._awaitQueue
                  .push(
                    async () =>
                      await this._handler.setRtpEncodingParameters(
                        producer.localId,
                        params
                      ),
                    "producer @setrtpencodingparameters event"
                  )
                  .then(callback)
                  .catch(errback);
              }
            );
            producer.on("@getstats", (callback, errback) => {
              if (this._closed) {
                return errback(new errors_1.InvalidStateError("closed"));
              }
              this._handler
                .getSenderStats(producer.localId)
                .then(callback)
                .catch(errback);
            });
          }
          handleConsumer(consumer) {
            consumer.on("@close", () => {
              this._consumers.delete(consumer.id);
              this._pendingPauseConsumers.delete(consumer.id);
              this._pendingResumeConsumers.delete(consumer.id);
              if (this._closed) {
                return;
              }
              // Store the Consumer into the close list.
              this._pendingCloseConsumers.set(consumer.id, consumer);
              // There is no Consumer close in progress, do it now.
              if (this._consumerCloseInProgress === false) {
                this.closePendingConsumers();
              }
            });
            consumer.on("@pause", () => {
              // If Consumer is pending to be resumed, remove from pending resume list.
              if (this._pendingResumeConsumers.has(consumer.id)) {
                this._pendingResumeConsumers.delete(consumer.id);
              }
              // Store the Consumer into the pending list.
              this._pendingPauseConsumers.set(consumer.id, consumer);
              // There is no Consumer pause in progress, do it now.
              (0, queue_microtask_1.default)(() => {
                if (this._closed) {
                  return;
                }
                if (this._consumerPauseInProgress === false) {
                  this.pausePendingConsumers();
                }
              });
            });
            consumer.on("@resume", () => {
              // If Consumer is pending to be paused, remove from pending pause list.
              if (this._pendingPauseConsumers.has(consumer.id)) {
                this._pendingPauseConsumers.delete(consumer.id);
              }
              // Store the Consumer into the pending list.
              this._pendingResumeConsumers.set(consumer.id, consumer);
              // There is no Consumer resume in progress, do it now.
              (0, queue_microtask_1.default)(() => {
                if (this._closed) {
                  return;
                }
                if (this._consumerResumeInProgress === false) {
                  this.resumePendingConsumers();
                }
              });
            });
            consumer.on("@getstats", (callback, errback) => {
              if (this._closed) {
                return errback(new errors_1.InvalidStateError("closed"));
              }
              this._handler
                .getReceiverStats(consumer.localId)
                .then(callback)
                .catch(errback);
            });
          }
          handleDataProducer(dataProducer) {
            dataProducer.on("@close", () => {
              this._dataProducers.delete(dataProducer.id);
            });
          }
          handleDataConsumer(dataConsumer) {
            dataConsumer.on("@close", () => {
              this._dataConsumers.delete(dataConsumer.id);
            });
          }
        }
        exports.Transport = Transport;
      },
      {
        "./Consumer": 38,
        "./DataConsumer": 39,
        "./DataProducer": 40,
        "./EnhancedEventEmitter": 42,
        "./Logger": 43,
        "./Producer": 44,
        "./errors": 48,
        "./ortc": 69,
        "./utils": 72,
        awaitqueue: 3,
        "queue-microtask": 77,
      },
    ],
    48: [
      function (require, module, exports) {
        "use strict";
        Object.defineProperty(exports, "__esModule", { value: true });
        exports.InvalidStateError = exports.UnsupportedError = void 0;
        /**
         * Error indicating not support for something.
         */
        class UnsupportedError extends Error {
          constructor(message) {
            super(message);
            this.name = "UnsupportedError";
            if (Error.hasOwnProperty("captureStackTrace")) {
              // Just in V8.
              // @ts-ignore
              Error.captureStackTrace(this, UnsupportedError);
            } else {
              this.stack = new Error(message).stack;
            }
          }
        }
        exports.UnsupportedError = UnsupportedError;
        /**
         * Error produced when calling a method in an invalid state.
         */
        class InvalidStateError extends Error {
          constructor(message) {
            super(message);
            this.name = "InvalidStateError";
            if (Error.hasOwnProperty("captureStackTrace")) {
              // Just in V8.
              // @ts-ignore
              Error.captureStackTrace(this, InvalidStateError);
            } else {
              this.stack = new Error(message).stack;
            }
          }
        }
        exports.InvalidStateError = InvalidStateError;
      },
      {},
    ],
    49: [
      function (require, module, exports) {
        "use strict";
        var __createBinding =
          (this && this.__createBinding) ||
          (Object.create
            ? function (o, m, k, k2) {
                if (k2 === undefined) k2 = k;
                var desc = Object.getOwnPropertyDescriptor(m, k);
                if (
                  !desc ||
                  ("get" in desc
                    ? !m.__esModule
                    : desc.writable || desc.configurable)
                ) {
                  desc = {
                    enumerable: true,
                    get: function () {
                      return m[k];
                    },
                  };
                }
                Object.defineProperty(o, k2, desc);
              }
            : function (o, m, k, k2) {
                if (k2 === undefined) k2 = k;
                o[k2] = m[k];
              });
        var __setModuleDefault =
          (this && this.__setModuleDefault) ||
          (Object.create
            ? function (o, v) {
                Object.defineProperty(o, "default", {
                  enumerable: true,
                  value: v,
                });
              }
            : function (o, v) {
                o["default"] = v;
              });
        var __importStar =
          (this && this.__importStar) ||
          function (mod) {
            if (mod && mod.__esModule) return mod;
            var result = {};
            if (mod != null)
              for (var k in mod)
                if (
                  k !== "default" &&
                  Object.prototype.hasOwnProperty.call(mod, k)
                )
                  __createBinding(result, mod, k);
            __setModuleDefault(result, mod);
            return result;
          };
        Object.defineProperty(exports, "__esModule", { value: true });
        exports.Chrome111 = void 0;
        const sdpTransform = __importStar(require("sdp-transform"));
        const Logger_1 = require("../Logger");
        const utils = __importStar(require("../utils"));
        const ortc = __importStar(require("../ortc"));
        const sdpCommonUtils = __importStar(require("./sdp/commonUtils"));
        const sdpUnifiedPlanUtils = __importStar(
          require("./sdp/unifiedPlanUtils")
        );
        const ortcUtils = __importStar(require("./ortc/utils"));
        const errors_1 = require("../errors");
        const HandlerInterface_1 = require("./HandlerInterface");
        const RemoteSdp_1 = require("./sdp/RemoteSdp");
        const scalabilityModes_1 = require("../scalabilityModes");
        const logger = new Logger_1.Logger("Chrome111");
        const SCTP_NUM_STREAMS = { OS: 1024, MIS: 1024 };
        class Chrome111 extends HandlerInterface_1.HandlerInterface {
          /**
           * Creates a factory function.
           */
          static createFactory() {
            return () => new Chrome111();
          }
          constructor() {
            super();
            // Closed flag.
            this._closed = false;
            // Map of RTCTransceivers indexed by MID.
            this._mapMidTransceiver = new Map();
            // Local stream for sending.
            this._sendStream = new MediaStream();
            // Whether a DataChannel m=application section has been created.
            this._hasDataChannelMediaSection = false;
            // Sending DataChannel id value counter. Incremented for each new DataChannel.
            this._nextSendSctpStreamId = 0;
            // Got transport local and remote parameters.
            this._transportReady = false;
          }
          get name() {
            return "Chrome111";
          }
          close() {
            logger.debug("close()");
            if (this._closed) {
              return;
            }
            this._closed = true;
            // Close RTCPeerConnection.
            if (this._pc) {
              try {
                this._pc.close();
              } catch (error) {}
            }
            this.emit("@close");
          }
          async getNativeRtpCapabilities() {
            logger.debug("getNativeRtpCapabilities()");
            const pc = new RTCPeerConnection({
              iceServers: [],
              iceTransportPolicy: "all",
              bundlePolicy: "max-bundle",
              rtcpMuxPolicy: "require",
              sdpSemantics: "unified-plan",
            });
            try {
              pc.addTransceiver("audio");
              pc.addTransceiver("video");
              const offer = await pc.createOffer();
              try {
                pc.close();
              } catch (error) {}
              const sdpObject = sdpTransform.parse(offer.sdp);
              const nativeRtpCapabilities =
                sdpCommonUtils.extractRtpCapabilities({
                  sdpObject,
                });
              // libwebrtc supports NACK for OPUS but doesn't announce it.
              ortcUtils.addNackSuppportForOpus(nativeRtpCapabilities);
              return nativeRtpCapabilities;
            } catch (error) {
              try {
                pc.close();
              } catch (error2) {}
              throw error;
            }
          }
          async getNativeSctpCapabilities() {
            logger.debug("getNativeSctpCapabilities()");
            return {
              numStreams: SCTP_NUM_STREAMS,
            };
          }
          run({
            direction,
            iceParameters,
            iceCandidates,
            dtlsParameters,
            sctpParameters,
            iceServers,
            iceTransportPolicy,
            additionalSettings,
            proprietaryConstraints,
            extendedRtpCapabilities,
          }) {
            this.assertNotClosed();
            logger.debug("run()");
            this._direction = direction;
            this._remoteSdp = new RemoteSdp_1.RemoteSdp({
              iceParameters,
              iceCandidates,
              dtlsParameters,
              sctpParameters,
            });
            this._sendingRtpParametersByKind = {
              audio: ortc.getSendingRtpParameters(
                "audio",
                extendedRtpCapabilities
              ),
              video: ortc.getSendingRtpParameters(
                "video",
                extendedRtpCapabilities
              ),
            };
            this._sendingRemoteRtpParametersByKind = {
              audio: ortc.getSendingRemoteRtpParameters(
                "audio",
                extendedRtpCapabilities
              ),
              video: ortc.getSendingRemoteRtpParameters(
                "video",
                extendedRtpCapabilities
              ),
            };
            if (dtlsParameters.role && dtlsParameters.role !== "auto") {
              this._forcedLocalDtlsRole =
                dtlsParameters.role === "server" ? "client" : "server";
            }
            this._pc = new RTCPeerConnection(
              {
                iceServers: iceServers || [],
                iceTransportPolicy: iceTransportPolicy || "all",
                bundlePolicy: "max-bundle",
                rtcpMuxPolicy: "require",
                sdpSemantics: "unified-plan",
                ...additionalSettings,
              },
              proprietaryConstraints
            );
            this._pc.addEventListener("icegatheringstatechange", () => {
              this.emit("@icegatheringstatechange", this._pc.iceGatheringState);
            });
            if (this._pc.connectionState) {
              this._pc.addEventListener("connectionstatechange", () => {
                this.emit("@connectionstatechange", this._pc.connectionState);
              });
            } else {
              logger.warn(
                "run() | pc.connectionState not supported, using pc.iceConnectionState"
              );
              this._pc.addEventListener("iceconnectionstatechange", () => {
                switch (this._pc.iceConnectionState) {
                  case "checking": {
                    this.emit("@connectionstatechange", "connecting");
                    break;
                  }
                  case "connected":
                  case "completed": {
                    this.emit("@connectionstatechange", "connected");
                    break;
                  }
                  case "failed": {
                    this.emit("@connectionstatechange", "failed");
                    break;
                  }
                  case "disconnected": {
                    this.emit("@connectionstatechange", "disconnected");
                    break;
                  }
                  case "closed": {
                    this.emit("@connectionstatechange", "closed");
                    break;
                  }
                }
              });
            }
          }
          async updateIceServers(iceServers) {
            this.assertNotClosed();
            logger.debug("updateIceServers()");
            const configuration = this._pc.getConfiguration();
            configuration.iceServers = iceServers;
            this._pc.setConfiguration(configuration);
          }
          async restartIce(iceParameters) {
            this.assertNotClosed();
            logger.debug("restartIce()");
            // Provide the remote SDP handler with new remote ICE parameters.
            this._remoteSdp.updateIceParameters(iceParameters);
            if (!this._transportReady) {
              return;
            }
            if (this._direction === "send") {
              const offer = await this._pc.createOffer({ iceRestart: true });
              logger.debug(
                "restartIce() | calling pc.setLocalDescription() [offer:%o]",
                offer
              );
              await this._pc.setLocalDescription(offer);
              const answer = { type: "answer", sdp: this._remoteSdp.getSdp() };
              logger.debug(
                "restartIce() | calling pc.setRemoteDescription() [answer:%o]",
                answer
              );
              await this._pc.setRemoteDescription(answer);
            } else {
              const offer = { type: "offer", sdp: this._remoteSdp.getSdp() };
              logger.debug(
                "restartIce() | calling pc.setRemoteDescription() [offer:%o]",
                offer
              );
              await this._pc.setRemoteDescription(offer);
              const answer = await this._pc.createAnswer();
              logger.debug(
                "restartIce() | calling pc.setLocalDescription() [answer:%o]",
                answer
              );
              await this._pc.setLocalDescription(answer);
            }
          }
          async getTransportStats() {
            this.assertNotClosed();
            return this._pc.getStats();
          }
          async send({ track, encodings, codecOptions, codec }) {
            this.assertNotClosed();
            this.assertSendDirection();
            logger.debug("send() [kind:%s, track.id:%s]", track.kind, track.id);
            if (encodings && encodings.length > 1) {
              encodings.forEach((encoding, idx) => {
                encoding.rid = `r${idx}`;
              });
              // Set rid and verify scalabilityMode in each encoding.
              // NOTE: Even if WebRTC allows different scalabilityMode (different number
              // of temporal layers) per simulcast stream, we need that those are the
              // same in all them, so let's pick up the highest value.
              // NOTE: If scalabilityMode is not given, Chrome will use L1T3.
              let nextRid = 1;
              let maxTemporalLayers = 1;
              for (const encoding of encodings) {
                const temporalLayers = encoding.scalabilityMode
                  ? (0, scalabilityModes_1.parse)(encoding.scalabilityMode)
                      .temporalLayers
                  : 3;
                if (temporalLayers > maxTemporalLayers) {
                  maxTemporalLayers = temporalLayers;
                }
              }
              for (const encoding of encodings) {
                encoding.rid = `r${nextRid++}`;
                encoding.scalabilityMode = `L1T${maxTemporalLayers}`;
              }
            }
            const sendingRtpParameters = utils.clone(
              this._sendingRtpParametersByKind[track.kind]
            );
            // This may throw.
            sendingRtpParameters.codecs = ortc.reduceCodecs(
              sendingRtpParameters.codecs,
              codec
            );
            const sendingRemoteRtpParameters = utils.clone(
              this._sendingRemoteRtpParametersByKind[track.kind]
            );
            // This may throw.
            sendingRemoteRtpParameters.codecs = ortc.reduceCodecs(
              sendingRemoteRtpParameters.codecs,
              codec
            );
            const mediaSectionIdx = this._remoteSdp.getNextMediaSectionIdx();
            const transceiver = this._pc.addTransceiver(track, {
              direction: "sendonly",
              streams: [this._sendStream],
              sendEncodings: encodings,
            });
            const offer = await this._pc.createOffer();
            let localSdpObject = sdpTransform.parse(offer.sdp);
            if (!this._transportReady) {
              await this.setupTransport({
                localDtlsRole: this._forcedLocalDtlsRole ?? "client",
                localSdpObject,
              });
            }
            logger.debug(
              "send() | calling pc.setLocalDescription() [offer:%o]",
              offer
            );
            await this._pc.setLocalDescription(offer);
            // We can now get the transceiver.mid.
            const localId = transceiver.mid;
            // Set MID.
            sendingRtpParameters.mid = localId;
            localSdpObject = sdpTransform.parse(this._pc.localDescription.sdp);
            const offerMediaObject = localSdpObject.media[mediaSectionIdx.idx];
            // Set RTCP CNAME.
            sendingRtpParameters.rtcp.cname = sdpCommonUtils.getCname({
              offerMediaObject,
            });
            // Set RTP encodings by parsing the SDP offer if no encodings are given.
            if (!encodings) {
              sendingRtpParameters.encodings =
                sdpUnifiedPlanUtils.getRtpEncodings({
                  offerMediaObject,
                });
            }
            // Set RTP encodings by parsing the SDP offer and complete them with given
            // one if just a single encoding has been given.
            else if (encodings.length === 1) {
              const newEncodings = sdpUnifiedPlanUtils.getRtpEncodings({
                offerMediaObject,
              });
              Object.assign(newEncodings[0], encodings[0]);
              sendingRtpParameters.encodings = newEncodings;
            }
            // Otherwise if more than 1 encoding are given use them verbatim.
            else {
              sendingRtpParameters.encodings = encodings;
            }
            this._remoteSdp.send({
              offerMediaObject,
              reuseMid: mediaSectionIdx.reuseMid,
              offerRtpParameters: sendingRtpParameters,
              answerRtpParameters: sendingRemoteRtpParameters,
              codecOptions,
              extmapAllowMixed: true,
            });
            const answer = { type: "answer", sdp: this._remoteSdp.getSdp() };
            logger.debug(
              "send() | calling pc.setRemoteDescription() [answer:%o]",
              answer
            );
            await this._pc.setRemoteDescription(answer);
            // Store in the map.
            this._mapMidTransceiver.set(localId, transceiver);
            return {
              localId,
              rtpParameters: sendingRtpParameters,
              rtpSender: transceiver.sender,
            };
          }
          async stopSending(localId) {
            this.assertSendDirection();
            logger.debug("stopSending() [localId:%s]", localId);
            if (this._closed) {
              return;
            }
            const transceiver = this._mapMidTransceiver.get(localId);
            if (!transceiver) {
              throw new Error("associated RTCRtpTransceiver not found");
            }
            transceiver.sender.replaceTrack(null);
            this._pc.removeTrack(transceiver.sender);
            const mediaSectionClosed = this._remoteSdp.closeMediaSection(
              transceiver.mid
            );
            if (mediaSectionClosed) {
              try {
                transceiver.stop();
              } catch (error) {}
            }
            const offer = await this._pc.createOffer();
            logger.debug(
              "stopSending() | calling pc.setLocalDescription() [offer:%o]",
              offer
            );
            await this._pc.setLocalDescription(offer);
            const answer = { type: "answer", sdp: this._remoteSdp.getSdp() };
            logger.debug(
              "stopSending() | calling pc.setRemoteDescription() [answer:%o]",
              answer
            );
            await this._pc.setRemoteDescription(answer);
            this._mapMidTransceiver.delete(localId);
          }
          async pauseSending(localId) {
            this.assertNotClosed();
            this.assertSendDirection();
            logger.debug("pauseSending() [localId:%s]", localId);
            const transceiver = this._mapMidTransceiver.get(localId);
            if (!transceiver) {
              throw new Error("associated RTCRtpTransceiver not found");
            }
            transceiver.direction = "inactive";
            this._remoteSdp.pauseMediaSection(localId);
            const offer = await this._pc.createOffer();
            logger.debug(
              "pauseSending() | calling pc.setLocalDescription() [offer:%o]",
              offer
            );
            await this._pc.setLocalDescription(offer);
            const answer = { type: "answer", sdp: this._remoteSdp.getSdp() };
            logger.debug(
              "pauseSending() | calling pc.setRemoteDescription() [answer:%o]",
              answer
            );
            await this._pc.setRemoteDescription(answer);
          }
          async resumeSending(localId) {
            this.assertNotClosed();
            this.assertSendDirection();
            logger.debug("resumeSending() [localId:%s]", localId);
            const transceiver = this._mapMidTransceiver.get(localId);
            this._remoteSdp.resumeSendingMediaSection(localId);
            if (!transceiver) {
              throw new Error("associated RTCRtpTransceiver not found");
            }
            transceiver.direction = "sendonly";
            const offer = await this._pc.createOffer();
            logger.debug(
              "resumeSending() | calling pc.setLocalDescription() [offer:%o]",
              offer
            );
            await this._pc.setLocalDescription(offer);
            const answer = { type: "answer", sdp: this._remoteSdp.getSdp() };
            logger.debug(
              "resumeSending() | calling pc.setRemoteDescription() [answer:%o]",
              answer
            );
            await this._pc.setRemoteDescription(answer);
          }
          async replaceTrack(localId, track) {
            this.assertNotClosed();
            this.assertSendDirection();
            if (track) {
              logger.debug(
                "replaceTrack() [localId:%s, track.id:%s]",
                localId,
                track.id
              );
            } else {
              logger.debug("replaceTrack() [localId:%s, no track]", localId);
            }
            const transceiver = this._mapMidTransceiver.get(localId);
            if (!transceiver) {
              throw new Error("associated RTCRtpTransceiver not found");
            }
            await transceiver.sender.replaceTrack(track);
          }
          async setMaxSpatialLayer(localId, spatialLayer) {
            this.assertNotClosed();
            this.assertSendDirection();
            logger.debug(
              "setMaxSpatialLayer() [localId:%s, spatialLayer:%s]",
              localId,
              spatialLayer
            );
            const transceiver = this._mapMidTransceiver.get(localId);
            if (!transceiver) {
              throw new Error("associated RTCRtpTransceiver not found");
            }
            const parameters = transceiver.sender.getParameters();
            parameters.encodings.forEach((encoding, idx) => {
              if (idx <= spatialLayer) {
                encoding.active = true;
              } else {
                encoding.active = false;
              }
            });
            await transceiver.sender.setParameters(parameters);
            this._remoteSdp.muxMediaSectionSimulcast(
              localId,
              parameters.encodings
            );
            const offer = await this._pc.createOffer();
            logger.debug(
              "setMaxSpatialLayer() | calling pc.setLocalDescription() [offer:%o]",
              offer
            );
            await this._pc.setLocalDescription(offer);
            const answer = { type: "answer", sdp: this._remoteSdp.getSdp() };
            logger.debug(
              "setMaxSpatialLayer() | calling pc.setRemoteDescription() [answer:%o]",
              answer
            );
            await this._pc.setRemoteDescription(answer);
          }
          async setRtpEncodingParameters(localId, params) {
            this.assertNotClosed();
            this.assertSendDirection();
            logger.debug(
              "setRtpEncodingParameters() [localId:%s, params:%o]",
              localId,
              params
            );
            const transceiver = this._mapMidTransceiver.get(localId);
            if (!transceiver) {
              throw new Error("associated RTCRtpTransceiver not found");
            }
            const parameters = transceiver.sender.getParameters();
            parameters.encodings.forEach((encoding, idx) => {
              parameters.encodings[idx] = { ...encoding, ...params };
            });
            await transceiver.sender.setParameters(parameters);
            this._remoteSdp.muxMediaSectionSimulcast(
              localId,
              parameters.encodings
            );
            const offer = await this._pc.createOffer();
            logger.debug(
              "setRtpEncodingParameters() | calling pc.setLocalDescription() [offer:%o]",
              offer
            );
            await this._pc.setLocalDescription(offer);
            const answer = { type: "answer", sdp: this._remoteSdp.getSdp() };
            logger.debug(
              "setRtpEncodingParameters() | calling pc.setRemoteDescription() [answer:%o]",
              answer
            );
            await this._pc.setRemoteDescription(answer);
          }
          async getSenderStats(localId) {
            this.assertNotClosed();
            this.assertSendDirection();
            const transceiver = this._mapMidTransceiver.get(localId);
            if (!transceiver) {
              throw new Error("associated RTCRtpTransceiver not found");
            }
            return transceiver.sender.getStats();
          }
          async sendDataChannel({
            ordered,
            maxPacketLifeTime,
            maxRetransmits,
            label,
            protocol,
          }) {
            this.assertNotClosed();
            this.assertSendDirection();
            const options = {
              negotiated: true,
              id: this._nextSendSctpStreamId,
              ordered,
              maxPacketLifeTime,
              maxRetransmits,
              protocol,
            };
            logger.debug("sendDataChannel() [options:%o]", options);
            const dataChannel = this._pc.createDataChannel(label, options);
            // Increase next id.
            this._nextSendSctpStreamId =
              ++this._nextSendSctpStreamId % SCTP_NUM_STREAMS.MIS;
            // If this is the first DataChannel we need to create the SDP answer with
            // m=application section.
            if (!this._hasDataChannelMediaSection) {
              const offer = await this._pc.createOffer();
              const localSdpObject = sdpTransform.parse(offer.sdp);
              const offerMediaObject = localSdpObject.media.find(
                (m) => m.type === "application"
              );
              if (!this._transportReady) {
                await this.setupTransport({
                  localDtlsRole: this._forcedLocalDtlsRole ?? "client",
                  localSdpObject,
                });
              }
              logger.debug(
                "sendDataChannel() | calling pc.setLocalDescription() [offer:%o]",
                offer
              );
              await this._pc.setLocalDescription(offer);
              this._remoteSdp.sendSctpAssociation({ offerMediaObject });
              const answer = { type: "answer", sdp: this._remoteSdp.getSdp() };
              logger.debug(
                "sendDataChannel() | calling pc.setRemoteDescription() [answer:%o]",
                answer
              );
              await this._pc.setRemoteDescription(answer);
              this._hasDataChannelMediaSection = true;
            }
            const sctpStreamParameters = {
              streamId: options.id,
              ordered: options.ordered,
              maxPacketLifeTime: options.maxPacketLifeTime,
              maxRetransmits: options.maxRetransmits,
            };
            return { dataChannel, sctpStreamParameters };
          }
          async receive(optionsList) {
            this.assertNotClosed();
            this.assertRecvDirection();
            const results = [];
            const mapLocalId = new Map();
            for (const options of optionsList) {
              const { trackId, kind, rtpParameters, streamId } = options;
              logger.debug("receive() [trackId:%s, kind:%s]", trackId, kind);
              const localId =
                rtpParameters.mid || String(this._mapMidTransceiver.size);
              mapLocalId.set(trackId, localId);
              this._remoteSdp.receive({
                mid: localId,
                kind,
                offerRtpParameters: rtpParameters,
                streamId: streamId || rtpParameters.rtcp.cname,
                trackId,
              });
            }
            const offer = { type: "offer", sdp: this._remoteSdp.getSdp() };
            logger.debug(
              "receive() | calling pc.setRemoteDescription() [offer:%o]",
              offer
            );
            await this._pc.setRemoteDescription(offer);
            let answer = await this._pc.createAnswer();
            const localSdpObject = sdpTransform.parse(answer.sdp);
            for (const options of optionsList) {
              const { trackId, rtpParameters } = options;
              const localId = mapLocalId.get(trackId);
              const answerMediaObject = localSdpObject.media.find(
                (m) => String(m.mid) === localId
              );
              // May need to modify codec parameters in the answer based on codec
              // parameters in the offer.
              sdpCommonUtils.applyCodecParameters({
                offerRtpParameters: rtpParameters,
                answerMediaObject,
              });
            }
            answer = {
              type: "answer",
              sdp: sdpTransform.write(localSdpObject),
            };
            if (!this._transportReady) {
              await this.setupTransport({
                localDtlsRole: this._forcedLocalDtlsRole ?? "client",
                localSdpObject,
              });
            }
            logger.debug(
              "receive() | calling pc.setLocalDescription() [answer:%o]",
              answer
            );
            await this._pc.setLocalDescription(answer);
            for (const options of optionsList) {
              const { trackId } = options;
              const localId = mapLocalId.get(trackId);
              const transceiver = this._pc
                .getTransceivers()
                .find((t) => t.mid === localId);
              if (!transceiver) {
                throw new Error("new RTCRtpTransceiver not found");
              } else {
                // Store in the map.
                this._mapMidTransceiver.set(localId, transceiver);
                results.push({
                  localId,
                  track: transceiver.receiver.track,
                  rtpReceiver: transceiver.receiver,
                });
              }
            }
            return results;
          }
          async stopReceiving(localIds) {
            this.assertRecvDirection();
            if (this._closed) {
              return;
            }
            for (const localId of localIds) {
              logger.debug("stopReceiving() [localId:%s]", localId);
              const transceiver = this._mapMidTransceiver.get(localId);
              if (!transceiver) {
                throw new Error("associated RTCRtpTransceiver not found");
              }
              this._remoteSdp.closeMediaSection(transceiver.mid);
            }
            const offer = { type: "offer", sdp: this._remoteSdp.getSdp() };
            logger.debug(
              "stopReceiving() | calling pc.setRemoteDescription() [offer:%o]",
              offer
            );
            await this._pc.setRemoteDescription(offer);
            const answer = await this._pc.createAnswer();
            logger.debug(
              "stopReceiving() | calling pc.setLocalDescription() [answer:%o]",
              answer
            );
            await this._pc.setLocalDescription(answer);
            for (const localId of localIds) {
              this._mapMidTransceiver.delete(localId);
            }
          }
          async pauseReceiving(localIds) {
            this.assertNotClosed();
            this.assertRecvDirection();
            for (const localId of localIds) {
              logger.debug("pauseReceiving() [localId:%s]", localId);
              const transceiver = this._mapMidTransceiver.get(localId);
              if (!transceiver) {
                throw new Error("associated RTCRtpTransceiver not found");
              }
              transceiver.direction = "inactive";
              this._remoteSdp.pauseMediaSection(localId);
            }
            const offer = { type: "offer", sdp: this._remoteSdp.getSdp() };
            logger.debug(
              "pauseReceiving() | calling pc.setRemoteDescription() [offer:%o]",
              offer
            );
            await this._pc.setRemoteDescription(offer);
            const answer = await this._pc.createAnswer();
            logger.debug(
              "pauseReceiving() | calling pc.setLocalDescription() [answer:%o]",
              answer
            );
            await this._pc.setLocalDescription(answer);
          }
          async resumeReceiving(localIds) {
            this.assertNotClosed();
            this.assertRecvDirection();
            for (const localId of localIds) {
              logger.debug("resumeReceiving() [localId:%s]", localId);
              const transceiver = this._mapMidTransceiver.get(localId);
              if (!transceiver) {
                throw new Error("associated RTCRtpTransceiver not found");
              }
              transceiver.direction = "recvonly";
              this._remoteSdp.resumeReceivingMediaSection(localId);
            }
            const offer = { type: "offer", sdp: this._remoteSdp.getSdp() };
            logger.debug(
              "resumeReceiving() | calling pc.setRemoteDescription() [offer:%o]",
              offer
            );
            await this._pc.setRemoteDescription(offer);
            const answer = await this._pc.createAnswer();
            logger.debug(
              "resumeReceiving() | calling pc.setLocalDescription() [answer:%o]",
              answer
            );
            await this._pc.setLocalDescription(answer);
          }
          async getReceiverStats(localId) {
            this.assertNotClosed();
            this.assertRecvDirection();
            const transceiver = this._mapMidTransceiver.get(localId);
            if (!transceiver) {
              throw new Error("associated RTCRtpTransceiver not found");
            }
            return transceiver.receiver.getStats();
          }
          async receiveDataChannel({ sctpStreamParameters, label, protocol }) {
            this.assertNotClosed();
            this.assertRecvDirection();
            const { streamId, ordered, maxPacketLifeTime, maxRetransmits } =
              sctpStreamParameters;
            const options = {
              negotiated: true,
              id: streamId,
              ordered,
              maxPacketLifeTime,
              maxRetransmits,
              protocol,
            };
            logger.debug("receiveDataChannel() [options:%o]", options);
            const dataChannel = this._pc.createDataChannel(label, options);
            // If this is the first DataChannel we need to create the SDP offer with
            // m=application section.
            if (!this._hasDataChannelMediaSection) {
              this._remoteSdp.receiveSctpAssociation();
              const offer = { type: "offer", sdp: this._remoteSdp.getSdp() };
              logger.debug(
                "receiveDataChannel() | calling pc.setRemoteDescription() [offer:%o]",
                offer
              );
              await this._pc.setRemoteDescription(offer);
              const answer = await this._pc.createAnswer();
              if (!this._transportReady) {
                const localSdpObject = sdpTransform.parse(answer.sdp);
                await this.setupTransport({
                  localDtlsRole: this._forcedLocalDtlsRole ?? "client",
                  localSdpObject,
                });
              }
              logger.debug(
                "receiveDataChannel() | calling pc.setRemoteDescription() [answer:%o]",
                answer
              );
              await this._pc.setLocalDescription(answer);
              this._hasDataChannelMediaSection = true;
            }
            return { dataChannel };
          }
          async setupTransport({ localDtlsRole, localSdpObject }) {
            if (!localSdpObject) {
              localSdpObject = sdpTransform.parse(
                this._pc.localDescription.sdp
              );
            }
            // Get our local DTLS parameters.
            const dtlsParameters = sdpCommonUtils.extractDtlsParameters({
              sdpObject: localSdpObject,
            });
            // Set our DTLS role.
            dtlsParameters.role = localDtlsRole;
            // Update the remote DTLS role in the SDP.
            this._remoteSdp.updateDtlsRole(
              localDtlsRole === "client" ? "server" : "client"
            );
            // Need to tell the remote transport about our parameters.
            await new Promise((resolve, reject) => {
              this.safeEmit("@connect", { dtlsParameters }, resolve, reject);
            });
            this._transportReady = true;
          }
          assertNotClosed() {
            if (this._closed) {
              throw new errors_1.InvalidStateError(
                "method called in a closed handler"
              );
            }
          }
          assertSendDirection() {
            if (this._direction !== "send") {
              throw new Error(
                'method can just be called for handlers with "send" direction'
              );
            }
          }
          assertRecvDirection() {
            if (this._direction !== "recv") {
              throw new Error(
                'method can just be called for handlers with "recv" direction'
              );
            }
          }
        }
        exports.Chrome111 = Chrome111;
      },
      {
        "../Logger": 43,
        "../errors": 48,
        "../ortc": 69,
        "../scalabilityModes": 70,
        "../utils": 72,
        "./HandlerInterface": 56,
        "./ortc/utils": 62,
        "./sdp/RemoteSdp": 64,
        "./sdp/commonUtils": 65,
        "./sdp/unifiedPlanUtils": 67,
        "sdp-transform": 79,
      },
    ],
    50: [
      function (require, module, exports) {
        "use strict";
        var __createBinding =
          (this && this.__createBinding) ||
          (Object.create
            ? function (o, m, k, k2) {
                if (k2 === undefined) k2 = k;
                var desc = Object.getOwnPropertyDescriptor(m, k);
                if (
                  !desc ||
                  ("get" in desc
                    ? !m.__esModule
                    : desc.writable || desc.configurable)
                ) {
                  desc = {
                    enumerable: true,
                    get: function () {
                      return m[k];
                    },
                  };
                }
                Object.defineProperty(o, k2, desc);
              }
            : function (o, m, k, k2) {
                if (k2 === undefined) k2 = k;
                o[k2] = m[k];
              });
        var __setModuleDefault =
          (this && this.__setModuleDefault) ||
          (Object.create
            ? function (o, v) {
                Object.defineProperty(o, "default", {
                  enumerable: true,
                  value: v,
                });
              }
            : function (o, v) {
                o["default"] = v;
              });
        var __importStar =
          (this && this.__importStar) ||
          function (mod) {
            if (mod && mod.__esModule) return mod;
            var result = {};
            if (mod != null)
              for (var k in mod)
                if (
                  k !== "default" &&
                  Object.prototype.hasOwnProperty.call(mod, k)
                )
                  __createBinding(result, mod, k);
            __setModuleDefault(result, mod);
            return result;
          };
        Object.defineProperty(exports, "__esModule", { value: true });
        exports.Chrome55 = void 0;
        const sdpTransform = __importStar(require("sdp-transform"));
        const Logger_1 = require("../Logger");
        const errors_1 = require("../errors");
        const utils = __importStar(require("../utils"));
        const ortc = __importStar(require("../ortc"));
        const sdpCommonUtils = __importStar(require("./sdp/commonUtils"));
        const sdpPlanBUtils = __importStar(require("./sdp/planBUtils"));
        const HandlerInterface_1 = require("./HandlerInterface");
        const RemoteSdp_1 = require("./sdp/RemoteSdp");
        const logger = new Logger_1.Logger("Chrome55");
        const SCTP_NUM_STREAMS = { OS: 1024, MIS: 1024 };
        class Chrome55 extends HandlerInterface_1.HandlerInterface {
          /**
           * Creates a factory function.
           */
          static createFactory() {
            return () => new Chrome55();
          }
          constructor() {
            super();
            // Local stream for sending.
            this._sendStream = new MediaStream();
            // Map of sending MediaStreamTracks indexed by localId.
            this._mapSendLocalIdTrack = new Map();
            // Next sending localId.
            this._nextSendLocalId = 0;
            // Map of MID, RTP parameters and RTCRtpReceiver indexed by local id.
            // Value is an Object with mid, rtpParameters and rtpReceiver.
            this._mapRecvLocalIdInfo = new Map();
            // Whether a DataChannel m=application section has been created.
            this._hasDataChannelMediaSection = false;
            // Sending DataChannel id value counter. Incremented for each new DataChannel.
            this._nextSendSctpStreamId = 0;
            // Got transport local and remote parameters.
            this._transportReady = false;
          }
          get name() {
            return "Chrome55";
          }
          close() {
            logger.debug("close()");
            // Close RTCPeerConnection.
            if (this._pc) {
              try {
                this._pc.close();
              } catch (error) {}
            }
            this.emit("@close");
          }
          async getNativeRtpCapabilities() {
            logger.debug("getNativeRtpCapabilities()");
            const pc = new RTCPeerConnection({
              iceServers: [],
              iceTransportPolicy: "all",
              bundlePolicy: "max-bundle",
              rtcpMuxPolicy: "require",
              sdpSemantics: "plan-b",
            });
            try {
              const offer = await pc.createOffer({
                offerToReceiveAudio: true,
                offerToReceiveVideo: true,
              });
              try {
                pc.close();
              } catch (error) {}
              const sdpObject = sdpTransform.parse(offer.sdp);
              const nativeRtpCapabilities =
                sdpCommonUtils.extractRtpCapabilities({
                  sdpObject,
                });
              return nativeRtpCapabilities;
            } catch (error) {
              try {
                pc.close();
              } catch (error2) {}
              throw error;
            }
          }
          async getNativeSctpCapabilities() {
            logger.debug("getNativeSctpCapabilities()");
            return {
              numStreams: SCTP_NUM_STREAMS,
            };
          }
          run({
            direction,
            iceParameters,
            iceCandidates,
            dtlsParameters,
            sctpParameters,
            iceServers,
            iceTransportPolicy,
            additionalSettings,
            proprietaryConstraints,
            extendedRtpCapabilities,
          }) {
            logger.debug("run()");
            this._direction = direction;
            this._remoteSdp = new RemoteSdp_1.RemoteSdp({
              iceParameters,
              iceCandidates,
              dtlsParameters,
              sctpParameters,
              planB: true,
            });
            this._sendingRtpParametersByKind = {
              audio: ortc.getSendingRtpParameters(
                "audio",
                extendedRtpCapabilities
              ),
              video: ortc.getSendingRtpParameters(
                "video",
                extendedRtpCapabilities
              ),
            };
            this._sendingRemoteRtpParametersByKind = {
              audio: ortc.getSendingRemoteRtpParameters(
                "audio",
                extendedRtpCapabilities
              ),
              video: ortc.getSendingRemoteRtpParameters(
                "video",
                extendedRtpCapabilities
              ),
            };
            if (dtlsParameters.role && dtlsParameters.role !== "auto") {
              this._forcedLocalDtlsRole =
                dtlsParameters.role === "server" ? "client" : "server";
            }
            this._pc = new RTCPeerConnection(
              {
                iceServers: iceServers || [],
                iceTransportPolicy: iceTransportPolicy || "all",
                bundlePolicy: "max-bundle",
                rtcpMuxPolicy: "require",
                sdpSemantics: "plan-b",
                ...additionalSettings,
              },
              proprietaryConstraints
            );
            this._pc.addEventListener("icegatheringstatechange", () => {
              this.emit("@icegatheringstatechange", this._pc.iceGatheringState);
            });
            if (this._pc.connectionState) {
              this._pc.addEventListener("connectionstatechange", () => {
                this.emit("@connectionstatechange", this._pc.connectionState);
              });
            } else {
              this._pc.addEventListener("iceconnectionstatechange", () => {
                logger.warn(
                  "run() | pc.connectionState not supported, using pc.iceConnectionState"
                );
                switch (this._pc.iceConnectionState) {
                  case "checking": {
                    this.emit("@connectionstatechange", "connecting");
                    break;
                  }
                  case "connected":
                  case "completed": {
                    this.emit("@connectionstatechange", "connected");
                    break;
                  }
                  case "failed": {
                    this.emit("@connectionstatechange", "failed");
                    break;
                  }
                  case "disconnected": {
                    this.emit("@connectionstatechange", "disconnected");
                    break;
                  }
                  case "closed": {
                    this.emit("@connectionstatechange", "closed");
                    break;
                  }
                }
              });
            }
          }
          async updateIceServers(iceServers) {
            logger.debug("updateIceServers()");
            const configuration = this._pc.getConfiguration();
            configuration.iceServers = iceServers;
            this._pc.setConfiguration(configuration);
          }
          async restartIce(iceParameters) {
            logger.debug("restartIce()");
            // Provide the remote SDP handler with new remote ICE parameters.
            this._remoteSdp.updateIceParameters(iceParameters);
            if (!this._transportReady) {
              return;
            }
            if (this._direction === "send") {
              const offer = await this._pc.createOffer({ iceRestart: true });
              logger.debug(
                "restartIce() | calling pc.setLocalDescription() [offer:%o]",
                offer
              );
              await this._pc.setLocalDescription(offer);
              const answer = { type: "answer", sdp: this._remoteSdp.getSdp() };
              logger.debug(
                "restartIce() | calling pc.setRemoteDescription() [answer:%o]",
                answer
              );
              await this._pc.setRemoteDescription(answer);
            } else {
              const offer = { type: "offer", sdp: this._remoteSdp.getSdp() };
              logger.debug(
                "restartIce() | calling pc.setRemoteDescription() [offer:%o]",
                offer
              );
              await this._pc.setRemoteDescription(offer);
              const answer = await this._pc.createAnswer();
              logger.debug(
                "restartIce() | calling pc.setLocalDescription() [answer:%o]",
                answer
              );
              await this._pc.setLocalDescription(answer);
            }
          }
          async getTransportStats() {
            return this._pc.getStats();
          }
          async send({ track, encodings, codecOptions, codec }) {
            this.assertSendDirection();
            logger.debug("send() [kind:%s, track.id:%s]", track.kind, track.id);
            if (codec) {
              logger.warn(
                "send() | codec selection is not available in %s handler",
                this.name
              );
            }
            this._sendStream.addTrack(track);
            this._pc.addStream(this._sendStream);
            let offer = await this._pc.createOffer();
            let localSdpObject = sdpTransform.parse(offer.sdp);
            let offerMediaObject;
            const sendingRtpParameters = utils.clone(
              this._sendingRtpParametersByKind[track.kind]
            );
            sendingRtpParameters.codecs = ortc.reduceCodecs(
              sendingRtpParameters.codecs
            );
            const sendingRemoteRtpParameters = utils.clone(
              this._sendingRemoteRtpParametersByKind[track.kind]
            );
            sendingRemoteRtpParameters.codecs = ortc.reduceCodecs(
              sendingRemoteRtpParameters.codecs
            );
            if (!this._transportReady) {
              await this.setupTransport({
                localDtlsRole: this._forcedLocalDtlsRole ?? "client",
                localSdpObject,
              });
            }
            if (track.kind === "video" && encodings && encodings.length > 1) {
              logger.debug("send() | enabling simulcast");
              localSdpObject = sdpTransform.parse(offer.sdp);
              offerMediaObject = localSdpObject.media.find(
                (m) => m.type === "video"
              );
              sdpPlanBUtils.addLegacySimulcast({
                offerMediaObject,
                track,
                numStreams: encodings.length,
              });
              offer = {
                type: "offer",
                sdp: sdpTransform.write(localSdpObject),
              };
            }
            logger.debug(
              "send() | calling pc.setLocalDescription() [offer:%o]",
              offer
            );
            await this._pc.setLocalDescription(offer);
            localSdpObject = sdpTransform.parse(this._pc.localDescription.sdp);
            offerMediaObject = localSdpObject.media.find(
              (m) => m.type === track.kind
            );
            // Set RTCP CNAME.
            sendingRtpParameters.rtcp.cname = sdpCommonUtils.getCname({
              offerMediaObject,
            });
            // Set RTP encodings.
            sendingRtpParameters.encodings = sdpPlanBUtils.getRtpEncodings({
              offerMediaObject,
              track,
            });
            // Complete encodings with given values.
            if (encodings) {
              for (
                let idx = 0;
                idx < sendingRtpParameters.encodings.length;
                ++idx
              ) {
                if (encodings[idx]) {
                  Object.assign(
                    sendingRtpParameters.encodings[idx],
                    encodings[idx]
                  );
                }
              }
            }
            // If VP8 and there is effective simulcast, add scalabilityMode to each
            // encoding.
            if (
              sendingRtpParameters.encodings.length > 1 &&
              sendingRtpParameters.codecs[0].mimeType.toLowerCase() ===
                "video/vp8"
            ) {
              for (const encoding of sendingRtpParameters.encodings) {
                encoding.scalabilityMode = "L1T3";
              }
            }
            this._remoteSdp.send({
              offerMediaObject,
              offerRtpParameters: sendingRtpParameters,
              answerRtpParameters: sendingRemoteRtpParameters,
              codecOptions,
            });
            const answer = { type: "answer", sdp: this._remoteSdp.getSdp() };
            logger.debug(
              "send() | calling pc.setRemoteDescription() [answer:%o]",
              answer
            );
            await this._pc.setRemoteDescription(answer);
            const localId = String(this._nextSendLocalId);
            this._nextSendLocalId++;
            // Insert into the map.
            this._mapSendLocalIdTrack.set(localId, track);
            return {
              localId: localId,
              rtpParameters: sendingRtpParameters,
            };
          }
          async stopSending(localId) {
            this.assertSendDirection();
            logger.debug("stopSending() [localId:%s]", localId);
            const track = this._mapSendLocalIdTrack.get(localId);
            if (!track) {
              throw new Error("track not found");
            }
            this._mapSendLocalIdTrack.delete(localId);
            this._sendStream.removeTrack(track);
            this._pc.addStream(this._sendStream);
            const offer = await this._pc.createOffer();
            logger.debug(
              "stopSending() | calling pc.setLocalDescription() [offer:%o]",
              offer
            );
            try {
              await this._pc.setLocalDescription(offer);
            } catch (error) {
              // NOTE: If there are no sending tracks, setLocalDescription() will fail with
              // "Failed to create channels". If so, ignore it.
              if (this._sendStream.getTracks().length === 0) {
                logger.warn(
                  "stopSending() | ignoring expected error due no sending tracks: %s",
                  error.toString()
                );
                return;
              }
              throw error;
            }
            if (this._pc.signalingState === "stable") {
              return;
            }
            const answer = { type: "answer", sdp: this._remoteSdp.getSdp() };
            logger.debug(
              "stopSending() | calling pc.setRemoteDescription() [answer:%o]",
              answer
            );
            await this._pc.setRemoteDescription(answer);
          }
          // eslint-disable-next-line @typescript-eslint/no-unused-vars
          async pauseSending(localId) {
            // Unimplemented.
          }
          // eslint-disable-next-line @typescript-eslint/no-unused-vars
          async resumeSending(localId) {
            // Unimplemented.
          }
          async replaceTrack(
            // eslint-disable-next-line @typescript-eslint/no-unused-vars
            localId,
            // eslint-disable-next-line @typescript-eslint/no-unused-vars
            track
          ) {
            throw new errors_1.UnsupportedError("not implemented");
          }
          async setMaxSpatialLayer(
            // eslint-disable-next-line @typescript-eslint/no-unused-vars
            localId,
            // eslint-disable-next-line @typescript-eslint/no-unused-vars
            spatialLayer
          ) {
            throw new errors_1.UnsupportedError(" not implemented");
          }
          // eslint-disable-next-line @typescript-eslint/no-unused-vars
          async setRtpEncodingParameters(localId, params) {
            throw new errors_1.UnsupportedError("not supported");
          }
          // eslint-disable-next-line @typescript-eslint/no-unused-vars
          async getSenderStats(localId) {
            throw new errors_1.UnsupportedError("not implemented");
          }
          async sendDataChannel({
            ordered,
            maxPacketLifeTime,
            maxRetransmits,
            label,
            protocol,
          }) {
            this.assertSendDirection();
            const options = {
              negotiated: true,
              id: this._nextSendSctpStreamId,
              ordered,
              maxPacketLifeTime,
              maxRetransmitTime: maxPacketLifeTime, // NOTE: Old spec.
              maxRetransmits,
              protocol,
            };
            logger.debug("sendDataChannel() [options:%o]", options);
            const dataChannel = this._pc.createDataChannel(label, options);
            // Increase next id.
            this._nextSendSctpStreamId =
              ++this._nextSendSctpStreamId % SCTP_NUM_STREAMS.MIS;
            // If this is the first DataChannel we need to create the SDP answer with
            // m=application section.
            if (!this._hasDataChannelMediaSection) {
              const offer = await this._pc.createOffer();
              const localSdpObject = sdpTransform.parse(offer.sdp);
              const offerMediaObject = localSdpObject.media.find(
                (m) => m.type === "application"
              );
              if (!this._transportReady) {
                await this.setupTransport({
                  localDtlsRole: this._forcedLocalDtlsRole ?? "client",
                  localSdpObject,
                });
              }
              logger.debug(
                "sendDataChannel() | calling pc.setLocalDescription() [offer:%o]",
                offer
              );
              await this._pc.setLocalDescription(offer);
              this._remoteSdp.sendSctpAssociation({ offerMediaObject });
              const answer = { type: "answer", sdp: this._remoteSdp.getSdp() };
              logger.debug(
                "sendDataChannel() | calling pc.setRemoteDescription() [answer:%o]",
                answer
              );
              await this._pc.setRemoteDescription(answer);
              this._hasDataChannelMediaSection = true;
            }
            const sctpStreamParameters = {
              streamId: options.id,
              ordered: options.ordered,
              maxPacketLifeTime: options.maxPacketLifeTime,
              maxRetransmits: options.maxRetransmits,
            };
            return { dataChannel, sctpStreamParameters };
          }
          async receive(optionsList) {
            this.assertRecvDirection();
            const results = [];
            for (const options of optionsList) {
              const { trackId, kind, rtpParameters, streamId } = options;
              logger.debug("receive() [trackId:%s, kind:%s]", trackId, kind);
              const mid = kind;
              this._remoteSdp.receive({
                mid,
                kind,
                offerRtpParameters: rtpParameters,
                streamId: streamId || rtpParameters.rtcp.cname,
                trackId,
              });
            }
            const offer = { type: "offer", sdp: this._remoteSdp.getSdp() };
            logger.debug(
              "receive() | calling pc.setRemoteDescription() [offer:%o]",
              offer
            );
            await this._pc.setRemoteDescription(offer);
            let answer = await this._pc.createAnswer();
            const localSdpObject = sdpTransform.parse(answer.sdp);
            for (const options of optionsList) {
              const { kind, rtpParameters } = options;
              const mid = kind;
              const answerMediaObject = localSdpObject.media.find(
                (m) => String(m.mid) === mid
              );
              // May need to modify codec parameters in the answer based on codec
              // parameters in the offer.
              sdpCommonUtils.applyCodecParameters({
                offerRtpParameters: rtpParameters,
                answerMediaObject,
              });
            }
            answer = {
              type: "answer",
              sdp: sdpTransform.write(localSdpObject),
            };
            if (!this._transportReady) {
              await this.setupTransport({
                localDtlsRole: this._forcedLocalDtlsRole ?? "client",
                localSdpObject,
              });
            }
            logger.debug(
              "receive() | calling pc.setLocalDescription() [answer:%o]",
              answer
            );
            await this._pc.setLocalDescription(answer);
            for (const options of optionsList) {
              const { kind, trackId, rtpParameters } = options;
              const mid = kind;
              const localId = trackId;
              const streamId = options.streamId || rtpParameters.rtcp.cname;
              const stream = this._pc
                .getRemoteStreams()
                .find((s) => s.id === streamId);
              const track = stream.getTrackById(localId);
              if (!track) {
                throw new Error("remote track not found");
              }
              // Insert into the map.
              this._mapRecvLocalIdInfo.set(localId, { mid, rtpParameters });
              results.push({ localId, track });
            }
            return results;
          }
          async stopReceiving(localIds) {
            this.assertRecvDirection();
            for (const localId of localIds) {
              logger.debug("stopReceiving() [localId:%s]", localId);
              const { mid, rtpParameters } =
                this._mapRecvLocalIdInfo.get(localId) || {};
              // Remove from the map.
              this._mapRecvLocalIdInfo.delete(localId);
              this._remoteSdp.planBStopReceiving({
                mid: mid,
                offerRtpParameters: rtpParameters,
              });
            }
            const offer = { type: "offer", sdp: this._remoteSdp.getSdp() };
            logger.debug(
              "stopReceiving() | calling pc.setRemoteDescription() [offer:%o]",
              offer
            );
            await this._pc.setRemoteDescription(offer);
            const answer = await this._pc.createAnswer();
            logger.debug(
              "stopReceiving() | calling pc.setLocalDescription() [answer:%o]",
              answer
            );
            await this._pc.setLocalDescription(answer);
          }
          async pauseReceiving(
            // eslint-disable-next-line @typescript-eslint/no-unused-vars
            localIds
          ) {
            // Unimplemented.
          }
          async resumeReceiving(
            // eslint-disable-next-line @typescript-eslint/no-unused-vars
            localIds
          ) {
            // Unimplemented.
          }
          // eslint-disable-next-line @typescript-eslint/no-unused-vars
          async getReceiverStats(localId) {
            throw new errors_1.UnsupportedError("not implemented");
          }
          async receiveDataChannel({ sctpStreamParameters, label, protocol }) {
            this.assertRecvDirection();
            const { streamId, ordered, maxPacketLifeTime, maxRetransmits } =
              sctpStreamParameters;
            const options = {
              negotiated: true,
              id: streamId,
              ordered,
              maxPacketLifeTime,
              maxRetransmitTime: maxPacketLifeTime, // NOTE: Old spec.
              maxRetransmits,
              protocol,
            };
            logger.debug("receiveDataChannel() [options:%o]", options);
            const dataChannel = this._pc.createDataChannel(label, options);
            // If this is the first DataChannel we need to create the SDP offer with
            // m=application section.
            if (!this._hasDataChannelMediaSection) {
              this._remoteSdp.receiveSctpAssociation({
                oldDataChannelSpec: true,
              });
              const offer = { type: "offer", sdp: this._remoteSdp.getSdp() };
              logger.debug(
                "receiveDataChannel() | calling pc.setRemoteDescription() [offer:%o]",
                offer
              );
              await this._pc.setRemoteDescription(offer);
              const answer = await this._pc.createAnswer();
              if (!this._transportReady) {
                const localSdpObject = sdpTransform.parse(answer.sdp);
                await this.setupTransport({
                  localDtlsRole: this._forcedLocalDtlsRole ?? "client",
                  localSdpObject,
                });
              }
              logger.debug(
                "receiveDataChannel() | calling pc.setRemoteDescription() [answer:%o]",
                answer
              );
              await this._pc.setLocalDescription(answer);
              this._hasDataChannelMediaSection = true;
            }
            return { dataChannel };
          }
          async setupTransport({ localDtlsRole, localSdpObject }) {
            if (!localSdpObject) {
              localSdpObject = sdpTransform.parse(
                this._pc.localDescription.sdp
              );
            }
            // Get our local DTLS parameters.
            const dtlsParameters = sdpCommonUtils.extractDtlsParameters({
              sdpObject: localSdpObject,
            });
            // Set our DTLS role.
            dtlsParameters.role = localDtlsRole;
            // Update the remote DTLS role in the SDP.
            this._remoteSdp.updateDtlsRole(
              localDtlsRole === "client" ? "server" : "client"
            );
            // Need to tell the remote transport about our parameters.
            await new Promise((resolve, reject) => {
              this.safeEmit("@connect", { dtlsParameters }, resolve, reject);
            });
            this._transportReady = true;
          }
          assertSendDirection() {
            if (this._direction !== "send") {
              throw new Error(
                'method can just be called for handlers with "send" direction'
              );
            }
          }
          assertRecvDirection() {
            if (this._direction !== "recv") {
              throw new Error(
                'method can just be called for handlers with "recv" direction'
              );
            }
          }
        }
        exports.Chrome55 = Chrome55;
      },
      {
        "../Logger": 43,
        "../errors": 48,
        "../ortc": 69,
        "../utils": 72,
        "./HandlerInterface": 56,
        "./sdp/RemoteSdp": 64,
        "./sdp/commonUtils": 65,
        "./sdp/planBUtils": 66,
        "sdp-transform": 79,
      },
    ],
    51: [
      function (require, module, exports) {
        "use strict";
        var __createBinding =
          (this && this.__createBinding) ||
          (Object.create
            ? function (o, m, k, k2) {
                if (k2 === undefined) k2 = k;
                var desc = Object.getOwnPropertyDescriptor(m, k);
                if (
                  !desc ||
                  ("get" in desc
                    ? !m.__esModule
                    : desc.writable || desc.configurable)
                ) {
                  desc = {
                    enumerable: true,
                    get: function () {
                      return m[k];
                    },
                  };
                }
                Object.defineProperty(o, k2, desc);
              }
            : function (o, m, k, k2) {
                if (k2 === undefined) k2 = k;
                o[k2] = m[k];
              });
        var __setModuleDefault =
          (this && this.__setModuleDefault) ||
          (Object.create
            ? function (o, v) {
                Object.defineProperty(o, "default", {
                  enumerable: true,
                  value: v,
                });
              }
            : function (o, v) {
                o["default"] = v;
              });
        var __importStar =
          (this && this.__importStar) ||
          function (mod) {
            if (mod && mod.__esModule) return mod;
            var result = {};
            if (mod != null)
              for (var k in mod)
                if (
                  k !== "default" &&
                  Object.prototype.hasOwnProperty.call(mod, k)
                )
                  __createBinding(result, mod, k);
            __setModuleDefault(result, mod);
            return result;
          };
        Object.defineProperty(exports, "__esModule", { value: true });
        exports.Chrome67 = void 0;
        const sdpTransform = __importStar(require("sdp-transform"));
        const Logger_1 = require("../Logger");
        const utils = __importStar(require("../utils"));
        const ortc = __importStar(require("../ortc"));
        const sdpCommonUtils = __importStar(require("./sdp/commonUtils"));
        const sdpPlanBUtils = __importStar(require("./sdp/planBUtils"));
        const HandlerInterface_1 = require("./HandlerInterface");
        const RemoteSdp_1 = require("./sdp/RemoteSdp");
        const logger = new Logger_1.Logger("Chrome67");
        const SCTP_NUM_STREAMS = { OS: 1024, MIS: 1024 };
        class Chrome67 extends HandlerInterface_1.HandlerInterface {
          /**
           * Creates a factory function.
           */
          static createFactory() {
            return () => new Chrome67();
          }
          constructor() {
            super();
            // Local stream for sending.
            this._sendStream = new MediaStream();
            // Map of RTCRtpSender indexed by localId.
            this._mapSendLocalIdRtpSender = new Map();
            // Next sending localId.
            this._nextSendLocalId = 0;
            // Map of MID, RTP parameters and RTCRtpReceiver indexed by local id.
            // Value is an Object with mid, rtpParameters and rtpReceiver.
            this._mapRecvLocalIdInfo = new Map();
            // Whether a DataChannel m=application section has been created.
            this._hasDataChannelMediaSection = false;
            // Sending DataChannel id value counter. Incremented for each new DataChannel.
            this._nextSendSctpStreamId = 0;
            // Got transport local and remote parameters.
            this._transportReady = false;
          }
          get name() {
            return "Chrome67";
          }
          close() {
            logger.debug("close()");
            // Close RTCPeerConnection.
            if (this._pc) {
              try {
                this._pc.close();
              } catch (error) {}
            }
            this.emit("@close");
          }
          async getNativeRtpCapabilities() {
            logger.debug("getNativeRtpCapabilities()");
            const pc = new RTCPeerConnection({
              iceServers: [],
              iceTransportPolicy: "all",
              bundlePolicy: "max-bundle",
              rtcpMuxPolicy: "require",
              sdpSemantics: "plan-b",
            });
            try {
              const offer = await pc.createOffer({
                offerToReceiveAudio: true,
                offerToReceiveVideo: true,
              });
              try {
                pc.close();
              } catch (error) {}
              const sdpObject = sdpTransform.parse(offer.sdp);
              const nativeRtpCapabilities =
                sdpCommonUtils.extractRtpCapabilities({
                  sdpObject,
                });
              return nativeRtpCapabilities;
            } catch (error) {
              try {
                pc.close();
              } catch (error2) {}
              throw error;
            }
          }
          async getNativeSctpCapabilities() {
            logger.debug("getNativeSctpCapabilities()");
            return {
              numStreams: SCTP_NUM_STREAMS,
            };
          }
          run({
            direction,
            iceParameters,
            iceCandidates,
            dtlsParameters,
            sctpParameters,
            iceServers,
            iceTransportPolicy,
            additionalSettings,
            proprietaryConstraints,
            extendedRtpCapabilities,
          }) {
            logger.debug("run()");
            this._direction = direction;
            this._remoteSdp = new RemoteSdp_1.RemoteSdp({
              iceParameters,
              iceCandidates,
              dtlsParameters,
              sctpParameters,
              planB: true,
            });
            this._sendingRtpParametersByKind = {
              audio: ortc.getSendingRtpParameters(
                "audio",
                extendedRtpCapabilities
              ),
              video: ortc.getSendingRtpParameters(
                "video",
                extendedRtpCapabilities
              ),
            };
            this._sendingRemoteRtpParametersByKind = {
              audio: ortc.getSendingRemoteRtpParameters(
                "audio",
                extendedRtpCapabilities
              ),
              video: ortc.getSendingRemoteRtpParameters(
                "video",
                extendedRtpCapabilities
              ),
            };
            if (dtlsParameters.role && dtlsParameters.role !== "auto") {
              this._forcedLocalDtlsRole =
                dtlsParameters.role === "server" ? "client" : "server";
            }
            this._pc = new RTCPeerConnection(
              {
                iceServers: iceServers || [],
                iceTransportPolicy: iceTransportPolicy || "all",
                bundlePolicy: "max-bundle",
                rtcpMuxPolicy: "require",
                sdpSemantics: "plan-b",
                ...additionalSettings,
              },
              proprietaryConstraints
            );
            this._pc.addEventListener("icegatheringstatechange", () => {
              this.emit("@icegatheringstatechange", this._pc.iceGatheringState);
            });
            if (this._pc.connectionState) {
              this._pc.addEventListener("connectionstatechange", () => {
                this.emit("@connectionstatechange", this._pc.connectionState);
              });
            } else {
              this._pc.addEventListener("iceconnectionstatechange", () => {
                logger.warn(
                  "run() | pc.connectionState not supported, using pc.iceConnectionState"
                );
                switch (this._pc.iceConnectionState) {
                  case "checking": {
                    this.emit("@connectionstatechange", "connecting");
                    break;
                  }
                  case "connected":
                  case "completed": {
                    this.emit("@connectionstatechange", "connected");
                    break;
                  }
                  case "failed": {
                    this.emit("@connectionstatechange", "failed");
                    break;
                  }
                  case "disconnected": {
                    this.emit("@connectionstatechange", "disconnected");
                    break;
                  }
                  case "closed": {
                    this.emit("@connectionstatechange", "closed");
                    break;
                  }
                }
              });
            }
          }
          async updateIceServers(iceServers) {
            logger.debug("updateIceServers()");
            const configuration = this._pc.getConfiguration();
            configuration.iceServers = iceServers;
            this._pc.setConfiguration(configuration);
          }
          async restartIce(iceParameters) {
            logger.debug("restartIce()");
            // Provide the remote SDP handler with new remote ICE parameters.
            this._remoteSdp.updateIceParameters(iceParameters);
            if (!this._transportReady) {
              return;
            }
            if (this._direction === "send") {
              const offer = await this._pc.createOffer({ iceRestart: true });
              logger.debug(
                "restartIce() | calling pc.setLocalDescription() [offer:%o]",
                offer
              );
              await this._pc.setLocalDescription(offer);
              const answer = { type: "answer", sdp: this._remoteSdp.getSdp() };
              logger.debug(
                "restartIce() | calling pc.setRemoteDescription() [answer:%o]",
                answer
              );
              await this._pc.setRemoteDescription(answer);
            } else {
              const offer = { type: "offer", sdp: this._remoteSdp.getSdp() };
              logger.debug(
                "restartIce() | calling pc.setRemoteDescription() [offer:%o]",
                offer
              );
              await this._pc.setRemoteDescription(offer);
              const answer = await this._pc.createAnswer();
              logger.debug(
                "restartIce() | calling pc.setLocalDescription() [answer:%o]",
                answer
              );
              await this._pc.setLocalDescription(answer);
            }
          }
          async getTransportStats() {
            return this._pc.getStats();
          }
          async send({ track, encodings, codecOptions, codec }) {
            this.assertSendDirection();
            logger.debug("send() [kind:%s, track.id:%s]", track.kind, track.id);
            if (codec) {
              logger.warn(
                "send() | codec selection is not available in %s handler",
                this.name
              );
            }
            this._sendStream.addTrack(track);
            this._pc.addTrack(track, this._sendStream);
            let offer = await this._pc.createOffer();
            let localSdpObject = sdpTransform.parse(offer.sdp);
            let offerMediaObject;
            const sendingRtpParameters = utils.clone(
              this._sendingRtpParametersByKind[track.kind]
            );
            sendingRtpParameters.codecs = ortc.reduceCodecs(
              sendingRtpParameters.codecs
            );
            const sendingRemoteRtpParameters = utils.clone(
              this._sendingRemoteRtpParametersByKind[track.kind]
            );
            sendingRemoteRtpParameters.codecs = ortc.reduceCodecs(
              sendingRemoteRtpParameters.codecs
            );
            if (!this._transportReady) {
              await this.setupTransport({
                localDtlsRole: this._forcedLocalDtlsRole ?? "client",
                localSdpObject,
              });
            }
            if (track.kind === "video" && encodings && encodings.length > 1) {
              logger.debug("send() | enabling simulcast");
              localSdpObject = sdpTransform.parse(offer.sdp);
              offerMediaObject = localSdpObject.media.find(
                (m) => m.type === "video"
              );
              sdpPlanBUtils.addLegacySimulcast({
                offerMediaObject,
                track,
                numStreams: encodings.length,
              });
              offer = {
                type: "offer",
                sdp: sdpTransform.write(localSdpObject),
              };
            }
            logger.debug(
              "send() | calling pc.setLocalDescription() [offer:%o]",
              offer
            );
            await this._pc.setLocalDescription(offer);
            localSdpObject = sdpTransform.parse(this._pc.localDescription.sdp);
            offerMediaObject = localSdpObject.media.find(
              (m) => m.type === track.kind
            );
            // Set RTCP CNAME.
            sendingRtpParameters.rtcp.cname = sdpCommonUtils.getCname({
              offerMediaObject,
            });
            // Set RTP encodings.
            sendingRtpParameters.encodings = sdpPlanBUtils.getRtpEncodings({
              offerMediaObject,
              track,
            });
            // Complete encodings with given values.
            if (encodings) {
              for (
                let idx = 0;
                idx < sendingRtpParameters.encodings.length;
                ++idx
              ) {
                if (encodings[idx]) {
                  Object.assign(
                    sendingRtpParameters.encodings[idx],
                    encodings[idx]
                  );
                }
              }
            }
            // If VP8 and there is effective simulcast, add scalabilityMode to each
            // encoding.
            if (
              sendingRtpParameters.encodings.length > 1 &&
              sendingRtpParameters.codecs[0].mimeType.toLowerCase() ===
                "video/vp8"
            ) {
              for (const encoding of sendingRtpParameters.encodings) {
                encoding.scalabilityMode = "L1T3";
              }
            }
            this._remoteSdp.send({
              offerMediaObject,
              offerRtpParameters: sendingRtpParameters,
              answerRtpParameters: sendingRemoteRtpParameters,
              codecOptions,
            });
            const answer = { type: "answer", sdp: this._remoteSdp.getSdp() };
            logger.debug(
              "send() | calling pc.setRemoteDescription() [answer:%o]",
              answer
            );
            await this._pc.setRemoteDescription(answer);
            const localId = String(this._nextSendLocalId);
            this._nextSendLocalId++;
            const rtpSender = this._pc
              .getSenders()
              .find((s) => s.track === track);
            // Insert into the map.
            this._mapSendLocalIdRtpSender.set(localId, rtpSender);
            return {
              localId: localId,
              rtpParameters: sendingRtpParameters,
              rtpSender,
            };
          }
          async stopSending(localId) {
            this.assertSendDirection();
            logger.debug("stopSending() [localId:%s]", localId);
            const rtpSender = this._mapSendLocalIdRtpSender.get(localId);
            if (!rtpSender) {
              throw new Error("associated RTCRtpSender not found");
            }
            this._pc.removeTrack(rtpSender);
            if (rtpSender.track) {
              this._sendStream.removeTrack(rtpSender.track);
            }
            this._mapSendLocalIdRtpSender.delete(localId);
            const offer = await this._pc.createOffer();
            logger.debug(
              "stopSending() | calling pc.setLocalDescription() [offer:%o]",
              offer
            );
            try {
              await this._pc.setLocalDescription(offer);
            } catch (error) {
              // NOTE: If there are no sending tracks, setLocalDescription() will fail with
              // "Failed to create channels". If so, ignore it.
              if (this._sendStream.getTracks().length === 0) {
                logger.warn(
                  "stopSending() | ignoring expected error due no sending tracks: %s",
                  error.toString()
                );
                return;
              }
              throw error;
            }
            if (this._pc.signalingState === "stable") {
              return;
            }
            const answer = { type: "answer", sdp: this._remoteSdp.getSdp() };
            logger.debug(
              "stopSending() | calling pc.setRemoteDescription() [answer:%o]",
              answer
            );
            await this._pc.setRemoteDescription(answer);
          }
          // eslint-disable-next-line @typescript-eslint/no-unused-vars
          async pauseSending(localId) {
            // Unimplemented.
          }
          // eslint-disable-next-line @typescript-eslint/no-unused-vars
          async resumeSending(localId) {
            // Unimplemented.
          }
          async replaceTrack(localId, track) {
            this.assertSendDirection();
            if (track) {
              logger.debug(
                "replaceTrack() [localId:%s, track.id:%s]",
                localId,
                track.id
              );
            } else {
              logger.debug("replaceTrack() [localId:%s, no track]", localId);
            }
            const rtpSender = this._mapSendLocalIdRtpSender.get(localId);
            if (!rtpSender) {
              throw new Error("associated RTCRtpSender not found");
            }
            const oldTrack = rtpSender.track;
            await rtpSender.replaceTrack(track);
            // Remove the old track from the local stream.
            if (oldTrack) {
              this._sendStream.removeTrack(oldTrack);
            }
            // Add the new track to the local stream.
            if (track) {
              this._sendStream.addTrack(track);
            }
          }
          async setMaxSpatialLayer(localId, spatialLayer) {
            this.assertSendDirection();
            logger.debug(
              "setMaxSpatialLayer() [localId:%s, spatialLayer:%s]",
              localId,
              spatialLayer
            );
            const rtpSender = this._mapSendLocalIdRtpSender.get(localId);
            if (!rtpSender) {
              throw new Error("associated RTCRtpSender not found");
            }
            const parameters = rtpSender.getParameters();
            parameters.encodings.forEach((encoding, idx) => {
              if (idx <= spatialLayer) {
                encoding.active = true;
              } else {
                encoding.active = false;
              }
            });
            await rtpSender.setParameters(parameters);
          }
          async setRtpEncodingParameters(localId, params) {
            this.assertSendDirection();
            logger.debug(
              "setRtpEncodingParameters() [localId:%s, params:%o]",
              localId,
              params
            );
            const rtpSender = this._mapSendLocalIdRtpSender.get(localId);
            if (!rtpSender) {
              throw new Error("associated RTCRtpSender not found");
            }
            const parameters = rtpSender.getParameters();
            parameters.encodings.forEach((encoding, idx) => {
              parameters.encodings[idx] = { ...encoding, ...params };
            });
            await rtpSender.setParameters(parameters);
          }
          async getSenderStats(localId) {
            this.assertSendDirection();
            const rtpSender = this._mapSendLocalIdRtpSender.get(localId);
            if (!rtpSender) {
              throw new Error("associated RTCRtpSender not found");
            }
            return rtpSender.getStats();
          }
          async sendDataChannel({
            ordered,
            maxPacketLifeTime,
            maxRetransmits,
            label,
            protocol,
          }) {
            this.assertSendDirection();
            const options = {
              negotiated: true,
              id: this._nextSendSctpStreamId,
              ordered,
              maxPacketLifeTime,
              maxRetransmitTime: maxPacketLifeTime, // NOTE: Old spec.
              maxRetransmits,
              protocol,
            };
            logger.debug("sendDataChannel() [options:%o]", options);
            const dataChannel = this._pc.createDataChannel(label, options);
            // Increase next id.
            this._nextSendSctpStreamId =
              ++this._nextSendSctpStreamId % SCTP_NUM_STREAMS.MIS;
            // If this is the first DataChannel we need to create the SDP answer with
            // m=application section.
            if (!this._hasDataChannelMediaSection) {
              const offer = await this._pc.createOffer();
              const localSdpObject = sdpTransform.parse(offer.sdp);
              const offerMediaObject = localSdpObject.media.find(
                (m) => m.type === "application"
              );
              if (!this._transportReady) {
                await this.setupTransport({
                  localDtlsRole: this._forcedLocalDtlsRole ?? "client",
                  localSdpObject,
                });
              }
              logger.debug(
                "sendDataChannel() | calling pc.setLocalDescription() [offer:%o]",
                offer
              );
              await this._pc.setLocalDescription(offer);
              this._remoteSdp.sendSctpAssociation({ offerMediaObject });
              const answer = { type: "answer", sdp: this._remoteSdp.getSdp() };
              logger.debug(
                "sendDataChannel() | calling pc.setRemoteDescription() [answer:%o]",
                answer
              );
              await this._pc.setRemoteDescription(answer);
              this._hasDataChannelMediaSection = true;
            }
            const sctpStreamParameters = {
              streamId: options.id,
              ordered: options.ordered,
              maxPacketLifeTime: options.maxPacketLifeTime,
              maxRetransmits: options.maxRetransmits,
            };
            return { dataChannel, sctpStreamParameters };
          }
          async receive(optionsList) {
            this.assertRecvDirection();
            const results = [];
            for (const options of optionsList) {
              const { trackId, kind, rtpParameters, streamId } = options;
              logger.debug("receive() [trackId:%s, kind:%s]", trackId, kind);
              const mid = kind;
              this._remoteSdp.receive({
                mid,
                kind,
                offerRtpParameters: rtpParameters,
                streamId: streamId || rtpParameters.rtcp.cname,
                trackId,
              });
            }
            const offer = { type: "offer", sdp: this._remoteSdp.getSdp() };
            logger.debug(
              "receive() | calling pc.setRemoteDescription() [offer:%o]",
              offer
            );
            await this._pc.setRemoteDescription(offer);
            let answer = await this._pc.createAnswer();
            const localSdpObject = sdpTransform.parse(answer.sdp);
            for (const options of optionsList) {
              const { kind, rtpParameters } = options;
              const mid = kind;
              const answerMediaObject = localSdpObject.media.find(
                (m) => String(m.mid) === mid
              );
              // May need to modify codec parameters in the answer based on codec
              // parameters in the offer.
              sdpCommonUtils.applyCodecParameters({
                offerRtpParameters: rtpParameters,
                answerMediaObject,
              });
            }
            answer = {
              type: "answer",
              sdp: sdpTransform.write(localSdpObject),
            };
            if (!this._transportReady) {
              await this.setupTransport({
                localDtlsRole: this._forcedLocalDtlsRole ?? "client",
                localSdpObject,
              });
            }
            logger.debug(
              "receive() | calling pc.setLocalDescription() [answer:%o]",
              answer
            );
            await this._pc.setLocalDescription(answer);
            for (const options of optionsList) {
              const { kind, trackId, rtpParameters } = options;
              const localId = trackId;
              const mid = kind;
              const rtpReceiver = this._pc
                .getReceivers()
                .find((r) => r.track && r.track.id === localId);
              if (!rtpReceiver) {
                throw new Error("new RTCRtpReceiver not");
              }
              // Insert into the map.
              this._mapRecvLocalIdInfo.set(localId, {
                mid,
                rtpParameters,
                rtpReceiver,
              });
              results.push({
                localId,
                track: rtpReceiver.track,
                rtpReceiver,
              });
            }
            return results;
          }
          async stopReceiving(localIds) {
            this.assertRecvDirection();
            for (const localId of localIds) {
              logger.debug("stopReceiving() [localId:%s]", localId);
              const { mid, rtpParameters } =
                this._mapRecvLocalIdInfo.get(localId) || {};
              // Remove from the map.
              this._mapRecvLocalIdInfo.delete(localId);
              this._remoteSdp.planBStopReceiving({
                mid: mid,
                offerRtpParameters: rtpParameters,
              });
            }
            const offer = { type: "offer", sdp: this._remoteSdp.getSdp() };
            logger.debug(
              "stopReceiving() | calling pc.setRemoteDescription() [offer:%o]",
              offer
            );
            await this._pc.setRemoteDescription(offer);
            const answer = await this._pc.createAnswer();
            logger.debug(
              "stopReceiving() | calling pc.setLocalDescription() [answer:%o]",
              answer
            );
            await this._pc.setLocalDescription(answer);
          }
          async pauseReceiving(
            // eslint-disable-next-line @typescript-eslint/no-unused-vars
            localIds
          ) {
            // Unimplemented.
          }
          async resumeReceiving(
            // eslint-disable-next-line @typescript-eslint/no-unused-vars
            localIds
          ) {
            // Unimplemented.
          }
          async getReceiverStats(localId) {
            this.assertRecvDirection();
            const { rtpReceiver } = this._mapRecvLocalIdInfo.get(localId) || {};
            if (!rtpReceiver) {
              throw new Error("associated RTCRtpReceiver not found");
            }
            return rtpReceiver.getStats();
          }
          async receiveDataChannel({ sctpStreamParameters, label, protocol }) {
            this.assertRecvDirection();
            const { streamId, ordered, maxPacketLifeTime, maxRetransmits } =
              sctpStreamParameters;
            const options = {
              negotiated: true,
              id: streamId,
              ordered,
              maxPacketLifeTime,
              maxRetransmitTime: maxPacketLifeTime, // NOTE: Old spec.
              maxRetransmits,
              protocol,
            };
            logger.debug("receiveDataChannel() [options:%o]", options);
            const dataChannel = this._pc.createDataChannel(label, options);
            // If this is the first DataChannel we need to create the SDP offer with
            // m=application section.
            if (!this._hasDataChannelMediaSection) {
              this._remoteSdp.receiveSctpAssociation({
                oldDataChannelSpec: true,
              });
              const offer = { type: "offer", sdp: this._remoteSdp.getSdp() };
              logger.debug(
                "receiveDataChannel() | calling pc.setRemoteDescription() [offer:%o]",
                offer
              );
              await this._pc.setRemoteDescription(offer);
              const answer = await this._pc.createAnswer();
              if (!this._transportReady) {
                const localSdpObject = sdpTransform.parse(answer.sdp);
                await this.setupTransport({
                  localDtlsRole: this._forcedLocalDtlsRole ?? "client",
                  localSdpObject,
                });
              }
              logger.debug(
                "receiveDataChannel() | calling pc.setRemoteDescription() [answer:%o]",
                answer
              );
              await this._pc.setLocalDescription(answer);
              this._hasDataChannelMediaSection = true;
            }
            return { dataChannel };
          }
          async setupTransport({ localDtlsRole, localSdpObject }) {
            if (!localSdpObject) {
              localSdpObject = sdpTransform.parse(
                this._pc.localDescription.sdp
              );
            }
            // Get our local DTLS parameters.
            const dtlsParameters = sdpCommonUtils.extractDtlsParameters({
              sdpObject: localSdpObject,
            });
            // Set our DTLS role.
            dtlsParameters.role = localDtlsRole;
            // Update the remote DTLS role in the SDP.
            this._remoteSdp.updateDtlsRole(
              localDtlsRole === "client" ? "server" : "client"
            );
            // Need to tell the remote transport about our parameters.
            await new Promise((resolve, reject) => {
              this.safeEmit("@connect", { dtlsParameters }, resolve, reject);
            });
            this._transportReady = true;
          }
          assertSendDirection() {
            if (this._direction !== "send") {
              throw new Error(
                'method can just be called for handlers with "send" direction'
              );
            }
          }
          assertRecvDirection() {
            if (this._direction !== "recv") {
              throw new Error(
                'method can just be called for handlers with "recv" direction'
              );
            }
          }
        }
        exports.Chrome67 = Chrome67;
      },
      {
        "../Logger": 43,
        "../ortc": 69,
        "../utils": 72,
        "./HandlerInterface": 56,
        "./sdp/RemoteSdp": 64,
        "./sdp/commonUtils": 65,
        "./sdp/planBUtils": 66,
        "sdp-transform": 79,
      },
    ],
    52: [
      function (require, module, exports) {
        "use strict";
        var __createBinding =
          (this && this.__createBinding) ||
          (Object.create
            ? function (o, m, k, k2) {
                if (k2 === undefined) k2 = k;
                var desc = Object.getOwnPropertyDescriptor(m, k);
                if (
                  !desc ||
                  ("get" in desc
                    ? !m.__esModule
                    : desc.writable || desc.configurable)
                ) {
                  desc = {
                    enumerable: true,
                    get: function () {
                      return m[k];
                    },
                  };
                }
                Object.defineProperty(o, k2, desc);
              }
            : function (o, m, k, k2) {
                if (k2 === undefined) k2 = k;
                o[k2] = m[k];
              });
        var __setModuleDefault =
          (this && this.__setModuleDefault) ||
          (Object.create
            ? function (o, v) {
                Object.defineProperty(o, "default", {
                  enumerable: true,
                  value: v,
                });
              }
            : function (o, v) {
                o["default"] = v;
              });
        var __importStar =
          (this && this.__importStar) ||
          function (mod) {
            if (mod && mod.__esModule) return mod;
            var result = {};
            if (mod != null)
              for (var k in mod)
                if (
                  k !== "default" &&
                  Object.prototype.hasOwnProperty.call(mod, k)
                )
                  __createBinding(result, mod, k);
            __setModuleDefault(result, mod);
            return result;
          };
        Object.defineProperty(exports, "__esModule", { value: true });
        exports.Chrome70 = void 0;
        const sdpTransform = __importStar(require("sdp-transform"));
        const Logger_1 = require("../Logger");
        const utils = __importStar(require("../utils"));
        const ortc = __importStar(require("../ortc"));
        const sdpCommonUtils = __importStar(require("./sdp/commonUtils"));
        const sdpUnifiedPlanUtils = __importStar(
          require("./sdp/unifiedPlanUtils")
        );
        const HandlerInterface_1 = require("./HandlerInterface");
        const RemoteSdp_1 = require("./sdp/RemoteSdp");
        const scalabilityModes_1 = require("../scalabilityModes");
        const logger = new Logger_1.Logger("Chrome70");
        const SCTP_NUM_STREAMS = { OS: 1024, MIS: 1024 };
        class Chrome70 extends HandlerInterface_1.HandlerInterface {
          /**
           * Creates a factory function.
           */
          static createFactory() {
            return () => new Chrome70();
          }
          constructor() {
            super();
            // Map of RTCTransceivers indexed by MID.
            this._mapMidTransceiver = new Map();
            // Local stream for sending.
            this._sendStream = new MediaStream();
            // Whether a DataChannel m=application section has been created.
            this._hasDataChannelMediaSection = false;
            // Sending DataChannel id value counter. Incremented for each new DataChannel.
            this._nextSendSctpStreamId = 0;
            // Got transport local and remote parameters.
            this._transportReady = false;
          }
          get name() {
            return "Chrome70";
          }
          close() {
            logger.debug("close()");
            // Close RTCPeerConnection.
            if (this._pc) {
              try {
                this._pc.close();
              } catch (error) {}
            }
            this.emit("@close");
          }
          async getNativeRtpCapabilities() {
            logger.debug("getNativeRtpCapabilities()");
            const pc = new RTCPeerConnection({
              iceServers: [],
              iceTransportPolicy: "all",
              bundlePolicy: "max-bundle",
              rtcpMuxPolicy: "require",
              sdpSemantics: "unified-plan",
            });
            try {
              pc.addTransceiver("audio");
              pc.addTransceiver("video");
              const offer = await pc.createOffer();
              try {
                pc.close();
              } catch (error) {}
              const sdpObject = sdpTransform.parse(offer.sdp);
              const nativeRtpCapabilities =
                sdpCommonUtils.extractRtpCapabilities({
                  sdpObject,
                });
              return nativeRtpCapabilities;
            } catch (error) {
              try {
                pc.close();
              } catch (error2) {}
              throw error;
            }
          }
          async getNativeSctpCapabilities() {
            logger.debug("getNativeSctpCapabilities()");
            return {
              numStreams: SCTP_NUM_STREAMS,
            };
          }
          run({
            direction,
            iceParameters,
            iceCandidates,
            dtlsParameters,
            sctpParameters,
            iceServers,
            iceTransportPolicy,
            additionalSettings,
            proprietaryConstraints,
            extendedRtpCapabilities,
          }) {
            logger.debug("run()");
            this._direction = direction;
            this._remoteSdp = new RemoteSdp_1.RemoteSdp({
              iceParameters,
              iceCandidates,
              dtlsParameters,
              sctpParameters,
            });
            this._sendingRtpParametersByKind = {
              audio: ortc.getSendingRtpParameters(
                "audio",
                extendedRtpCapabilities
              ),
              video: ortc.getSendingRtpParameters(
                "video",
                extendedRtpCapabilities
              ),
            };
            this._sendingRemoteRtpParametersByKind = {
              audio: ortc.getSendingRemoteRtpParameters(
                "audio",
                extendedRtpCapabilities
              ),
              video: ortc.getSendingRemoteRtpParameters(
                "video",
                extendedRtpCapabilities
              ),
            };
            if (dtlsParameters.role && dtlsParameters.role !== "auto") {
              this._forcedLocalDtlsRole =
                dtlsParameters.role === "server" ? "client" : "server";
            }
            this._pc = new RTCPeerConnection(
              {
                iceServers: iceServers || [],
                iceTransportPolicy: iceTransportPolicy || "all",
                bundlePolicy: "max-bundle",
                rtcpMuxPolicy: "require",
                sdpSemantics: "unified-plan",
                ...additionalSettings,
              },
              proprietaryConstraints
            );
            this._pc.addEventListener("icegatheringstatechange", () => {
              this.emit("@icegatheringstatechange", this._pc.iceGatheringState);
            });
            if (this._pc.connectionState) {
              this._pc.addEventListener("connectionstatechange", () => {
                this.emit("@connectionstatechange", this._pc.connectionState);
              });
            } else {
              this._pc.addEventListener("iceconnectionstatechange", () => {
                logger.warn(
                  "run() | pc.connectionState not supported, using pc.iceConnectionState"
                );
                switch (this._pc.iceConnectionState) {
                  case "checking": {
                    this.emit("@connectionstatechange", "connecting");
                    break;
                  }
                  case "connected":
                  case "completed": {
                    this.emit("@connectionstatechange", "connected");
                    break;
                  }
                  case "failed": {
                    this.emit("@connectionstatechange", "failed");
                    break;
                  }
                  case "disconnected": {
                    this.emit("@connectionstatechange", "disconnected");
                    break;
                  }
                  case "closed": {
                    this.emit("@connectionstatechange", "closed");
                    break;
                  }
                }
              });
            }
          }
          async updateIceServers(iceServers) {
            logger.debug("updateIceServers()");
            const configuration = this._pc.getConfiguration();
            configuration.iceServers = iceServers;
            this._pc.setConfiguration(configuration);
          }
          async restartIce(iceParameters) {
            logger.debug("restartIce()");
            // Provide the remote SDP handler with new remote ICE parameters.
            this._remoteSdp.updateIceParameters(iceParameters);
            if (!this._transportReady) {
              return;
            }
            if (this._direction === "send") {
              const offer = await this._pc.createOffer({ iceRestart: true });
              logger.debug(
                "restartIce() | calling pc.setLocalDescription() [offer:%o]",
                offer
              );
              await this._pc.setLocalDescription(offer);
              const answer = { type: "answer", sdp: this._remoteSdp.getSdp() };
              logger.debug(
                "restartIce() | calling pc.setRemoteDescription() [answer:%o]",
                answer
              );
              await this._pc.setRemoteDescription(answer);
            } else {
              const offer = { type: "offer", sdp: this._remoteSdp.getSdp() };
              logger.debug(
                "restartIce() | calling pc.setRemoteDescription() [offer:%o]",
                offer
              );
              await this._pc.setRemoteDescription(offer);
              const answer = await this._pc.createAnswer();
              logger.debug(
                "restartIce() | calling pc.setLocalDescription() [answer:%o]",
                answer
              );
              await this._pc.setLocalDescription(answer);
            }
          }
          async getTransportStats() {
            return this._pc.getStats();
          }
          async send({ track, encodings, codecOptions, codec }) {
            this.assertSendDirection();
            logger.debug("send() [kind:%s, track.id:%s]", track.kind, track.id);
            const sendingRtpParameters = utils.clone(
              this._sendingRtpParametersByKind[track.kind]
            );
            // This may throw.
            sendingRtpParameters.codecs = ortc.reduceCodecs(
              sendingRtpParameters.codecs,
              codec
            );
            const sendingRemoteRtpParameters = utils.clone(
              this._sendingRemoteRtpParametersByKind[track.kind]
            );
            // This may throw.
            sendingRemoteRtpParameters.codecs = ortc.reduceCodecs(
              sendingRemoteRtpParameters.codecs,
              codec
            );
            const mediaSectionIdx = this._remoteSdp.getNextMediaSectionIdx();
            const transceiver = this._pc.addTransceiver(track, {
              direction: "sendonly",
              streams: [this._sendStream],
            });
            let offer = await this._pc.createOffer();
            let localSdpObject = sdpTransform.parse(offer.sdp);
            let offerMediaObject;
            if (!this._transportReady) {
              await this.setupTransport({
                localDtlsRole: this._forcedLocalDtlsRole ?? "client",
                localSdpObject,
              });
            }
            if (encodings && encodings.length > 1) {
              logger.debug("send() | enabling legacy simulcast");
              localSdpObject = sdpTransform.parse(offer.sdp);
              offerMediaObject = localSdpObject.media[mediaSectionIdx.idx];
              sdpUnifiedPlanUtils.addLegacySimulcast({
                offerMediaObject,
                numStreams: encodings.length,
              });
              offer = {
                type: "offer",
                sdp: sdpTransform.write(localSdpObject),
              };
            }
            // Special case for VP9 with SVC.
            let hackVp9Svc = false;
            const layers = (0, scalabilityModes_1.parse)(
              (encodings || [{}])[0].scalabilityMode
            );
            if (
              encodings &&
              encodings.length === 1 &&
              layers.spatialLayers > 1 &&
              sendingRtpParameters.codecs[0].mimeType.toLowerCase() ===
                "video/vp9"
            ) {
              logger.debug("send() | enabling legacy simulcast for VP9 SVC");
              hackVp9Svc = true;
              localSdpObject = sdpTransform.parse(offer.sdp);
              offerMediaObject = localSdpObject.media[mediaSectionIdx.idx];
              sdpUnifiedPlanUtils.addLegacySimulcast({
                offerMediaObject,
                numStreams: layers.spatialLayers,
              });
              offer = {
                type: "offer",
                sdp: sdpTransform.write(localSdpObject),
              };
            }
            logger.debug(
              "send() | calling pc.setLocalDescription() [offer:%o]",
              offer
            );
            await this._pc.setLocalDescription(offer);
            // If encodings are given, apply them now.
            if (encodings) {
              logger.debug("send() | applying given encodings");
              const parameters = transceiver.sender.getParameters();
              for (
                let idx = 0;
                idx < (parameters.encodings || []).length;
                ++idx
              ) {
                const encoding = parameters.encodings[idx];
                const desiredEncoding = encodings[idx];
                // Should not happen but just in case.
                if (!desiredEncoding) {
                  break;
                }
                parameters.encodings[idx] = Object.assign(
                  encoding,
                  desiredEncoding
                );
              }
              await transceiver.sender.setParameters(parameters);
            }
            // We can now get the transceiver.mid.
            const localId = transceiver.mid;
            // Set MID.
            sendingRtpParameters.mid = localId;
            localSdpObject = sdpTransform.parse(this._pc.localDescription.sdp);
            offerMediaObject = localSdpObject.media[mediaSectionIdx.idx];
            // Set RTCP CNAME.
            sendingRtpParameters.rtcp.cname = sdpCommonUtils.getCname({
              offerMediaObject,
            });
            // Set RTP encodings.
            sendingRtpParameters.encodings =
              sdpUnifiedPlanUtils.getRtpEncodings({
                offerMediaObject,
              });
            // Complete encodings with given values.
            if (encodings) {
              for (
                let idx = 0;
                idx < sendingRtpParameters.encodings.length;
                ++idx
              ) {
                if (encodings[idx]) {
                  Object.assign(
                    sendingRtpParameters.encodings[idx],
                    encodings[idx]
                  );
                }
              }
            }
            // Hack for VP9 SVC.
            if (hackVp9Svc) {
              sendingRtpParameters.encodings = [
                sendingRtpParameters.encodings[0],
              ];
            }
            // If VP8 or H264 and there is effective simulcast, add scalabilityMode to
            // each encoding.
            if (
              sendingRtpParameters.encodings.length > 1 &&
              (sendingRtpParameters.codecs[0].mimeType.toLowerCase() ===
                "video/vp8" ||
                sendingRtpParameters.codecs[0].mimeType.toLowerCase() ===
                  "video/h264")
            ) {
              for (const encoding of sendingRtpParameters.encodings) {
                encoding.scalabilityMode = "L1T3";
              }
            }
            this._remoteSdp.send({
              offerMediaObject,
              reuseMid: mediaSectionIdx.reuseMid,
              offerRtpParameters: sendingRtpParameters,
              answerRtpParameters: sendingRemoteRtpParameters,
              codecOptions,
            });
            const answer = { type: "answer", sdp: this._remoteSdp.getSdp() };
            logger.debug(
              "send() | calling pc.setRemoteDescription() [answer:%o]",
              answer
            );
            await this._pc.setRemoteDescription(answer);
            // Store in the map.
            this._mapMidTransceiver.set(localId, transceiver);
            return {
              localId,
              rtpParameters: sendingRtpParameters,
              rtpSender: transceiver.sender,
            };
          }
          async stopSending(localId) {
            this.assertSendDirection();
            logger.debug("stopSending() [localId:%s]", localId);
            const transceiver = this._mapMidTransceiver.get(localId);
            if (!transceiver) {
              throw new Error("associated RTCRtpTransceiver not found");
            }
            transceiver.sender.replaceTrack(null);
            this._pc.removeTrack(transceiver.sender);
            const mediaSectionClosed = this._remoteSdp.closeMediaSection(
              transceiver.mid
            );
            if (mediaSectionClosed) {
              try {
                transceiver.stop();
              } catch (error) {}
            }
            const offer = await this._pc.createOffer();
            logger.debug(
              "stopSending() | calling pc.setLocalDescription() [offer:%o]",
              offer
            );
            await this._pc.setLocalDescription(offer);
            const answer = { type: "answer", sdp: this._remoteSdp.getSdp() };
            logger.debug(
              "stopSending() | calling pc.setRemoteDescription() [answer:%o]",
              answer
            );
            await this._pc.setRemoteDescription(answer);
            this._mapMidTransceiver.delete(localId);
          }
          // eslint-disable-next-line @typescript-eslint/no-unused-vars
          async pauseSending(localId) {
            // Unimplemented.
          }
          // eslint-disable-next-line @typescript-eslint/no-unused-vars
          async resumeSending(localId) {
            // Unimplemented.
          }
          async replaceTrack(localId, track) {
            this.assertSendDirection();
            if (track) {
              logger.debug(
                "replaceTrack() [localId:%s, track.id:%s]",
                localId,
                track.id
              );
            } else {
              logger.debug("replaceTrack() [localId:%s, no track]", localId);
            }
            const transceiver = this._mapMidTransceiver.get(localId);
            if (!transceiver) {
              throw new Error("associated RTCRtpTransceiver not found");
            }
            await transceiver.sender.replaceTrack(track);
          }
          async setMaxSpatialLayer(localId, spatialLayer) {
            this.assertSendDirection();
            logger.debug(
              "setMaxSpatialLayer() [localId:%s, spatialLayer:%s]",
              localId,
              spatialLayer
            );
            const transceiver = this._mapMidTransceiver.get(localId);
            if (!transceiver) {
              throw new Error("associated RTCRtpTransceiver not found");
            }
            const parameters = transceiver.sender.getParameters();
            parameters.encodings.forEach((encoding, idx) => {
              if (idx <= spatialLayer) {
                encoding.active = true;
              } else {
                encoding.active = false;
              }
            });
            await transceiver.sender.setParameters(parameters);
            this._remoteSdp.muxMediaSectionSimulcast(
              localId,
              parameters.encodings
            );
            const offer = await this._pc.createOffer();
            logger.debug(
              "setMaxSpatialLayer() | calling pc.setLocalDescription() [offer:%o]",
              offer
            );
            await this._pc.setLocalDescription(offer);
            const answer = { type: "answer", sdp: this._remoteSdp.getSdp() };
            logger.debug(
              "setMaxSpatialLayer() | calling pc.setRemoteDescription() [answer:%o]",
              answer
            );
            await this._pc.setRemoteDescription(answer);
          }
          async setRtpEncodingParameters(localId, params) {
            this.assertSendDirection();
            logger.debug(
              "setRtpEncodingParameters() [localId:%s, params:%o]",
              localId,
              params
            );
            const transceiver = this._mapMidTransceiver.get(localId);
            if (!transceiver) {
              throw new Error("associated RTCRtpTransceiver not found");
            }
            const parameters = transceiver.sender.getParameters();
            parameters.encodings.forEach((encoding, idx) => {
              parameters.encodings[idx] = { ...encoding, ...params };
            });
            await transceiver.sender.setParameters(parameters);
            this._remoteSdp.muxMediaSectionSimulcast(
              localId,
              parameters.encodings
            );
            const offer = await this._pc.createOffer();
            logger.debug(
              "setRtpEncodingParameters() | calling pc.setLocalDescription() [offer:%o]",
              offer
            );
            await this._pc.setLocalDescription(offer);
            const answer = { type: "answer", sdp: this._remoteSdp.getSdp() };
            logger.debug(
              "setRtpEncodingParameters() | calling pc.setRemoteDescription() [answer:%o]",
              answer
            );
            await this._pc.setRemoteDescription(answer);
          }
          async getSenderStats(localId) {
            this.assertSendDirection();
            const transceiver = this._mapMidTransceiver.get(localId);
            if (!transceiver) {
              throw new Error("associated RTCRtpTransceiver not found");
            }
            return transceiver.sender.getStats();
          }
          async sendDataChannel({
            ordered,
            maxPacketLifeTime,
            maxRetransmits,
            label,
            protocol,
          }) {
            this.assertSendDirection();
            const options = {
              negotiated: true,
              id: this._nextSendSctpStreamId,
              ordered,
              maxPacketLifeTime,
              maxRetransmitTime: maxPacketLifeTime, // NOTE: Old spec.
              maxRetransmits,
              protocol,
            };
            logger.debug("sendDataChannel() [options:%o]", options);
            const dataChannel = this._pc.createDataChannel(label, options);
            // Increase next id.
            this._nextSendSctpStreamId =
              ++this._nextSendSctpStreamId % SCTP_NUM_STREAMS.MIS;
            // If this is the first DataChannel we need to create the SDP answer with
            // m=application section.
            if (!this._hasDataChannelMediaSection) {
              const offer = await this._pc.createOffer();
              const localSdpObject = sdpTransform.parse(offer.sdp);
              const offerMediaObject = localSdpObject.media.find(
                (m) => m.type === "application"
              );
              if (!this._transportReady) {
                await this.setupTransport({
                  localDtlsRole: this._forcedLocalDtlsRole ?? "client",
                  localSdpObject,
                });
              }
              logger.debug(
                "sendDataChannel() | calling pc.setLocalDescription() [offer:%o]",
                offer
              );
              await this._pc.setLocalDescription(offer);
              this._remoteSdp.sendSctpAssociation({ offerMediaObject });
              const answer = { type: "answer", sdp: this._remoteSdp.getSdp() };
              logger.debug(
                "sendDataChannel() | calling pc.setRemoteDescription() [answer:%o]",
                answer
              );
              await this._pc.setRemoteDescription(answer);
              this._hasDataChannelMediaSection = true;
            }
            const sctpStreamParameters = {
              streamId: options.id,
              ordered: options.ordered,
              maxPacketLifeTime: options.maxPacketLifeTime,
              maxRetransmits: options.maxRetransmits,
            };
            return { dataChannel, sctpStreamParameters };
          }
          async receive(optionsList) {
            this.assertRecvDirection();
            const results = [];
            const mapLocalId = new Map();
            for (const options of optionsList) {
              const { trackId, kind, rtpParameters, streamId } = options;
              logger.debug("receive() [trackId:%s, kind:%s]", trackId, kind);
              const localId =
                rtpParameters.mid || String(this._mapMidTransceiver.size);
              mapLocalId.set(trackId, localId);
              this._remoteSdp.receive({
                mid: localId,
                kind,
                offerRtpParameters: rtpParameters,
                streamId: streamId || rtpParameters.rtcp.cname,
                trackId,
              });
            }
            const offer = { type: "offer", sdp: this._remoteSdp.getSdp() };
            logger.debug(
              "receive() | calling pc.setRemoteDescription() [offer:%o]",
              offer
            );
            await this._pc.setRemoteDescription(offer);
            let answer = await this._pc.createAnswer();
            const localSdpObject = sdpTransform.parse(answer.sdp);
            for (const options of optionsList) {
              const { trackId, rtpParameters } = options;
              const localId = mapLocalId.get(trackId);
              const answerMediaObject = localSdpObject.media.find(
                (m) => String(m.mid) === localId
              );
              // May need to modify codec parameters in the answer based on codec
              // parameters in the offer.
              sdpCommonUtils.applyCodecParameters({
                offerRtpParameters: rtpParameters,
                answerMediaObject,
              });
            }
            answer = {
              type: "answer",
              sdp: sdpTransform.write(localSdpObject),
            };
            if (!this._transportReady) {
              await this.setupTransport({
                localDtlsRole: this._forcedLocalDtlsRole ?? "client",
                localSdpObject,
              });
            }
            logger.debug(
              "receive() | calling pc.setLocalDescription() [answer:%o]",
              answer
            );
            await this._pc.setLocalDescription(answer);
            for (const options of optionsList) {
              const { trackId } = options;
              const localId = mapLocalId.get(trackId);
              const transceiver = this._pc
                .getTransceivers()
                .find((t) => t.mid === localId);
              if (!transceiver) {
                throw new Error("new RTCRtpTransceiver not found");
              }
              // Store in the map.
              this._mapMidTransceiver.set(localId, transceiver);
              results.push({
                localId,
                track: transceiver.receiver.track,
                rtpReceiver: transceiver.receiver,
              });
            }
            return results;
          }
          async stopReceiving(localIds) {
            this.assertRecvDirection();
            for (const localId of localIds) {
              logger.debug("stopReceiving() [localId:%s]", localId);
              const transceiver = this._mapMidTransceiver.get(localId);
              if (!transceiver) {
                throw new Error("associated RTCRtpTransceiver not found");
              }
              this._remoteSdp.closeMediaSection(transceiver.mid);
            }
            const offer = { type: "offer", sdp: this._remoteSdp.getSdp() };
            logger.debug(
              "stopReceiving() | calling pc.setRemoteDescription() [offer:%o]",
              offer
            );
            await this._pc.setRemoteDescription(offer);
            const answer = await this._pc.createAnswer();
            logger.debug(
              "stopReceiving() | calling pc.setLocalDescription() [answer:%o]",
              answer
            );
            await this._pc.setLocalDescription(answer);
            for (const localId of localIds) {
              this._mapMidTransceiver.delete(localId);
            }
          }
          async pauseReceiving(
            // eslint-disable-next-line @typescript-eslint/no-unused-vars
            localIds
          ) {
            // Unimplemented.
          }
          async resumeReceiving(
            // eslint-disable-next-line @typescript-eslint/no-unused-vars
            localIds
          ) {
            // Unimplemented.
          }
          async getReceiverStats(localId) {
            this.assertRecvDirection();
            const transceiver = this._mapMidTransceiver.get(localId);
            if (!transceiver) {
              throw new Error("associated RTCRtpTransceiver not found");
            }
            return transceiver.receiver.getStats();
          }
          async receiveDataChannel({ sctpStreamParameters, label, protocol }) {
            this.assertRecvDirection();
            const { streamId, ordered, maxPacketLifeTime, maxRetransmits } =
              sctpStreamParameters;
            const options = {
              negotiated: true,
              id: streamId,
              ordered,
              maxPacketLifeTime,
              maxRetransmitTime: maxPacketLifeTime, // NOTE: Old spec.
              maxRetransmits,
              protocol,
            };
            logger.debug("receiveDataChannel() [options:%o]", options);
            const dataChannel = this._pc.createDataChannel(label, options);
            // If this is the first DataChannel we need to create the SDP offer with
            // m=application section.
            if (!this._hasDataChannelMediaSection) {
              this._remoteSdp.receiveSctpAssociation();
              const offer = { type: "offer", sdp: this._remoteSdp.getSdp() };
              logger.debug(
                "receiveDataChannel() | calling pc.setRemoteDescription() [offer:%o]",
                offer
              );
              await this._pc.setRemoteDescription(offer);
              const answer = await this._pc.createAnswer();
              if (!this._transportReady) {
                const localSdpObject = sdpTransform.parse(answer.sdp);
                await this.setupTransport({
                  localDtlsRole: this._forcedLocalDtlsRole ?? "client",
                  localSdpObject,
                });
              }
              logger.debug(
                "receiveDataChannel() | calling pc.setRemoteDescription() [answer:%o]",
                answer
              );
              await this._pc.setLocalDescription(answer);
              this._hasDataChannelMediaSection = true;
            }
            return { dataChannel };
          }
          async setupTransport({ localDtlsRole, localSdpObject }) {
            if (!localSdpObject) {
              localSdpObject = sdpTransform.parse(
                this._pc.localDescription.sdp
              );
            }
            // Get our local DTLS parameters.
            const dtlsParameters = sdpCommonUtils.extractDtlsParameters({
              sdpObject: localSdpObject,
            });
            // Set our DTLS role.
            dtlsParameters.role = localDtlsRole;
            // Update the remote DTLS role in the SDP.
            this._remoteSdp.updateDtlsRole(
              localDtlsRole === "client" ? "server" : "client"
            );
            // Need to tell the remote transport about our parameters.
            await new Promise((resolve, reject) => {
              this.safeEmit("@connect", { dtlsParameters }, resolve, reject);
            });
            this._transportReady = true;
          }
          assertSendDirection() {
            if (this._direction !== "send") {
              throw new Error(
                'method can just be called for handlers with "send" direction'
              );
            }
          }
          assertRecvDirection() {
            if (this._direction !== "recv") {
              throw new Error(
                'method can just be called for handlers with "recv" direction'
              );
            }
          }
        }
        exports.Chrome70 = Chrome70;
      },
      {
        "../Logger": 43,
        "../ortc": 69,
        "../scalabilityModes": 70,
        "../utils": 72,
        "./HandlerInterface": 56,
        "./sdp/RemoteSdp": 64,
        "./sdp/commonUtils": 65,
        "./sdp/unifiedPlanUtils": 67,
        "sdp-transform": 79,
      },
    ],
    53: [
      function (require, module, exports) {
        "use strict";
        var __createBinding =
          (this && this.__createBinding) ||
          (Object.create
            ? function (o, m, k, k2) {
                if (k2 === undefined) k2 = k;
                var desc = Object.getOwnPropertyDescriptor(m, k);
                if (
                  !desc ||
                  ("get" in desc
                    ? !m.__esModule
                    : desc.writable || desc.configurable)
                ) {
                  desc = {
                    enumerable: true,
                    get: function () {
                      return m[k];
                    },
                  };
                }
                Object.defineProperty(o, k2, desc);
              }
            : function (o, m, k, k2) {
                if (k2 === undefined) k2 = k;
                o[k2] = m[k];
              });
        var __setModuleDefault =
          (this && this.__setModuleDefault) ||
          (Object.create
            ? function (o, v) {
                Object.defineProperty(o, "default", {
                  enumerable: true,
                  value: v,
                });
              }
            : function (o, v) {
                o["default"] = v;
              });
        var __importStar =
          (this && this.__importStar) ||
          function (mod) {
            if (mod && mod.__esModule) return mod;
            var result = {};
            if (mod != null)
              for (var k in mod)
                if (
                  k !== "default" &&
                  Object.prototype.hasOwnProperty.call(mod, k)
                )
                  __createBinding(result, mod, k);
            __setModuleDefault(result, mod);
            return result;
          };
        Object.defineProperty(exports, "__esModule", { value: true });
        exports.Chrome74 = void 0;
        const sdpTransform = __importStar(require("sdp-transform"));
        const Logger_1 = require("../Logger");
        const utils = __importStar(require("../utils"));
        const ortc = __importStar(require("../ortc"));
        const sdpCommonUtils = __importStar(require("./sdp/commonUtils"));
        const sdpUnifiedPlanUtils = __importStar(
          require("./sdp/unifiedPlanUtils")
        );
        const ortcUtils = __importStar(require("./ortc/utils"));
        const errors_1 = require("../errors");
        const HandlerInterface_1 = require("./HandlerInterface");
        const RemoteSdp_1 = require("./sdp/RemoteSdp");
        const scalabilityModes_1 = require("../scalabilityModes");
        const logger = new Logger_1.Logger("Chrome74");
        const SCTP_NUM_STREAMS = { OS: 1024, MIS: 1024 };
        class Chrome74 extends HandlerInterface_1.HandlerInterface {
          /**
           * Creates a factory function.
           */
          static createFactory() {
            return () => new Chrome74();
          }
          constructor() {
            super();
            // Closed flag.
            this._closed = false;
            // Map of RTCTransceivers indexed by MID.
            this._mapMidTransceiver = new Map();
            // Local stream for sending.
            this._sendStream = new MediaStream();
            // Whether a DataChannel m=application section has been created.
            this._hasDataChannelMediaSection = false;
            // Sending DataChannel id value counter. Incremented for each new DataChannel.
            this._nextSendSctpStreamId = 0;
            // Got transport local and remote parameters.
            this._transportReady = false;
          }
          get name() {
            return "Chrome74";
          }
          close() {
            logger.debug("close()");
            if (this._closed) {
              return;
            }
            this._closed = true;
            // Close RTCPeerConnection.
            if (this._pc) {
              try {
                this._pc.close();
              } catch (error) {}
            }
            this.emit("@close");
          }
          async getNativeRtpCapabilities() {
            logger.debug("getNativeRtpCapabilities()");
            const pc = new RTCPeerConnection({
              iceServers: [],
              iceTransportPolicy: "all",
              bundlePolicy: "max-bundle",
              rtcpMuxPolicy: "require",
              sdpSemantics: "unified-plan",
            });
            try {
              pc.addTransceiver("audio");
              pc.addTransceiver("video");
              const offer = await pc.createOffer();
              try {
                pc.close();
              } catch (error) {}
              const sdpObject = sdpTransform.parse(offer.sdp);
              const nativeRtpCapabilities =
                sdpCommonUtils.extractRtpCapabilities({
                  sdpObject,
                });
              // libwebrtc supports NACK for OPUS but doesn't announce it.
              ortcUtils.addNackSuppportForOpus(nativeRtpCapabilities);
              return nativeRtpCapabilities;
            } catch (error) {
              try {
                pc.close();
              } catch (error2) {}
              throw error;
            }
          }
          async getNativeSctpCapabilities() {
            logger.debug("getNativeSctpCapabilities()");
            return {
              numStreams: SCTP_NUM_STREAMS,
            };
          }
          run({
            direction,
            iceParameters,
            iceCandidates,
            dtlsParameters,
            sctpParameters,
            iceServers,
            iceTransportPolicy,
            additionalSettings,
            proprietaryConstraints,
            extendedRtpCapabilities,
          }) {
            logger.debug("run()");
            this._direction = direction;
            this._remoteSdp = new RemoteSdp_1.RemoteSdp({
              iceParameters,
              iceCandidates,
              dtlsParameters,
              sctpParameters,
            });
            this._sendingRtpParametersByKind = {
              audio: ortc.getSendingRtpParameters(
                "audio",
                extendedRtpCapabilities
              ),
              video: ortc.getSendingRtpParameters(
                "video",
                extendedRtpCapabilities
              ),
            };
            this._sendingRemoteRtpParametersByKind = {
              audio: ortc.getSendingRemoteRtpParameters(
                "audio",
                extendedRtpCapabilities
              ),
              video: ortc.getSendingRemoteRtpParameters(
                "video",
                extendedRtpCapabilities
              ),
            };
            if (dtlsParameters.role && dtlsParameters.role !== "auto") {
              this._forcedLocalDtlsRole =
                dtlsParameters.role === "server" ? "client" : "server";
            }
            this._pc = new RTCPeerConnection(
              {
                iceServers: iceServers || [],
                iceTransportPolicy: iceTransportPolicy || "all",
                bundlePolicy: "max-bundle",
                rtcpMuxPolicy: "require",
                sdpSemantics: "unified-plan",
                ...additionalSettings,
              },
              proprietaryConstraints
            );
            this._pc.addEventListener("icegatheringstatechange", () => {
              this.emit("@icegatheringstatechange", this._pc.iceGatheringState);
            });
            if (this._pc.connectionState) {
              this._pc.addEventListener("connectionstatechange", () => {
                this.emit("@connectionstatechange", this._pc.connectionState);
              });
            } else {
              logger.warn(
                "run() | pc.connectionState not supported, using pc.iceConnectionState"
              );
              this._pc.addEventListener("iceconnectionstatechange", () => {
                switch (this._pc.iceConnectionState) {
                  case "checking": {
                    this.emit("@connectionstatechange", "connecting");
                    break;
                  }
                  case "connected":
                  case "completed": {
                    this.emit("@connectionstatechange", "connected");
                    break;
                  }
                  case "failed": {
                    this.emit("@connectionstatechange", "failed");
                    break;
                  }
                  case "disconnected": {
                    this.emit("@connectionstatechange", "disconnected");
                    break;
                  }
                  case "closed": {
                    this.emit("@connectionstatechange", "closed");
                    break;
                  }
                }
              });
            }
          }
          async updateIceServers(iceServers) {
            this.assertNotClosed();
            logger.debug("updateIceServers()");
            const configuration = this._pc.getConfiguration();
            configuration.iceServers = iceServers;
            this._pc.setConfiguration(configuration);
          }
          async restartIce(iceParameters) {
            this.assertNotClosed();
            logger.debug("restartIce()");
            // Provide the remote SDP handler with new remote ICE parameters.
            this._remoteSdp.updateIceParameters(iceParameters);
            if (!this._transportReady) {
              return;
            }
            if (this._direction === "send") {
              const offer = await this._pc.createOffer({ iceRestart: true });
              logger.debug(
                "restartIce() | calling pc.setLocalDescription() [offer:%o]",
                offer
              );
              await this._pc.setLocalDescription(offer);
              const answer = { type: "answer", sdp: this._remoteSdp.getSdp() };
              logger.debug(
                "restartIce() | calling pc.setRemoteDescription() [answer:%o]",
                answer
              );
              await this._pc.setRemoteDescription(answer);
            } else {
              const offer = { type: "offer", sdp: this._remoteSdp.getSdp() };
              logger.debug(
                "restartIce() | calling pc.setRemoteDescription() [offer:%o]",
                offer
              );
              await this._pc.setRemoteDescription(offer);
              const answer = await this._pc.createAnswer();
              logger.debug(
                "restartIce() | calling pc.setLocalDescription() [answer:%o]",
                answer
              );
              await this._pc.setLocalDescription(answer);
            }
          }
          async getTransportStats() {
            this.assertNotClosed();
            return this._pc.getStats();
          }
          async send({ track, encodings, codecOptions, codec }) {
            this.assertNotClosed();
            this.assertSendDirection();
            logger.debug("send() [kind:%s, track.id:%s]", track.kind, track.id);
            if (encodings && encodings.length > 1) {
              encodings.forEach((encoding, idx) => {
                encoding.rid = `r${idx}`;
              });
            }
            const sendingRtpParameters = utils.clone(
              this._sendingRtpParametersByKind[track.kind]
            );
            // This may throw.
            sendingRtpParameters.codecs = ortc.reduceCodecs(
              sendingRtpParameters.codecs,
              codec
            );
            const sendingRemoteRtpParameters = utils.clone(
              this._sendingRemoteRtpParametersByKind[track.kind]
            );
            // This may throw.
            sendingRemoteRtpParameters.codecs = ortc.reduceCodecs(
              sendingRemoteRtpParameters.codecs,
              codec
            );
            const mediaSectionIdx = this._remoteSdp.getNextMediaSectionIdx();
            const transceiver = this._pc.addTransceiver(track, {
              direction: "sendonly",
              streams: [this._sendStream],
              sendEncodings: encodings,
            });
            let offer = await this._pc.createOffer();
            let localSdpObject = sdpTransform.parse(offer.sdp);
            let offerMediaObject;
            if (!this._transportReady) {
              await this.setupTransport({
                localDtlsRole: this._forcedLocalDtlsRole ?? "client",
                localSdpObject,
              });
            }
            // Special case for VP9 with SVC.
            let hackVp9Svc = false;
            const layers = (0, scalabilityModes_1.parse)(
              (encodings || [{}])[0].scalabilityMode
            );
            if (
              encodings &&
              encodings.length === 1 &&
              layers.spatialLayers > 1 &&
              sendingRtpParameters.codecs[0].mimeType.toLowerCase() ===
                "video/vp9"
            ) {
              logger.debug("send() | enabling legacy simulcast for VP9 SVC");
              hackVp9Svc = true;
              localSdpObject = sdpTransform.parse(offer.sdp);
              offerMediaObject = localSdpObject.media[mediaSectionIdx.idx];
              sdpUnifiedPlanUtils.addLegacySimulcast({
                offerMediaObject,
                numStreams: layers.spatialLayers,
              });
              offer = {
                type: "offer",
                sdp: sdpTransform.write(localSdpObject),
              };
            }
            logger.debug(
              "send() | calling pc.setLocalDescription() [offer:%o]",
              offer
            );
            await this._pc.setLocalDescription(offer);
            // We can now get the transceiver.mid.
            const localId = transceiver.mid;
            // Set MID.
            sendingRtpParameters.mid = localId;
            localSdpObject = sdpTransform.parse(this._pc.localDescription.sdp);
            offerMediaObject = localSdpObject.media[mediaSectionIdx.idx];
            // Set RTCP CNAME.
            sendingRtpParameters.rtcp.cname = sdpCommonUtils.getCname({
              offerMediaObject,
            });
            // Set RTP encodings by parsing the SDP offer if no encodings are given.
            if (!encodings) {
              sendingRtpParameters.encodings =
                sdpUnifiedPlanUtils.getRtpEncodings({
                  offerMediaObject,
                });
            }
            // Set RTP encodings by parsing the SDP offer and complete them with given
            // one if just a single encoding has been given.
            else if (encodings.length === 1) {
              let newEncodings = sdpUnifiedPlanUtils.getRtpEncodings({
                offerMediaObject,
              });
              Object.assign(newEncodings[0], encodings[0]);
              // Hack for VP9 SVC.
              if (hackVp9Svc) {
                newEncodings = [newEncodings[0]];
              }
              sendingRtpParameters.encodings = newEncodings;
            }
            // Otherwise if more than 1 encoding are given use them verbatim.
            else {
              sendingRtpParameters.encodings = encodings;
            }
            // If VP8 or H264 and there is effective simulcast, add scalabilityMode to
            // each encoding.
            if (
              sendingRtpParameters.encodings.length > 1 &&
              (sendingRtpParameters.codecs[0].mimeType.toLowerCase() ===
                "video/vp8" ||
                sendingRtpParameters.codecs[0].mimeType.toLowerCase() ===
                  "video/h264")
            ) {
              for (const encoding of sendingRtpParameters.encodings) {
                if (encoding.scalabilityMode) {
                  encoding.scalabilityMode = `L1T${layers.temporalLayers}`;
                } else {
                  encoding.scalabilityMode = "L1T3";
                }
              }
            }
            this._remoteSdp.send({
              offerMediaObject,
              reuseMid: mediaSectionIdx.reuseMid,
              offerRtpParameters: sendingRtpParameters,
              answerRtpParameters: sendingRemoteRtpParameters,
              codecOptions,
              extmapAllowMixed: true,
            });
            const answer = { type: "answer", sdp: this._remoteSdp.getSdp() };
            logger.debug(
              "send() | calling pc.setRemoteDescription() [answer:%o]",
              answer
            );
            await this._pc.setRemoteDescription(answer);
            // Store in the map.
            this._mapMidTransceiver.set(localId, transceiver);
            return {
              localId,
              rtpParameters: sendingRtpParameters,
              rtpSender: transceiver.sender,
            };
          }
          async stopSending(localId) {
            this.assertSendDirection();
            logger.debug("stopSending() [localId:%s]", localId);
            if (this._closed) {
              return;
            }
            const transceiver = this._mapMidTransceiver.get(localId);
            if (!transceiver) {
              throw new Error("associated RTCRtpTransceiver not found");
            }
            transceiver.sender.replaceTrack(null);
            this._pc.removeTrack(transceiver.sender);
            const mediaSectionClosed = this._remoteSdp.closeMediaSection(
              transceiver.mid
            );
            if (mediaSectionClosed) {
              try {
                transceiver.stop();
              } catch (error) {}
            }
            const offer = await this._pc.createOffer();
            logger.debug(
              "stopSending() | calling pc.setLocalDescription() [offer:%o]",
              offer
            );
            await this._pc.setLocalDescription(offer);
            const answer = { type: "answer", sdp: this._remoteSdp.getSdp() };
            logger.debug(
              "stopSending() | calling pc.setRemoteDescription() [answer:%o]",
              answer
            );
            await this._pc.setRemoteDescription(answer);
            this._mapMidTransceiver.delete(localId);
          }
          async pauseSending(localId) {
            this.assertNotClosed();
            this.assertSendDirection();
            logger.debug("pauseSending() [localId:%s]", localId);
            const transceiver = this._mapMidTransceiver.get(localId);
            if (!transceiver) {
              throw new Error("associated RTCRtpTransceiver not found");
            }
            transceiver.direction = "inactive";
            this._remoteSdp.pauseMediaSection(localId);
            const offer = await this._pc.createOffer();
            logger.debug(
              "pauseSending() | calling pc.setLocalDescription() [offer:%o]",
              offer
            );
            await this._pc.setLocalDescription(offer);
            const answer = { type: "answer", sdp: this._remoteSdp.getSdp() };
            logger.debug(
              "pauseSending() | calling pc.setRemoteDescription() [answer:%o]",
              answer
            );
            await this._pc.setRemoteDescription(answer);
          }
          async resumeSending(localId) {
            this.assertNotClosed();
            this.assertSendDirection();
            logger.debug("resumeSending() [localId:%s]", localId);
            const transceiver = this._mapMidTransceiver.get(localId);
            this._remoteSdp.resumeSendingMediaSection(localId);
            if (!transceiver) {
              throw new Error("associated RTCRtpTransceiver not found");
            }
            transceiver.direction = "sendonly";
            const offer = await this._pc.createOffer();
            logger.debug(
              "resumeSending() | calling pc.setLocalDescription() [offer:%o]",
              offer
            );
            await this._pc.setLocalDescription(offer);
            const answer = { type: "answer", sdp: this._remoteSdp.getSdp() };
            logger.debug(
              "resumeSending() | calling pc.setRemoteDescription() [answer:%o]",
              answer
            );
            await this._pc.setRemoteDescription(answer);
          }
          async replaceTrack(localId, track) {
            this.assertNotClosed();
            this.assertSendDirection();
            if (track) {
              logger.debug(
                "replaceTrack() [localId:%s, track.id:%s]",
                localId,
                track.id
              );
            } else {
              logger.debug("replaceTrack() [localId:%s, no track]", localId);
            }
            const transceiver = this._mapMidTransceiver.get(localId);
            if (!transceiver) {
              throw new Error("associated RTCRtpTransceiver not found");
            }
            await transceiver.sender.replaceTrack(track);
          }
          async setMaxSpatialLayer(localId, spatialLayer) {
            this.assertNotClosed();
            this.assertSendDirection();
            logger.debug(
              "setMaxSpatialLayer() [localId:%s, spatialLayer:%s]",
              localId,
              spatialLayer
            );
            const transceiver = this._mapMidTransceiver.get(localId);
            if (!transceiver) {
              throw new Error("associated RTCRtpTransceiver not found");
            }
            const parameters = transceiver.sender.getParameters();
            parameters.encodings.forEach((encoding, idx) => {
              if (idx <= spatialLayer) {
                encoding.active = true;
              } else {
                encoding.active = false;
              }
            });
            await transceiver.sender.setParameters(parameters);
            this._remoteSdp.muxMediaSectionSimulcast(
              localId,
              parameters.encodings
            );
            const offer = await this._pc.createOffer();
            logger.debug(
              "setMaxSpatialLayer() | calling pc.setLocalDescription() [offer:%o]",
              offer
            );
            await this._pc.setLocalDescription(offer);
            const answer = { type: "answer", sdp: this._remoteSdp.getSdp() };
            logger.debug(
              "setMaxSpatialLayer() | calling pc.setRemoteDescription() [answer:%o]",
              answer
            );
            await this._pc.setRemoteDescription(answer);
          }
          async setRtpEncodingParameters(localId, params) {
            this.assertNotClosed();
            this.assertSendDirection();
            logger.debug(
              "setRtpEncodingParameters() [localId:%s, params:%o]",
              localId,
              params
            );
            const transceiver = this._mapMidTransceiver.get(localId);
            if (!transceiver) {
              throw new Error("associated RTCRtpTransceiver not found");
            }
            const parameters = transceiver.sender.getParameters();
            parameters.encodings.forEach((encoding, idx) => {
              parameters.encodings[idx] = { ...encoding, ...params };
            });
            await transceiver.sender.setParameters(parameters);
            this._remoteSdp.muxMediaSectionSimulcast(
              localId,
              parameters.encodings
            );
            const offer = await this._pc.createOffer();
            logger.debug(
              "setRtpEncodingParameters() | calling pc.setLocalDescription() [offer:%o]",
              offer
            );
            await this._pc.setLocalDescription(offer);
            const answer = { type: "answer", sdp: this._remoteSdp.getSdp() };
            logger.debug(
              "setRtpEncodingParameters() | calling pc.setRemoteDescription() [answer:%o]",
              answer
            );
            await this._pc.setRemoteDescription(answer);
          }
          async getSenderStats(localId) {
            this.assertNotClosed();
            this.assertSendDirection();
            const transceiver = this._mapMidTransceiver.get(localId);
            if (!transceiver) {
              throw new Error("associated RTCRtpTransceiver not found");
            }
            return transceiver.sender.getStats();
          }
          async sendDataChannel({
            ordered,
            maxPacketLifeTime,
            maxRetransmits,
            label,
            protocol,
          }) {
            this.assertNotClosed();
            this.assertSendDirection();
            const options = {
              negotiated: true,
              id: this._nextSendSctpStreamId,
              ordered,
              maxPacketLifeTime,
              maxRetransmits,
              protocol,
            };
            logger.debug("sendDataChannel() [options:%o]", options);
            const dataChannel = this._pc.createDataChannel(label, options);
            // Increase next id.
            this._nextSendSctpStreamId =
              ++this._nextSendSctpStreamId % SCTP_NUM_STREAMS.MIS;
            // If this is the first DataChannel we need to create the SDP answer with
            // m=application section.
            if (!this._hasDataChannelMediaSection) {
              const offer = await this._pc.createOffer();
              const localSdpObject = sdpTransform.parse(offer.sdp);
              const offerMediaObject = localSdpObject.media.find(
                (m) => m.type === "application"
              );
              if (!this._transportReady) {
                await this.setupTransport({
                  localDtlsRole: this._forcedLocalDtlsRole ?? "client",
                  localSdpObject,
                });
              }
              logger.debug(
                "sendDataChannel() | calling pc.setLocalDescription() [offer:%o]",
                offer
              );
              await this._pc.setLocalDescription(offer);
              this._remoteSdp.sendSctpAssociation({ offerMediaObject });
              const answer = { type: "answer", sdp: this._remoteSdp.getSdp() };
              logger.debug(
                "sendDataChannel() | calling pc.setRemoteDescription() [answer:%o]",
                answer
              );
              await this._pc.setRemoteDescription(answer);
              this._hasDataChannelMediaSection = true;
            }
            const sctpStreamParameters = {
              streamId: options.id,
              ordered: options.ordered,
              maxPacketLifeTime: options.maxPacketLifeTime,
              maxRetransmits: options.maxRetransmits,
            };
            return { dataChannel, sctpStreamParameters };
          }
          async receive(optionsList) {
            this.assertNotClosed();
            this.assertRecvDirection();
            const results = [];
            const mapLocalId = new Map();
            for (const options of optionsList) {
              const { trackId, kind, rtpParameters, streamId } = options;
              logger.debug("receive() [trackId:%s, kind:%s]", trackId, kind);
              const localId =
                rtpParameters.mid || String(this._mapMidTransceiver.size);
              mapLocalId.set(trackId, localId);
              this._remoteSdp.receive({
                mid: localId,
                kind,
                offerRtpParameters: rtpParameters,
                streamId: streamId || rtpParameters.rtcp.cname,
                trackId,
              });
            }
            const offer = { type: "offer", sdp: this._remoteSdp.getSdp() };
            logger.debug(
              "receive() | calling pc.setRemoteDescription() [offer:%o]",
              offer
            );
            await this._pc.setRemoteDescription(offer);
            let answer = await this._pc.createAnswer();
            const localSdpObject = sdpTransform.parse(answer.sdp);
            for (const options of optionsList) {
              const { trackId, rtpParameters } = options;
              const localId = mapLocalId.get(trackId);
              const answerMediaObject = localSdpObject.media.find(
                (m) => String(m.mid) === localId
              );
              // May need to modify codec parameters in the answer based on codec
              // parameters in the offer.
              sdpCommonUtils.applyCodecParameters({
                offerRtpParameters: rtpParameters,
                answerMediaObject,
              });
            }
            answer = {
              type: "answer",
              sdp: sdpTransform.write(localSdpObject),
            };
            if (!this._transportReady) {
              await this.setupTransport({
                localDtlsRole: this._forcedLocalDtlsRole ?? "client",
                localSdpObject,
              });
            }
            logger.debug(
              "receive() | calling pc.setLocalDescription() [answer:%o]",
              answer
            );
            await this._pc.setLocalDescription(answer);
            for (const options of optionsList) {
              const { trackId } = options;
              const localId = mapLocalId.get(trackId);
              const transceiver = this._pc
                .getTransceivers()
                .find((t) => t.mid === localId);
              if (!transceiver) {
                throw new Error("new RTCRtpTransceiver not found");
              } else {
                // Store in the map.
                this._mapMidTransceiver.set(localId, transceiver);
                results.push({
                  localId,
                  track: transceiver.receiver.track,
                  rtpReceiver: transceiver.receiver,
                });
              }
            }
            return results;
          }
          async stopReceiving(localIds) {
            this.assertRecvDirection();
            if (this._closed) {
              return;
            }
            for (const localId of localIds) {
              logger.debug("stopReceiving() [localId:%s]", localId);
              const transceiver = this._mapMidTransceiver.get(localId);
              if (!transceiver) {
                throw new Error("associated RTCRtpTransceiver not found");
              }
              this._remoteSdp.closeMediaSection(transceiver.mid);
            }
            const offer = { type: "offer", sdp: this._remoteSdp.getSdp() };
            logger.debug(
              "stopReceiving() | calling pc.setRemoteDescription() [offer:%o]",
              offer
            );
            await this._pc.setRemoteDescription(offer);
            const answer = await this._pc.createAnswer();
            logger.debug(
              "stopReceiving() | calling pc.setLocalDescription() [answer:%o]",
              answer
            );
            await this._pc.setLocalDescription(answer);
            for (const localId of localIds) {
              this._mapMidTransceiver.delete(localId);
            }
          }
          async pauseReceiving(localIds) {
            this.assertNotClosed();
            this.assertRecvDirection();
            for (const localId of localIds) {
              logger.debug("pauseReceiving() [localId:%s]", localId);
              const transceiver = this._mapMidTransceiver.get(localId);
              if (!transceiver) {
                throw new Error("associated RTCRtpTransceiver not found");
              }
              transceiver.direction = "inactive";
              this._remoteSdp.pauseMediaSection(localId);
            }
            const offer = { type: "offer", sdp: this._remoteSdp.getSdp() };
            logger.debug(
              "pauseReceiving() | calling pc.setRemoteDescription() [offer:%o]",
              offer
            );
            await this._pc.setRemoteDescription(offer);
            const answer = await this._pc.createAnswer();
            logger.debug(
              "pauseReceiving() | calling pc.setLocalDescription() [answer:%o]",
              answer
            );
            await this._pc.setLocalDescription(answer);
          }
          async resumeReceiving(localIds) {
            this.assertNotClosed();
            this.assertRecvDirection();
            for (const localId of localIds) {
              logger.debug("resumeReceiving() [localId:%s]", localId);
              const transceiver = this._mapMidTransceiver.get(localId);
              if (!transceiver) {
                throw new Error("associated RTCRtpTransceiver not found");
              }
              transceiver.direction = "recvonly";
              this._remoteSdp.resumeReceivingMediaSection(localId);
            }
            const offer = { type: "offer", sdp: this._remoteSdp.getSdp() };
            logger.debug(
              "resumeReceiving() | calling pc.setRemoteDescription() [offer:%o]",
              offer
            );
            await this._pc.setRemoteDescription(offer);
            const answer = await this._pc.createAnswer();
            logger.debug(
              "resumeReceiving() | calling pc.setLocalDescription() [answer:%o]",
              answer
            );
            await this._pc.setLocalDescription(answer);
          }
          async getReceiverStats(localId) {
            this.assertNotClosed();
            this.assertRecvDirection();
            const transceiver = this._mapMidTransceiver.get(localId);
            if (!transceiver) {
              throw new Error("associated RTCRtpTransceiver not found");
            }
            return transceiver.receiver.getStats();
          }
          async receiveDataChannel({ sctpStreamParameters, label, protocol }) {
            this.assertNotClosed();
            this.assertRecvDirection();
            const { streamId, ordered, maxPacketLifeTime, maxRetransmits } =
              sctpStreamParameters;
            const options = {
              negotiated: true,
              id: streamId,
              ordered,
              maxPacketLifeTime,
              maxRetransmits,
              protocol,
            };
            logger.debug("receiveDataChannel() [options:%o]", options);
            const dataChannel = this._pc.createDataChannel(label, options);
            // If this is the first DataChannel we need to create the SDP offer with
            // m=application section.
            if (!this._hasDataChannelMediaSection) {
              this._remoteSdp.receiveSctpAssociation();
              const offer = { type: "offer", sdp: this._remoteSdp.getSdp() };
              logger.debug(
                "receiveDataChannel() | calling pc.setRemoteDescription() [offer:%o]",
                offer
              );
              await this._pc.setRemoteDescription(offer);
              const answer = await this._pc.createAnswer();
              if (!this._transportReady) {
                const localSdpObject = sdpTransform.parse(answer.sdp);
                await this.setupTransport({
                  localDtlsRole: this._forcedLocalDtlsRole ?? "client",
                  localSdpObject,
                });
              }
              logger.debug(
                "receiveDataChannel() | calling pc.setRemoteDescription() [answer:%o]",
                answer
              );
              await this._pc.setLocalDescription(answer);
              this._hasDataChannelMediaSection = true;
            }
            return { dataChannel };
          }
          async setupTransport({ localDtlsRole, localSdpObject }) {
            if (!localSdpObject) {
              localSdpObject = sdpTransform.parse(
                this._pc.localDescription.sdp
              );
            }
            // Get our local DTLS parameters.
            const dtlsParameters = sdpCommonUtils.extractDtlsParameters({
              sdpObject: localSdpObject,
            });
            // Set our DTLS role.
            dtlsParameters.role = localDtlsRole;
            // Update the remote DTLS role in the SDP.
            this._remoteSdp.updateDtlsRole(
              localDtlsRole === "client" ? "server" : "client"
            );
            // Need to tell the remote transport about our parameters.
            await new Promise((resolve, reject) => {
              this.safeEmit("@connect", { dtlsParameters }, resolve, reject);
            });
            this._transportReady = true;
          }
          assertNotClosed() {
            if (this._closed) {
              throw new errors_1.InvalidStateError(
                "method called in a closed handler"
              );
            }
          }
          assertSendDirection() {
            if (this._direction !== "send") {
              throw new Error(
                'method can just be called for handlers with "send" direction'
              );
            }
          }
          assertRecvDirection() {
            if (this._direction !== "recv") {
              throw new Error(
                'method can just be called for handlers with "recv" direction'
              );
            }
          }
        }
        exports.Chrome74 = Chrome74;
      },
      {
        "../Logger": 43,
        "../errors": 48,
        "../ortc": 69,
        "../scalabilityModes": 70,
        "../utils": 72,
        "./HandlerInterface": 56,
        "./ortc/utils": 62,
        "./sdp/RemoteSdp": 64,
        "./sdp/commonUtils": 65,
        "./sdp/unifiedPlanUtils": 67,
        "sdp-transform": 79,
      },
    ],
    54: [
      function (require, module, exports) {
        "use strict";
        var __createBinding =
          (this && this.__createBinding) ||
          (Object.create
            ? function (o, m, k, k2) {
                if (k2 === undefined) k2 = k;
                var desc = Object.getOwnPropertyDescriptor(m, k);
                if (
                  !desc ||
                  ("get" in desc
                    ? !m.__esModule
                    : desc.writable || desc.configurable)
                ) {
                  desc = {
                    enumerable: true,
                    get: function () {
                      return m[k];
                    },
                  };
                }
                Object.defineProperty(o, k2, desc);
              }
            : function (o, m, k, k2) {
                if (k2 === undefined) k2 = k;
                o[k2] = m[k];
              });
        var __setModuleDefault =
          (this && this.__setModuleDefault) ||
          (Object.create
            ? function (o, v) {
                Object.defineProperty(o, "default", {
                  enumerable: true,
                  value: v,
                });
              }
            : function (o, v) {
                o["default"] = v;
              });
        var __importStar =
          (this && this.__importStar) ||
          function (mod) {
            if (mod && mod.__esModule) return mod;
            var result = {};
            if (mod != null)
              for (var k in mod)
                if (
                  k !== "default" &&
                  Object.prototype.hasOwnProperty.call(mod, k)
                )
                  __createBinding(result, mod, k);
            __setModuleDefault(result, mod);
            return result;
          };
        Object.defineProperty(exports, "__esModule", { value: true });
        exports.Edge11 = void 0;
        const Logger_1 = require("../Logger");
        const errors_1 = require("../errors");
        const utils = __importStar(require("../utils"));
        const ortc = __importStar(require("../ortc"));
        const edgeUtils = __importStar(require("./ortc/edgeUtils"));
        const HandlerInterface_1 = require("./HandlerInterface");
        const logger = new Logger_1.Logger("Edge11");
        class Edge11 extends HandlerInterface_1.HandlerInterface {
          /**
           * Creates a factory function.
           */
          static createFactory() {
            return () => new Edge11();
          }
          constructor() {
            super();
            // Map of RTCRtpSenders indexed by id.
            this._rtpSenders = new Map();
            // Map of RTCRtpReceivers indexed by id.
            this._rtpReceivers = new Map();
            // Next localId for sending tracks.
            this._nextSendLocalId = 0;
            // Got transport local and remote parameters.
            this._transportReady = false;
          }
          get name() {
            return "Edge11";
          }
          close() {
            logger.debug("close()");
            // Close the ICE gatherer.
            // NOTE: Not yet implemented by Edge.
            try {
              this._iceGatherer.close();
            } catch (error) {}
            // Close the ICE transport.
            try {
              this._iceTransport.stop();
            } catch (error) {}
            // Close the DTLS transport.
            try {
              this._dtlsTransport.stop();
            } catch (error) {}
            // Close RTCRtpSenders.
            for (const rtpSender of this._rtpSenders.values()) {
              try {
                rtpSender.stop();
              } catch (error) {}
            }
            // Close RTCRtpReceivers.
            for (const rtpReceiver of this._rtpReceivers.values()) {
              try {
                rtpReceiver.stop();
              } catch (error) {}
            }
            this.emit("@close");
          }
          async getNativeRtpCapabilities() {
            logger.debug("getNativeRtpCapabilities()");
            return edgeUtils.getCapabilities();
          }
          async getNativeSctpCapabilities() {
            logger.debug("getNativeSctpCapabilities()");
            return {
              numStreams: { OS: 0, MIS: 0 },
            };
          }
          run({
            direction, // eslint-disable-line @typescript-eslint/no-unused-vars
            iceParameters,
            iceCandidates,
            dtlsParameters,
            sctpParameters, // eslint-disable-line @typescript-eslint/no-unused-vars
            iceServers,
            iceTransportPolicy,
            additionalSettings, // eslint-disable-line @typescript-eslint/no-unused-vars
            proprietaryConstraints, // eslint-disable-line @typescript-eslint/no-unused-vars
            extendedRtpCapabilities,
          }) {
            logger.debug("run()");
            this._sendingRtpParametersByKind = {
              audio: ortc.getSendingRtpParameters(
                "audio",
                extendedRtpCapabilities
              ),
              video: ortc.getSendingRtpParameters(
                "video",
                extendedRtpCapabilities
              ),
            };
            this._remoteIceParameters = iceParameters;
            this._remoteIceCandidates = iceCandidates;
            this._remoteDtlsParameters = dtlsParameters;
            this._cname = `CNAME-${utils.generateRandomNumber()}`;
            this.setIceGatherer({ iceServers, iceTransportPolicy });
            this.setIceTransport();
            this.setDtlsTransport();
          }
          // eslint-disable-next-line @typescript-eslint/no-unused-vars
          async updateIceServers(iceServers) {
            // NOTE: Edge 11 does not implement iceGatherer.gater().
            throw new errors_1.UnsupportedError("not supported");
          }
          async restartIce(iceParameters) {
            logger.debug("restartIce()");
            this._remoteIceParameters = iceParameters;
            if (!this._transportReady) {
              return;
            }
            logger.debug("restartIce() | calling iceTransport.start()");
            this._iceTransport.start(
              this._iceGatherer,
              iceParameters,
              "controlling"
            );
            for (const candidate of this._remoteIceCandidates) {
              this._iceTransport.addRemoteCandidate(candidate);
            }
            this._iceTransport.addRemoteCandidate({});
          }
          async getTransportStats() {
            return this._iceTransport.getStats();
          }
          async send(
            // eslint-disable-next-line @typescript-eslint/no-unused-vars
            { track, encodings, codecOptions, codec }
          ) {
            logger.debug("send() [kind:%s, track.id:%s]", track.kind, track.id);
            if (!this._transportReady) {
              await this.setupTransport({ localDtlsRole: "server" });
            }
            logger.debug("send() | calling new RTCRtpSender()");
            const rtpSender = new RTCRtpSender(track, this._dtlsTransport);
            const rtpParameters = utils.clone(
              this._sendingRtpParametersByKind[track.kind]
            );
            rtpParameters.codecs = ortc.reduceCodecs(
              rtpParameters.codecs,
              codec
            );
            const useRtx = rtpParameters.codecs.some((_codec) =>
              /.+\/rtx$/i.test(_codec.mimeType)
            );
            if (!encodings) {
              encodings = [{}];
            }
            for (const encoding of encodings) {
              encoding.ssrc = utils.generateRandomNumber();
              if (useRtx) {
                encoding.rtx = { ssrc: utils.generateRandomNumber() };
              }
            }
            rtpParameters.encodings = encodings;
            // Fill RTCRtpParameters.rtcp.
            rtpParameters.rtcp = {
              cname: this._cname,
              reducedSize: true,
              mux: true,
            };
            // NOTE: Convert our standard RTCRtpParameters into those that Edge
            // expects.
            const edgeRtpParameters =
              edgeUtils.mangleRtpParameters(rtpParameters);
            logger.debug(
              "send() | calling rtpSender.send() [params:%o]",
              edgeRtpParameters
            );
            await rtpSender.send(edgeRtpParameters);
            const localId = String(this._nextSendLocalId);
            this._nextSendLocalId++;
            // Store it.
            this._rtpSenders.set(localId, rtpSender);
            return { localId, rtpParameters, rtpSender };
          }
          async stopSending(localId) {
            logger.debug("stopSending() [localId:%s]", localId);
            const rtpSender = this._rtpSenders.get(localId);
            if (!rtpSender) {
              throw new Error("RTCRtpSender not found");
            }
            this._rtpSenders.delete(localId);
            try {
              logger.debug("stopSending() | calling rtpSender.stop()");
              rtpSender.stop();
            } catch (error) {
              logger.warn("stopSending() | rtpSender.stop() failed:%o", error);
              throw error;
            }
          }
          // eslint-disable-next-line @typescript-eslint/no-unused-vars
          async pauseSending(localId) {
            // Unimplemented.
          }
          // eslint-disable-next-line @typescript-eslint/no-unused-vars
          async resumeSending(localId) {
            // Unimplemented.
          }
          async replaceTrack(localId, track) {
            if (track) {
              logger.debug(
                "replaceTrack() [localId:%s, track.id:%s]",
                localId,
                track.id
              );
            } else {
              logger.debug("replaceTrack() [localId:%s, no track]", localId);
            }
            const rtpSender = this._rtpSenders.get(localId);
            if (!rtpSender) {
              throw new Error("RTCRtpSender not found");
            }
            rtpSender.setTrack(track);
          }
          async setMaxSpatialLayer(localId, spatialLayer) {
            logger.debug(
              "setMaxSpatialLayer() [localId:%s, spatialLayer:%s]",
              localId,
              spatialLayer
            );
            const rtpSender = this._rtpSenders.get(localId);
            if (!rtpSender) {
              throw new Error("RTCRtpSender not found");
            }
            const parameters = rtpSender.getParameters();
            parameters.encodings.forEach((encoding, idx) => {
              if (idx <= spatialLayer) {
                encoding.active = true;
              } else {
                encoding.active = false;
              }
            });
            await rtpSender.setParameters(parameters);
          }
          async setRtpEncodingParameters(localId, params) {
            logger.debug(
              "setRtpEncodingParameters() [localId:%s, params:%o]",
              localId,
              params
            );
            const rtpSender = this._rtpSenders.get(localId);
            if (!rtpSender) {
              throw new Error("RTCRtpSender not found");
            }
            const parameters = rtpSender.getParameters();
            parameters.encodings.forEach((encoding, idx) => {
              parameters.encodings[idx] = { ...encoding, ...params };
            });
            await rtpSender.setParameters(parameters);
          }
          async getSenderStats(localId) {
            const rtpSender = this._rtpSenders.get(localId);
            if (!rtpSender) {
              throw new Error("RTCRtpSender not found");
            }
            return rtpSender.getStats();
          }
          async sendDataChannel(
            // eslint-disable-next-line @typescript-eslint/no-unused-vars
            options
          ) {
            throw new errors_1.UnsupportedError("not implemented");
          }
          async receive(optionsList) {
            const results = [];
            for (const options of optionsList) {
              const { trackId, kind } = options;
              logger.debug("receive() [trackId:%s, kind:%s]", trackId, kind);
            }
            if (!this._transportReady) {
              await this.setupTransport({ localDtlsRole: "server" });
            }
            for (const options of optionsList) {
              const { trackId, kind, rtpParameters } = options;
              logger.debug("receive() | calling new RTCRtpReceiver()");
              const rtpReceiver = new RTCRtpReceiver(this._dtlsTransport, kind);
              rtpReceiver.addEventListener("error", (event) => {
                logger.error('rtpReceiver "error" event [event:%o]', event);
              });
              // NOTE: Convert our standard RTCRtpParameters into those that Edge
              // expects.
              const edgeRtpParameters =
                edgeUtils.mangleRtpParameters(rtpParameters);
              logger.debug(
                "receive() | calling rtpReceiver.receive() [params:%o]",
                edgeRtpParameters
              );
              await rtpReceiver.receive(edgeRtpParameters);
              const localId = trackId;
              // Store it.
              this._rtpReceivers.set(localId, rtpReceiver);
              results.push({
                localId,
                track: rtpReceiver.track,
                rtpReceiver,
              });
            }
            return results;
          }
          async stopReceiving(localIds) {
            for (const localId of localIds) {
              logger.debug("stopReceiving() [localId:%s]", localId);
              const rtpReceiver = this._rtpReceivers.get(localId);
              if (!rtpReceiver) {
                throw new Error("RTCRtpReceiver not found");
              }
              this._rtpReceivers.delete(localId);
              try {
                logger.debug("stopReceiving() | calling rtpReceiver.stop()");
                rtpReceiver.stop();
              } catch (error) {
                logger.warn(
                  "stopReceiving() | rtpReceiver.stop() failed:%o",
                  error
                );
              }
            }
          }
          async pauseReceiving(
            // eslint-disable-next-line @typescript-eslint/no-unused-vars
            localIds
          ) {
            // Unimplemented.
          }
          async resumeReceiving(
            // eslint-disable-next-line @typescript-eslint/no-unused-vars
            localIds
          ) {
            // Unimplemented.
          }
          async getReceiverStats(localId) {
            const rtpReceiver = this._rtpReceivers.get(localId);
            if (!rtpReceiver) {
              throw new Error("RTCRtpReceiver not found");
            }
            return rtpReceiver.getStats();
          }
          async receiveDataChannel(
            // eslint-disable-next-line @typescript-eslint/no-unused-vars
            options
          ) {
            throw new errors_1.UnsupportedError("not implemented");
          }
          setIceGatherer({ iceServers, iceTransportPolicy }) {
            // @ts-ignore
            const iceGatherer = new RTCIceGatherer({
              iceServers: iceServers || [],
              gatherPolicy: iceTransportPolicy || "all",
            });
            iceGatherer.addEventListener("error", (event) => {
              logger.error('iceGatherer "error" event [event:%o]', event);
            });
            // NOTE: Not yet implemented by Edge, which starts gathering automatically.
            try {
              iceGatherer.gather();
            } catch (error) {
              logger.debug(
                "setIceGatherer() | iceGatherer.gather() failed: %s",
                error.toString()
              );
            }
            this._iceGatherer = iceGatherer;
          }
          setIceTransport() {
            const iceTransport = new RTCIceTransport(this._iceGatherer);
            // NOTE: Not yet implemented by Edge.
            iceTransport.addEventListener("statechange", () => {
              switch (iceTransport.state) {
                case "checking": {
                  this.emit("@connectionstatechange", "connecting");
                  break;
                }
                case "connected":
                case "completed": {
                  this.emit("@connectionstatechange", "connected");
                  break;
                }
                case "failed": {
                  this.emit("@connectionstatechange", "failed");
                  break;
                }
                case "disconnected": {
                  this.emit("@connectionstatechange", "disconnected");
                  break;
                }
                case "closed": {
                  this.emit("@connectionstatechange", "closed");
                  break;
                }
              }
            });
            // NOTE: Not standard, but implemented by Edge.
            iceTransport.addEventListener("icestatechange", () => {
              switch (iceTransport.state) {
                case "checking": {
                  this.emit("@connectionstatechange", "connecting");
                  break;
                }
                case "connected":
                case "completed": {
                  this.emit("@connectionstatechange", "connected");
                  break;
                }
                case "failed": {
                  this.emit("@connectionstatechange", "failed");
                  break;
                }
                case "disconnected": {
                  this.emit("@connectionstatechange", "disconnected");
                  break;
                }
                case "closed": {
                  this.emit("@connectionstatechange", "closed");
                  break;
                }
              }
            });
            iceTransport.addEventListener("candidatepairchange", (event) => {
              logger.debug(
                'iceTransport "candidatepairchange" event [pair:%o]',
                event.pair
              );
            });
            this._iceTransport = iceTransport;
          }
          setDtlsTransport() {
            const dtlsTransport = new RTCDtlsTransport(this._iceTransport);
            // NOTE: Not yet implemented by Edge.
            dtlsTransport.addEventListener("statechange", () => {
              logger.debug(
                'dtlsTransport "statechange" event [state:%s]',
                dtlsTransport.state
              );
            });
            // NOTE: Not standard, but implemented by Edge.
            dtlsTransport.addEventListener("dtlsstatechange", () => {
              logger.debug(
                'dtlsTransport "dtlsstatechange" event [state:%s]',
                dtlsTransport.state
              );
              if (dtlsTransport.state === "closed") {
                this.emit("@connectionstatechange", "closed");
              }
            });
            dtlsTransport.addEventListener("error", (event) => {
              logger.error('dtlsTransport "error" event [event:%o]', event);
            });
            this._dtlsTransport = dtlsTransport;
          }
          async setupTransport({ localDtlsRole }) {
            logger.debug("setupTransport()");
            // Get our local DTLS parameters.
            const dtlsParameters = this._dtlsTransport.getLocalParameters();
            dtlsParameters.role = localDtlsRole;
            // Need to tell the remote transport about our parameters.
            await new Promise((resolve, reject) => {
              this.safeEmit("@connect", { dtlsParameters }, resolve, reject);
            });
            // Start the RTCIceTransport.
            this._iceTransport.start(
              this._iceGatherer,
              this._remoteIceParameters,
              "controlling"
            );
            // Add remote ICE candidates.
            for (const candidate of this._remoteIceCandidates) {
              this._iceTransport.addRemoteCandidate(candidate);
            }
            // Also signal a 'complete' candidate as per spec.
            // NOTE: It should be {complete: true} but Edge prefers {}.
            // NOTE: If we don't signal end of candidates, the Edge RTCIceTransport
            // won't enter the 'completed' state.
            this._iceTransport.addRemoteCandidate({});
            // NOTE: Edge does not like SHA less than 256.
            this._remoteDtlsParameters.fingerprints =
              this._remoteDtlsParameters.fingerprints.filter((fingerprint) => {
                return (
                  fingerprint.algorithm === "sha-256" ||
                  fingerprint.algorithm === "sha-384" ||
                  fingerprint.algorithm === "sha-512"
                );
              });
            // Start the RTCDtlsTransport.
            this._dtlsTransport.start(this._remoteDtlsParameters);
            this._transportReady = true;
          }
        }
        exports.Edge11 = Edge11;
      },
      {
        "../Logger": 43,
        "../errors": 48,
        "../ortc": 69,
        "../utils": 72,
        "./HandlerInterface": 56,
        "./ortc/edgeUtils": 61,
      },
    ],
    55: [
      function (require, module, exports) {
        "use strict";
        var __createBinding =
          (this && this.__createBinding) ||
          (Object.create
            ? function (o, m, k, k2) {
                if (k2 === undefined) k2 = k;
                var desc = Object.getOwnPropertyDescriptor(m, k);
                if (
                  !desc ||
                  ("get" in desc
                    ? !m.__esModule
                    : desc.writable || desc.configurable)
                ) {
                  desc = {
                    enumerable: true,
                    get: function () {
                      return m[k];
                    },
                  };
                }
                Object.defineProperty(o, k2, desc);
              }
            : function (o, m, k, k2) {
                if (k2 === undefined) k2 = k;
                o[k2] = m[k];
              });
        var __setModuleDefault =
          (this && this.__setModuleDefault) ||
          (Object.create
            ? function (o, v) {
                Object.defineProperty(o, "default", {
                  enumerable: true,
                  value: v,
                });
              }
            : function (o, v) {
                o["default"] = v;
              });
        var __importStar =
          (this && this.__importStar) ||
          function (mod) {
            if (mod && mod.__esModule) return mod;
            var result = {};
            if (mod != null)
              for (var k in mod)
                if (
                  k !== "default" &&
                  Object.prototype.hasOwnProperty.call(mod, k)
                )
                  __createBinding(result, mod, k);
            __setModuleDefault(result, mod);
            return result;
          };
        Object.defineProperty(exports, "__esModule", { value: true });
        exports.Firefox60 = void 0;
        const sdpTransform = __importStar(require("sdp-transform"));
        const Logger_1 = require("../Logger");
        const errors_1 = require("../errors");
        const utils = __importStar(require("../utils"));
        const ortc = __importStar(require("../ortc"));
        const sdpCommonUtils = __importStar(require("./sdp/commonUtils"));
        const sdpUnifiedPlanUtils = __importStar(
          require("./sdp/unifiedPlanUtils")
        );
        const HandlerInterface_1 = require("./HandlerInterface");
        const RemoteSdp_1 = require("./sdp/RemoteSdp");
        const scalabilityModes_1 = require("../scalabilityModes");
        const logger = new Logger_1.Logger("Firefox60");
        const SCTP_NUM_STREAMS = { OS: 16, MIS: 2048 };
        class Firefox60 extends HandlerInterface_1.HandlerInterface {
          /**
           * Creates a factory function.
           */
          static createFactory() {
            return () => new Firefox60();
          }
          constructor() {
            super();
            // Closed flag.
            this._closed = false;
            // Map of RTCTransceivers indexed by MID.
            this._mapMidTransceiver = new Map();
            // Local stream for sending.
            this._sendStream = new MediaStream();
            // Whether a DataChannel m=application section has been created.
            this._hasDataChannelMediaSection = false;
            // Sending DataChannel id value counter. Incremented for each new DataChannel.
            this._nextSendSctpStreamId = 0;
            // Got transport local and remote parameters.
            this._transportReady = false;
          }
          get name() {
            return "Firefox60";
          }
          close() {
            logger.debug("close()");
            if (this._closed) {
              return;
            }
            this._closed = true;
            // Close RTCPeerConnection.
            if (this._pc) {
              try {
                this._pc.close();
              } catch (error) {}
            }
            this.emit("@close");
          }
          async getNativeRtpCapabilities() {
            logger.debug("getNativeRtpCapabilities()");
            const pc = new RTCPeerConnection({
              iceServers: [],
              iceTransportPolicy: "all",
              bundlePolicy: "max-bundle",
              rtcpMuxPolicy: "require",
            });
            // NOTE: We need to add a real video track to get the RID extension mapping.
            const canvas = document.createElement("canvas");
            // NOTE: Otherwise Firefox fails in next line.
            canvas.getContext("2d");
            const fakeStream = canvas.captureStream();
            const fakeVideoTrack = fakeStream.getVideoTracks()[0];
            try {
              pc.addTransceiver("audio", { direction: "sendrecv" });
              const videoTransceiver = pc.addTransceiver(fakeVideoTrack, {
                direction: "sendrecv",
              });
              const parameters = videoTransceiver.sender.getParameters();
              const encodings = [
                { rid: "r0", maxBitrate: 100000 },
                { rid: "r1", maxBitrate: 500000 },
              ];
              parameters.encodings = encodings;
              await videoTransceiver.sender.setParameters(parameters);
              const offer = await pc.createOffer();
              try {
                canvas.remove();
              } catch (error) {}
              try {
                fakeVideoTrack.stop();
              } catch (error) {}
              try {
                pc.close();
              } catch (error) {}
              const sdpObject = sdpTransform.parse(offer.sdp);
              const nativeRtpCapabilities =
                sdpCommonUtils.extractRtpCapabilities({
                  sdpObject,
                });
              return nativeRtpCapabilities;
            } catch (error) {
              try {
                canvas.remove();
              } catch (error2) {}
              try {
                fakeVideoTrack.stop();
              } catch (error2) {}
              try {
                pc.close();
              } catch (error2) {}
              throw error;
            }
          }
          async getNativeSctpCapabilities() {
            logger.debug("getNativeSctpCapabilities()");
            return {
              numStreams: SCTP_NUM_STREAMS,
            };
          }
          run({
            direction,
            iceParameters,
            iceCandidates,
            dtlsParameters,
            sctpParameters,
            iceServers,
            iceTransportPolicy,
            additionalSettings,
            proprietaryConstraints,
            extendedRtpCapabilities,
          }) {
            this.assertNotClosed();
            logger.debug("run()");
            this._direction = direction;
            this._remoteSdp = new RemoteSdp_1.RemoteSdp({
              iceParameters,
              iceCandidates,
              dtlsParameters,
              sctpParameters,
            });
            this._sendingRtpParametersByKind = {
              audio: ortc.getSendingRtpParameters(
                "audio",
                extendedRtpCapabilities
              ),
              video: ortc.getSendingRtpParameters(
                "video",
                extendedRtpCapabilities
              ),
            };
            this._sendingRemoteRtpParametersByKind = {
              audio: ortc.getSendingRemoteRtpParameters(
                "audio",
                extendedRtpCapabilities
              ),
              video: ortc.getSendingRemoteRtpParameters(
                "video",
                extendedRtpCapabilities
              ),
            };
            this._pc = new RTCPeerConnection(
              {
                iceServers: iceServers || [],
                iceTransportPolicy: iceTransportPolicy || "all",
                bundlePolicy: "max-bundle",
                rtcpMuxPolicy: "require",
                ...additionalSettings,
              },
              proprietaryConstraints
            );
            this._pc.addEventListener("icegatheringstatechange", () => {
              this.emit("@icegatheringstatechange", this._pc.iceGatheringState);
            });
            if (this._pc.connectionState) {
              this._pc.addEventListener("connectionstatechange", () => {
                this.emit("@connectionstatechange", this._pc.connectionState);
              });
            } else {
              this._pc.addEventListener("iceconnectionstatechange", () => {
                logger.warn(
                  "run() | pc.connectionState not supported, using pc.iceConnectionState"
                );
                switch (this._pc.iceConnectionState) {
                  case "checking": {
                    this.emit("@connectionstatechange", "connecting");
                    break;
                  }
                  case "connected":
                  case "completed": {
                    this.emit("@connectionstatechange", "connected");
                    break;
                  }
                  case "failed": {
                    this.emit("@connectionstatechange", "failed");
                    break;
                  }
                  case "disconnected": {
                    this.emit("@connectionstatechange", "disconnected");
                    break;
                  }
                  case "closed": {
                    this.emit("@connectionstatechange", "closed");
                    break;
                  }
                }
              });
            }
          }
          // eslint-disable-next-line @typescript-eslint/no-unused-vars
          async updateIceServers(iceServers) {
            this.assertNotClosed();
            // NOTE: Firefox does not implement pc.setConfiguration().
            throw new errors_1.UnsupportedError("not supported");
          }
          async restartIce(iceParameters) {
            this.assertNotClosed();
            logger.debug("restartIce()");
            // Provide the remote SDP handler with new remote ICE parameters.
            this._remoteSdp.updateIceParameters(iceParameters);
            if (!this._transportReady) {
              return;
            }
            if (this._direction === "send") {
              const offer = await this._pc.createOffer({ iceRestart: true });
              logger.debug(
                "restartIce() | calling pc.setLocalDescription() [offer:%o]",
                offer
              );
              await this._pc.setLocalDescription(offer);
              const answer = { type: "answer", sdp: this._remoteSdp.getSdp() };
              logger.debug(
                "restartIce() | calling pc.setRemoteDescription() [answer:%o]",
                answer
              );
              await this._pc.setRemoteDescription(answer);
            } else {
              const offer = { type: "offer", sdp: this._remoteSdp.getSdp() };
              logger.debug(
                "restartIce() | calling pc.setRemoteDescription() [offer:%o]",
                offer
              );
              await this._pc.setRemoteDescription(offer);
              const answer = await this._pc.createAnswer();
              logger.debug(
                "restartIce() | calling pc.setLocalDescription() [answer:%o]",
                answer
              );
              await this._pc.setLocalDescription(answer);
            }
          }
          async getTransportStats() {
            this.assertNotClosed();
            return this._pc.getStats();
          }
          async send({ track, encodings, codecOptions, codec }) {
            this.assertNotClosed();
            this.assertSendDirection();
            logger.debug("send() [kind:%s, track.id:%s]", track.kind, track.id);
            if (encodings) {
              encodings = utils.clone(encodings);
              if (encodings.length > 1) {
                encodings.forEach((encoding, idx) => {
                  encoding.rid = `r${idx}`;
                });
                // Clone the encodings and reverse them because Firefox likes them
                // from high to low.
                encodings.reverse();
              }
            }
            const sendingRtpParameters = utils.clone(
              this._sendingRtpParametersByKind[track.kind]
            );
            // This may throw.
            sendingRtpParameters.codecs = ortc.reduceCodecs(
              sendingRtpParameters.codecs,
              codec
            );
            const sendingRemoteRtpParameters = utils.clone(
              this._sendingRemoteRtpParametersByKind[track.kind]
            );
            // This may throw.
            sendingRemoteRtpParameters.codecs = ortc.reduceCodecs(
              sendingRemoteRtpParameters.codecs,
              codec
            );
            // NOTE: Firefox fails sometimes to properly anticipate the closed media
            // section that it should use, so don't reuse closed media sections.
            //   https://github.com/versatica/mediasoup-client/issues/104
            //
            // const mediaSectionIdx = this._remoteSdp!.getNextMediaSectionIdx();
            const transceiver = this._pc.addTransceiver(track, {
              direction: "sendonly",
              streams: [this._sendStream],
            });
            // NOTE: This is not spec compliants. Encodings should be given in addTransceiver
            // second argument, but Firefox does not support it.
            if (encodings) {
              const parameters = transceiver.sender.getParameters();
              parameters.encodings = encodings;
              await transceiver.sender.setParameters(parameters);
            }
            const offer = await this._pc.createOffer();
            let localSdpObject = sdpTransform.parse(offer.sdp);
            // In Firefox use DTLS role client even if we are the "offerer" since
            // Firefox does not respect ICE-Lite.
            if (!this._transportReady) {
              await this.setupTransport({
                localDtlsRole: "client",
                localSdpObject,
              });
            }
            const layers = (0, scalabilityModes_1.parse)(
              (encodings || [{}])[0].scalabilityMode
            );
            logger.debug(
              "send() | calling pc.setLocalDescription() [offer:%o]",
              offer
            );
            await this._pc.setLocalDescription(offer);
            // We can now get the transceiver.mid.
            const localId = transceiver.mid;
            // Set MID.
            sendingRtpParameters.mid = localId;
            localSdpObject = sdpTransform.parse(this._pc.localDescription.sdp);
            const offerMediaObject =
              localSdpObject.media[localSdpObject.media.length - 1];
            // Set RTCP CNAME.
            sendingRtpParameters.rtcp.cname = sdpCommonUtils.getCname({
              offerMediaObject,
            });
            // Set RTP encodings by parsing the SDP offer if no encodings are given.
            if (!encodings) {
              sendingRtpParameters.encodings =
                sdpUnifiedPlanUtils.getRtpEncodings({
                  offerMediaObject,
                });
            }
            // Set RTP encodings by parsing the SDP offer and complete them with given
            // one if just a single encoding has been given.
            else if (encodings.length === 1) {
              const newEncodings = sdpUnifiedPlanUtils.getRtpEncodings({
                offerMediaObject,
              });
              Object.assign(newEncodings[0], encodings[0]);
              sendingRtpParameters.encodings = newEncodings;
            }
            // Otherwise if more than 1 encoding are given use them verbatim (but
            // reverse them back since we reversed them above to satisfy Firefox).
            else {
              sendingRtpParameters.encodings = encodings.reverse();
            }
            // If VP8 or H264 and there is effective simulcast, add scalabilityMode to
            // each encoding.
            if (
              sendingRtpParameters.encodings.length > 1 &&
              (sendingRtpParameters.codecs[0].mimeType.toLowerCase() ===
                "video/vp8" ||
                sendingRtpParameters.codecs[0].mimeType.toLowerCase() ===
                  "video/h264")
            ) {
              for (const encoding of sendingRtpParameters.encodings) {
                if (encoding.scalabilityMode) {
                  encoding.scalabilityMode = `L1T${layers.temporalLayers}`;
                } else {
                  encoding.scalabilityMode = "L1T3";
                }
              }
            }
            this._remoteSdp.send({
              offerMediaObject,
              offerRtpParameters: sendingRtpParameters,
              answerRtpParameters: sendingRemoteRtpParameters,
              codecOptions,
              extmapAllowMixed: true,
            });
            const answer = { type: "answer", sdp: this._remoteSdp.getSdp() };
            logger.debug(
              "send() | calling pc.setRemoteDescription() [answer:%o]",
              answer
            );
            await this._pc.setRemoteDescription(answer);
            // Store in the map.
            this._mapMidTransceiver.set(localId, transceiver);
            return {
              localId,
              rtpParameters: sendingRtpParameters,
              rtpSender: transceiver.sender,
            };
          }
          async stopSending(localId) {
            this.assertSendDirection();
            logger.debug("stopSending() [localId:%s]", localId);
            if (this._closed) {
              return;
            }
            const transceiver = this._mapMidTransceiver.get(localId);
            if (!transceiver) {
              throw new Error("associated transceiver not found");
            }
            transceiver.sender.replaceTrack(null);
            // NOTE: Cannot use stop() the transceiver due to the the note above in
            // send() method.
            // try
            // {
            // 	transceiver.stop();
            // }
            // catch (error)
            // {}
            this._pc.removeTrack(transceiver.sender);
            // NOTE: Cannot use closeMediaSection() due to the the note above in send()
            // method.
            // this._remoteSdp!.closeMediaSection(transceiver.mid);
            this._remoteSdp.disableMediaSection(transceiver.mid);
            const offer = await this._pc.createOffer();
            logger.debug(
              "stopSending() | calling pc.setLocalDescription() [offer:%o]",
              offer
            );
            await this._pc.setLocalDescription(offer);
            const answer = { type: "answer", sdp: this._remoteSdp.getSdp() };
            logger.debug(
              "stopSending() | calling pc.setRemoteDescription() [answer:%o]",
              answer
            );
            await this._pc.setRemoteDescription(answer);
            this._mapMidTransceiver.delete(localId);
          }
          // eslint-disable-next-line @typescript-eslint/no-unused-vars
          async pauseSending(localId) {
            this.assertNotClosed();
            this.assertSendDirection();
            logger.debug("pauseSending() [localId:%s]", localId);
            const transceiver = this._mapMidTransceiver.get(localId);
            if (!transceiver) {
              throw new Error("associated RTCRtpTransceiver not found");
            }
            transceiver.direction = "inactive";
            this._remoteSdp.pauseMediaSection(localId);
            const offer = await this._pc.createOffer();
            logger.debug(
              "pauseSending() | calling pc.setLocalDescription() [offer:%o]",
              offer
            );
            await this._pc.setLocalDescription(offer);
            const answer = { type: "answer", sdp: this._remoteSdp.getSdp() };
            logger.debug(
              "pauseSending() | calling pc.setRemoteDescription() [answer:%o]",
              answer
            );
            await this._pc.setRemoteDescription(answer);
          }
          // eslint-disable-next-line @typescript-eslint/no-unused-vars
          async resumeSending(localId) {
            this.assertNotClosed();
            this.assertSendDirection();
            logger.debug("resumeSending() [localId:%s]", localId);
            const transceiver = this._mapMidTransceiver.get(localId);
            if (!transceiver) {
              throw new Error("associated RTCRtpTransceiver not found");
            }
            transceiver.direction = "sendonly";
            this._remoteSdp.resumeSendingMediaSection(localId);
            const offer = await this._pc.createOffer();
            logger.debug(
              "resumeSending() | calling pc.setLocalDescription() [offer:%o]",
              offer
            );
            await this._pc.setLocalDescription(offer);
            const answer = { type: "answer", sdp: this._remoteSdp.getSdp() };
            logger.debug(
              "resumeSending() | calling pc.setRemoteDescription() [answer:%o]",
              answer
            );
            await this._pc.setRemoteDescription(answer);
          }
          async replaceTrack(localId, track) {
            this.assertNotClosed();
            this.assertSendDirection();
            if (track) {
              logger.debug(
                "replaceTrack() [localId:%s, track.id:%s]",
                localId,
                track.id
              );
            } else {
              logger.debug("replaceTrack() [localId:%s, no track]", localId);
            }
            const transceiver = this._mapMidTransceiver.get(localId);
            if (!transceiver) {
              throw new Error("associated RTCRtpTransceiver not found");
            }
            await transceiver.sender.replaceTrack(track);
          }
          async setMaxSpatialLayer(localId, spatialLayer) {
            this.assertNotClosed();
            this.assertSendDirection();
            logger.debug(
              "setMaxSpatialLayer() [localId:%s, spatialLayer:%s]",
              localId,
              spatialLayer
            );
            const transceiver = this._mapMidTransceiver.get(localId);
            if (!transceiver) {
              throw new Error("associated transceiver not found");
            }
            const parameters = transceiver.sender.getParameters();
            // NOTE: We require encodings given from low to high, however Firefox
            // requires them in reverse order, so do magic here.
            spatialLayer = parameters.encodings.length - 1 - spatialLayer;
            parameters.encodings.forEach((encoding, idx) => {
              if (idx >= spatialLayer) {
                encoding.active = true;
              } else {
                encoding.active = false;
              }
            });
            await transceiver.sender.setParameters(parameters);
            this._remoteSdp.muxMediaSectionSimulcast(
              localId,
              parameters.encodings
            );
            const offer = await this._pc.createOffer();
            logger.debug(
              "setMaxSpatialLayer() | calling pc.setLocalDescription() [offer:%o]",
              offer
            );
            await this._pc.setLocalDescription(offer);
            const answer = { type: "answer", sdp: this._remoteSdp.getSdp() };
            logger.debug(
              "setMaxSpatialLayer() | calling pc.setRemoteDescription() [answer:%o]",
              answer
            );
            await this._pc.setRemoteDescription(answer);
          }
          async setRtpEncodingParameters(localId, params) {
            this.assertNotClosed();
            this.assertSendDirection();
            logger.debug(
              "setRtpEncodingParameters() [localId:%s, params:%o]",
              localId,
              params
            );
            const transceiver = this._mapMidTransceiver.get(localId);
            if (!transceiver) {
              throw new Error("associated RTCRtpTransceiver not found");
            }
            const parameters = transceiver.sender.getParameters();
            parameters.encodings.forEach((encoding, idx) => {
              parameters.encodings[idx] = { ...encoding, ...params };
            });
            await transceiver.sender.setParameters(parameters);
            this._remoteSdp.muxMediaSectionSimulcast(
              localId,
              parameters.encodings
            );
            const offer = await this._pc.createOffer();
            logger.debug(
              "setRtpEncodingParameters() | calling pc.setLocalDescription() [offer:%o]",
              offer
            );
            await this._pc.setLocalDescription(offer);
            const answer = { type: "answer", sdp: this._remoteSdp.getSdp() };
            logger.debug(
              "setRtpEncodingParameters() | calling pc.setRemoteDescription() [answer:%o]",
              answer
            );
            await this._pc.setRemoteDescription(answer);
          }
          async getSenderStats(localId) {
            this.assertNotClosed();
            this.assertSendDirection();
            const transceiver = this._mapMidTransceiver.get(localId);
            if (!transceiver) {
              throw new Error("associated RTCRtpTransceiver not found");
            }
            return transceiver.sender.getStats();
          }
          async sendDataChannel({
            ordered,
            maxPacketLifeTime,
            maxRetransmits,
            label,
            protocol,
          }) {
            this.assertNotClosed();
            this.assertSendDirection();
            const options = {
              negotiated: true,
              id: this._nextSendSctpStreamId,
              ordered,
              maxPacketLifeTime,
              maxRetransmits,
              protocol,
            };
            logger.debug("sendDataChannel() [options:%o]", options);
            const dataChannel = this._pc.createDataChannel(label, options);
            // Increase next id.
            this._nextSendSctpStreamId =
              ++this._nextSendSctpStreamId % SCTP_NUM_STREAMS.MIS;
            // If this is the first DataChannel we need to create the SDP answer with
            // m=application section.
            if (!this._hasDataChannelMediaSection) {
              const offer = await this._pc.createOffer();
              const localSdpObject = sdpTransform.parse(offer.sdp);
              const offerMediaObject = localSdpObject.media.find(
                (m) => m.type === "application"
              );
              if (!this._transportReady) {
                await this.setupTransport({
                  localDtlsRole: "client",
                  localSdpObject,
                });
              }
              logger.debug(
                "sendDataChannel() | calling pc.setLocalDescription() [offer:%o]",
                offer
              );
              await this._pc.setLocalDescription(offer);
              this._remoteSdp.sendSctpAssociation({ offerMediaObject });
              const answer = { type: "answer", sdp: this._remoteSdp.getSdp() };
              logger.debug(
                "sendDataChannel() | calling pc.setRemoteDescription() [answer:%o]",
                answer
              );
              await this._pc.setRemoteDescription(answer);
              this._hasDataChannelMediaSection = true;
            }
            const sctpStreamParameters = {
              streamId: options.id,
              ordered: options.ordered,
              maxPacketLifeTime: options.maxPacketLifeTime,
              maxRetransmits: options.maxRetransmits,
            };
            return { dataChannel, sctpStreamParameters };
          }
          async receive(
            // eslint-disable-next-line @typescript-eslint/no-unused-vars
            optionsList
          ) {
            this.assertNotClosed();
            this.assertRecvDirection();
            const results = [];
            const mapLocalId = new Map();
            for (const options of optionsList) {
              const { trackId, kind, rtpParameters, streamId } = options;
              logger.debug("receive() [trackId:%s, kind:%s]", trackId, kind);
              const localId =
                rtpParameters.mid || String(this._mapMidTransceiver.size);
              mapLocalId.set(trackId, localId);
              this._remoteSdp.receive({
                mid: localId,
                kind,
                offerRtpParameters: rtpParameters,
                streamId: streamId || rtpParameters.rtcp.cname,
                trackId,
              });
            }
            const offer = { type: "offer", sdp: this._remoteSdp.getSdp() };
            logger.debug(
              "receive() | calling pc.setRemoteDescription() [offer:%o]",
              offer
            );
            await this._pc.setRemoteDescription(offer);
            let answer = await this._pc.createAnswer();
            const localSdpObject = sdpTransform.parse(answer.sdp);
            for (const options of optionsList) {
              const { trackId, rtpParameters } = options;
              const localId = mapLocalId.get(trackId);
              const answerMediaObject = localSdpObject.media.find(
                (m) => String(m.mid) === localId
              );
              // May need to modify codec parameters in the answer based on codec
              // parameters in the offer.
              sdpCommonUtils.applyCodecParameters({
                offerRtpParameters: rtpParameters,
                answerMediaObject,
              });
              answer = {
                type: "answer",
                sdp: sdpTransform.write(localSdpObject),
              };
            }
            if (!this._transportReady) {
              await this.setupTransport({
                localDtlsRole: "client",
                localSdpObject,
              });
            }
            logger.debug(
              "receive() | calling pc.setLocalDescription() [answer:%o]",
              answer
            );
            await this._pc.setLocalDescription(answer);
            for (const options of optionsList) {
              const { trackId } = options;
              const localId = mapLocalId.get(trackId);
              const transceiver = this._pc
                .getTransceivers()
                .find((t) => t.mid === localId);
              if (!transceiver) {
                throw new Error("new RTCRtpTransceiver not found");
              }
              // Store in the map.
              this._mapMidTransceiver.set(localId, transceiver);
              results.push({
                localId,
                track: transceiver.receiver.track,
                rtpReceiver: transceiver.receiver,
              });
            }
            return results;
          }
          async stopReceiving(localIds) {
            this.assertRecvDirection();
            if (this._closed) {
              return;
            }
            for (const localId of localIds) {
              logger.debug("stopReceiving() [localId:%s]", localId);
              const transceiver = this._mapMidTransceiver.get(localId);
              if (!transceiver) {
                throw new Error("associated RTCRtpTransceiver not found");
              }
              this._remoteSdp.closeMediaSection(transceiver.mid);
            }
            const offer = { type: "offer", sdp: this._remoteSdp.getSdp() };
            logger.debug(
              "stopReceiving() | calling pc.setRemoteDescription() [offer:%o]",
              offer
            );
            await this._pc.setRemoteDescription(offer);
            const answer = await this._pc.createAnswer();
            logger.debug(
              "stopReceiving() | calling pc.setLocalDescription() [answer:%o]",
              answer
            );
            await this._pc.setLocalDescription(answer);
            for (const localId of localIds) {
              this._mapMidTransceiver.delete(localId);
            }
          }
          async pauseReceiving(localIds) {
            this.assertNotClosed();
            this.assertRecvDirection();
            for (const localId of localIds) {
              logger.debug("pauseReceiving() [localId:%s]", localId);
              const transceiver = this._mapMidTransceiver.get(localId);
              if (!transceiver) {
                throw new Error("associated RTCRtpTransceiver not found");
              }
              transceiver.direction = "inactive";
              this._remoteSdp.pauseMediaSection(localId);
            }
            const offer = { type: "offer", sdp: this._remoteSdp.getSdp() };
            logger.debug(
              "pauseReceiving() | calling pc.setRemoteDescription() [offer:%o]",
              offer
            );
            await this._pc.setRemoteDescription(offer);
            const answer = await this._pc.createAnswer();
            logger.debug(
              "pauseReceiving() | calling pc.setLocalDescription() [answer:%o]",
              answer
            );
            await this._pc.setLocalDescription(answer);
          }
          async resumeReceiving(localIds) {
            this.assertNotClosed();
            this.assertRecvDirection();
            for (const localId of localIds) {
              logger.debug("resumeReceiving() [localId:%s]", localId);
              const transceiver = this._mapMidTransceiver.get(localId);
              if (!transceiver) {
                throw new Error("associated RTCRtpTransceiver not found");
              }
              transceiver.direction = "recvonly";
              this._remoteSdp.resumeReceivingMediaSection(localId);
            }
            const offer = { type: "offer", sdp: this._remoteSdp.getSdp() };
            logger.debug(
              "resumeReceiving() | calling pc.setRemoteDescription() [offer:%o]",
              offer
            );
            await this._pc.setRemoteDescription(offer);
            const answer = await this._pc.createAnswer();
            logger.debug(
              "resumeReceiving() | calling pc.setLocalDescription() [answer:%o]",
              answer
            );
            await this._pc.setLocalDescription(answer);
          }
          async getReceiverStats(localId) {
            this.assertRecvDirection();
            const transceiver = this._mapMidTransceiver.get(localId);
            if (!transceiver) {
              throw new Error("associated RTCRtpTransceiver not found");
            }
            return transceiver.receiver.getStats();
          }
          async receiveDataChannel({ sctpStreamParameters, label, protocol }) {
            this.assertNotClosed();
            this.assertRecvDirection();
            const { streamId, ordered, maxPacketLifeTime, maxRetransmits } =
              sctpStreamParameters;
            const options = {
              negotiated: true,
              id: streamId,
              ordered,
              maxPacketLifeTime,
              maxRetransmits,
              protocol,
            };
            logger.debug("receiveDataChannel() [options:%o]", options);
            const dataChannel = this._pc.createDataChannel(label, options);
            // If this is the first DataChannel we need to create the SDP offer with
            // m=application section.
            if (!this._hasDataChannelMediaSection) {
              this._remoteSdp.receiveSctpAssociation();
              const offer = { type: "offer", sdp: this._remoteSdp.getSdp() };
              logger.debug(
                "receiveDataChannel() | calling pc.setRemoteDescription() [offer:%o]",
                offer
              );
              await this._pc.setRemoteDescription(offer);
              const answer = await this._pc.createAnswer();
              if (!this._transportReady) {
                const localSdpObject = sdpTransform.parse(answer.sdp);
                await this.setupTransport({
                  localDtlsRole: "client",
                  localSdpObject,
                });
              }
              logger.debug(
                "receiveDataChannel() | calling pc.setRemoteDescription() [answer:%o]",
                answer
              );
              await this._pc.setLocalDescription(answer);
              this._hasDataChannelMediaSection = true;
            }
            return { dataChannel };
          }
          async setupTransport({ localDtlsRole, localSdpObject }) {
            if (!localSdpObject) {
              localSdpObject = sdpTransform.parse(
                this._pc.localDescription.sdp
              );
            }
            // Get our local DTLS parameters.
            const dtlsParameters = sdpCommonUtils.extractDtlsParameters({
              sdpObject: localSdpObject,
            });
            // Set our DTLS role.
            dtlsParameters.role = localDtlsRole;
            // Update the remote DTLS role in the SDP.
            this._remoteSdp.updateDtlsRole(
              localDtlsRole === "client" ? "server" : "client"
            );
            // Need to tell the remote transport about our parameters.
            await new Promise((resolve, reject) => {
              this.safeEmit("@connect", { dtlsParameters }, resolve, reject);
            });
            this._transportReady = true;
          }
          assertNotClosed() {
            if (this._closed) {
              throw new errors_1.InvalidStateError(
                "method called in a closed handler"
              );
            }
          }
          assertSendDirection() {
            if (this._direction !== "send") {
              throw new Error(
                'method can just be called for handlers with "send" direction'
              );
            }
          }
          assertRecvDirection() {
            if (this._direction !== "recv") {
              throw new Error(
                'method can just be called for handlers with "recv" direction'
              );
            }
          }
        }
        exports.Firefox60 = Firefox60;
      },
      {
        "../Logger": 43,
        "../errors": 48,
        "../ortc": 69,
        "../scalabilityModes": 70,
        "../utils": 72,
        "./HandlerInterface": 56,
        "./sdp/RemoteSdp": 64,
        "./sdp/commonUtils": 65,
        "./sdp/unifiedPlanUtils": 67,
        "sdp-transform": 79,
      },
    ],
    56: [
      function (require, module, exports) {
        "use strict";
        Object.defineProperty(exports, "__esModule", { value: true });
        exports.HandlerInterface = void 0;
        const EnhancedEventEmitter_1 = require("../EnhancedEventEmitter");
        class HandlerInterface extends EnhancedEventEmitter_1.EnhancedEventEmitter {
          constructor() {
            super();
          }
        }
        exports.HandlerInterface = HandlerInterface;
      },
      { "../EnhancedEventEmitter": 42 },
    ],
    57: [
      function (require, module, exports) {
        "use strict";
        var __createBinding =
          (this && this.__createBinding) ||
          (Object.create
            ? function (o, m, k, k2) {
                if (k2 === undefined) k2 = k;
                var desc = Object.getOwnPropertyDescriptor(m, k);
                if (
                  !desc ||
                  ("get" in desc
                    ? !m.__esModule
                    : desc.writable || desc.configurable)
                ) {
                  desc = {
                    enumerable: true,
                    get: function () {
                      return m[k];
                    },
                  };
                }
                Object.defineProperty(o, k2, desc);
              }
            : function (o, m, k, k2) {
                if (k2 === undefined) k2 = k;
                o[k2] = m[k];
              });
        var __setModuleDefault =
          (this && this.__setModuleDefault) ||
          (Object.create
            ? function (o, v) {
                Object.defineProperty(o, "default", {
                  enumerable: true,
                  value: v,
                });
              }
            : function (o, v) {
                o["default"] = v;
              });
        var __importStar =
          (this && this.__importStar) ||
          function (mod) {
            if (mod && mod.__esModule) return mod;
            var result = {};
            if (mod != null)
              for (var k in mod)
                if (
                  k !== "default" &&
                  Object.prototype.hasOwnProperty.call(mod, k)
                )
                  __createBinding(result, mod, k);
            __setModuleDefault(result, mod);
            return result;
          };
        Object.defineProperty(exports, "__esModule", { value: true });
        exports.ReactNative = void 0;
        const sdpTransform = __importStar(require("sdp-transform"));
        const Logger_1 = require("../Logger");
        const errors_1 = require("../errors");
        const utils = __importStar(require("../utils"));
        const ortc = __importStar(require("../ortc"));
        const sdpCommonUtils = __importStar(require("./sdp/commonUtils"));
        const sdpPlanBUtils = __importStar(require("./sdp/planBUtils"));
        const HandlerInterface_1 = require("./HandlerInterface");
        const RemoteSdp_1 = require("./sdp/RemoteSdp");
        const logger = new Logger_1.Logger("ReactNative");
        const SCTP_NUM_STREAMS = { OS: 1024, MIS: 1024 };
        class ReactNative extends HandlerInterface_1.HandlerInterface {
          /**
           * Creates a factory function.
           */
          static createFactory() {
            return () => new ReactNative();
          }
          constructor() {
            super();
            // Local stream for sending.
            this._sendStream = new MediaStream();
            // Map of sending MediaStreamTracks indexed by localId.
            this._mapSendLocalIdTrack = new Map();
            // Next sending localId.
            this._nextSendLocalId = 0;
            // Map of MID, RTP parameters and RTCRtpReceiver indexed by local id.
            // Value is an Object with mid, rtpParameters and rtpReceiver.
            this._mapRecvLocalIdInfo = new Map();
            // Whether a DataChannel m=application section has been created.
            this._hasDataChannelMediaSection = false;
            // Sending DataChannel id value counter. Incremented for each new DataChannel.
            this._nextSendSctpStreamId = 0;
            // Got transport local and remote parameters.
            this._transportReady = false;
          }
          get name() {
            return "ReactNative";
          }
          close() {
            logger.debug("close()");
            // Free/dispose native MediaStream but DO NOT free/dispose native
            // MediaStreamTracks (that is parent's business).
            // @ts-ignore (proprietary API in react-native-webrtc).
            this._sendStream.release(/* releaseTracks */ false);
            // Close RTCPeerConnection.
            if (this._pc) {
              try {
                this._pc.close();
              } catch (error) {}
            }
            this.emit("@close");
          }
          async getNativeRtpCapabilities() {
            logger.debug("getNativeRtpCapabilities()");
            const pc = new RTCPeerConnection({
              iceServers: [],
              iceTransportPolicy: "all",
              bundlePolicy: "max-bundle",
              rtcpMuxPolicy: "require",
              sdpSemantics: "plan-b",
            });
            try {
              const offer = await pc.createOffer({
                offerToReceiveAudio: true,
                offerToReceiveVideo: true,
              });
              try {
                pc.close();
              } catch (error) {}
              const sdpObject = sdpTransform.parse(offer.sdp);
              const nativeRtpCapabilities =
                sdpCommonUtils.extractRtpCapabilities({
                  sdpObject,
                });
              return nativeRtpCapabilities;
            } catch (error) {
              try {
                pc.close();
              } catch (error2) {}
              throw error;
            }
          }
          async getNativeSctpCapabilities() {
            logger.debug("getNativeSctpCapabilities()");
            return {
              numStreams: SCTP_NUM_STREAMS,
            };
          }
          run({
            direction,
            iceParameters,
            iceCandidates,
            dtlsParameters,
            sctpParameters,
            iceServers,
            iceTransportPolicy,
            additionalSettings,
            proprietaryConstraints,
            extendedRtpCapabilities,
          }) {
            logger.debug("run()");
            this._direction = direction;
            this._remoteSdp = new RemoteSdp_1.RemoteSdp({
              iceParameters,
              iceCandidates,
              dtlsParameters,
              sctpParameters,
              planB: true,
            });
            this._sendingRtpParametersByKind = {
              audio: ortc.getSendingRtpParameters(
                "audio",
                extendedRtpCapabilities
              ),
              video: ortc.getSendingRtpParameters(
                "video",
                extendedRtpCapabilities
              ),
            };
            this._sendingRemoteRtpParametersByKind = {
              audio: ortc.getSendingRemoteRtpParameters(
                "audio",
                extendedRtpCapabilities
              ),
              video: ortc.getSendingRemoteRtpParameters(
                "video",
                extendedRtpCapabilities
              ),
            };
            if (dtlsParameters.role && dtlsParameters.role !== "auto") {
              this._forcedLocalDtlsRole =
                dtlsParameters.role === "server" ? "client" : "server";
            }
            this._pc = new RTCPeerConnection(
              {
                iceServers: iceServers || [],
                iceTransportPolicy: iceTransportPolicy || "all",
                bundlePolicy: "max-bundle",
                rtcpMuxPolicy: "require",
                sdpSemantics: "plan-b",
                ...additionalSettings,
              },
              proprietaryConstraints
            );
            this._pc.addEventListener("icegatheringstatechange", () => {
              this.emit("@icegatheringstatechange", this._pc.iceGatheringState);
            });
            if (this._pc.connectionState) {
              this._pc.addEventListener("connectionstatechange", () => {
                this.emit("@connectionstatechange", this._pc.connectionState);
              });
            } else {
              this._pc.addEventListener("iceconnectionstatechange", () => {
                logger.warn(
                  "run() | pc.connectionState not supported, using pc.iceConnectionState"
                );
                switch (this._pc.iceConnectionState) {
                  case "checking": {
                    this.emit("@connectionstatechange", "connecting");
                    break;
                  }
                  case "connected":
                  case "completed": {
                    this.emit("@connectionstatechange", "connected");
                    break;
                  }
                  case "failed": {
                    this.emit("@connectionstatechange", "failed");
                    break;
                  }
                  case "disconnected": {
                    this.emit("@connectionstatechange", "disconnected");
                    break;
                  }
                  case "closed": {
                    this.emit("@connectionstatechange", "closed");
                    break;
                  }
                }
              });
            }
          }
          async updateIceServers(iceServers) {
            logger.debug("updateIceServers()");
            const configuration = this._pc.getConfiguration();
            configuration.iceServers = iceServers;
            this._pc.setConfiguration(configuration);
          }
          async restartIce(iceParameters) {
            logger.debug("restartIce()");
            // Provide the remote SDP handler with new remote ICE parameters.
            this._remoteSdp.updateIceParameters(iceParameters);
            if (!this._transportReady) {
              return;
            }
            if (this._direction === "send") {
              const offer = await this._pc.createOffer({ iceRestart: true });
              logger.debug(
                "restartIce() | calling pc.setLocalDescription() [offer:%o]",
                offer
              );
              await this._pc.setLocalDescription(offer);
              const answer = { type: "answer", sdp: this._remoteSdp.getSdp() };
              logger.debug(
                "restartIce() | calling pc.setRemoteDescription() [answer:%o]",
                answer
              );
              await this._pc.setRemoteDescription(answer);
            } else {
              const offer = { type: "offer", sdp: this._remoteSdp.getSdp() };
              logger.debug(
                "restartIce() | calling pc.setRemoteDescription() [offer:%o]",
                offer
              );
              await this._pc.setRemoteDescription(offer);
              const answer = await this._pc.createAnswer();
              logger.debug(
                "restartIce() | calling pc.setLocalDescription() [answer:%o]",
                answer
              );
              await this._pc.setLocalDescription(answer);
            }
          }
          async getTransportStats() {
            return this._pc.getStats();
          }
          async send({ track, encodings, codecOptions, codec }) {
            this.assertSendDirection();
            logger.debug("send() [kind:%s, track.id:%s]", track.kind, track.id);
            if (codec) {
              logger.warn(
                "send() | codec selection is not available in %s handler",
                this.name
              );
            }
            this._sendStream.addTrack(track);
            this._pc.addStream(this._sendStream);
            let offer = await this._pc.createOffer();
            let localSdpObject = sdpTransform.parse(offer.sdp);
            let offerMediaObject;
            const sendingRtpParameters = utils.clone(
              this._sendingRtpParametersByKind[track.kind]
            );
            sendingRtpParameters.codecs = ortc.reduceCodecs(
              sendingRtpParameters.codecs
            );
            const sendingRemoteRtpParameters = utils.clone(
              this._sendingRemoteRtpParametersByKind[track.kind]
            );
            sendingRemoteRtpParameters.codecs = ortc.reduceCodecs(
              sendingRemoteRtpParameters.codecs
            );
            if (!this._transportReady) {
              await this.setupTransport({
                localDtlsRole: this._forcedLocalDtlsRole ?? "client",
                localSdpObject,
              });
            }
            if (track.kind === "video" && encodings && encodings.length > 1) {
              logger.debug("send() | enabling simulcast");
              localSdpObject = sdpTransform.parse(offer.sdp);
              offerMediaObject = localSdpObject.media.find(
                (m) => m.type === "video"
              );
              sdpPlanBUtils.addLegacySimulcast({
                offerMediaObject,
                track,
                numStreams: encodings.length,
              });
              offer = {
                type: "offer",
                sdp: sdpTransform.write(localSdpObject),
              };
            }
            logger.debug(
              "send() | calling pc.setLocalDescription() [offer:%o]",
              offer
            );
            await this._pc.setLocalDescription(offer);
            localSdpObject = sdpTransform.parse(this._pc.localDescription.sdp);
            offerMediaObject = localSdpObject.media.find(
              (m) => m.type === track.kind
            );
            // Set RTCP CNAME.
            sendingRtpParameters.rtcp.cname = sdpCommonUtils.getCname({
              offerMediaObject,
            });
            // Set RTP encodings.
            sendingRtpParameters.encodings = sdpPlanBUtils.getRtpEncodings({
              offerMediaObject,
              track,
            });
            // Complete encodings with given values.
            if (encodings) {
              for (
                let idx = 0;
                idx < sendingRtpParameters.encodings.length;
                ++idx
              ) {
                if (encodings[idx]) {
                  Object.assign(
                    sendingRtpParameters.encodings[idx],
                    encodings[idx]
                  );
                }
              }
            }
            // If VP8 or H264 and there is effective simulcast, add scalabilityMode to
            // each encoding.
            if (
              sendingRtpParameters.encodings.length > 1 &&
              (sendingRtpParameters.codecs[0].mimeType.toLowerCase() ===
                "video/vp8" ||
                sendingRtpParameters.codecs[0].mimeType.toLowerCase() ===
                  "video/h264")
            ) {
              for (const encoding of sendingRtpParameters.encodings) {
                encoding.scalabilityMode = "L1T3";
              }
            }
            this._remoteSdp.send({
              offerMediaObject,
              offerRtpParameters: sendingRtpParameters,
              answerRtpParameters: sendingRemoteRtpParameters,
              codecOptions,
            });
            const answer = { type: "answer", sdp: this._remoteSdp.getSdp() };
            logger.debug(
              "send() | calling pc.setRemoteDescription() [answer:%o]",
              answer
            );
            await this._pc.setRemoteDescription(answer);
            const localId = String(this._nextSendLocalId);
            this._nextSendLocalId++;
            // Insert into the map.
            this._mapSendLocalIdTrack.set(localId, track);
            return {
              localId: localId,
              rtpParameters: sendingRtpParameters,
            };
          }
          async stopSending(localId) {
            this.assertSendDirection();
            logger.debug("stopSending() [localId:%s]", localId);
            const track = this._mapSendLocalIdTrack.get(localId);
            if (!track) {
              throw new Error("track not found");
            }
            this._mapSendLocalIdTrack.delete(localId);
            this._sendStream.removeTrack(track);
            this._pc.addStream(this._sendStream);
            const offer = await this._pc.createOffer();
            logger.debug(
              "stopSending() | calling pc.setLocalDescription() [offer:%o]",
              offer
            );
            try {
              await this._pc.setLocalDescription(offer);
            } catch (error) {
              // NOTE: If there are no sending tracks, setLocalDescription() will fail with
              // "Failed to create channels". If so, ignore it.
              if (this._sendStream.getTracks().length === 0) {
                logger.warn(
                  "stopSending() | ignoring expected error due no sending tracks: %s",
                  error.toString()
                );
                return;
              }
              throw error;
            }
            if (this._pc.signalingState === "stable") {
              return;
            }
            const answer = { type: "answer", sdp: this._remoteSdp.getSdp() };
            logger.debug(
              "stopSending() | calling pc.setRemoteDescription() [answer:%o]",
              answer
            );
            await this._pc.setRemoteDescription(answer);
          }
          // eslint-disable-next-line @typescript-eslint/no-unused-vars
          async pauseSending(localId) {
            // Unimplemented.
          }
          // eslint-disable-next-line @typescript-eslint/no-unused-vars
          async resumeSending(localId) {
            // Unimplemented.
          }
          async replaceTrack(
            // eslint-disable-next-line @typescript-eslint/no-unused-vars
            localId,
            // eslint-disable-next-line @typescript-eslint/no-unused-vars
            track
          ) {
            throw new errors_1.UnsupportedError("not implemented");
          }
          async setMaxSpatialLayer(
            // eslint-disable-next-line @typescript-eslint/no-unused-vars
            localId,
            // eslint-disable-next-line @typescript-eslint/no-unused-vars
            spatialLayer
          ) {
            throw new errors_1.UnsupportedError("not implemented");
          }
          // eslint-disable-next-line @typescript-eslint/no-unused-vars
          async setRtpEncodingParameters(localId, params) {
            throw new errors_1.UnsupportedError("not implemented");
          }
          // eslint-disable-next-line @typescript-eslint/no-unused-vars
          async getSenderStats(localId) {
            throw new errors_1.UnsupportedError("not implemented");
          }
          async sendDataChannel({
            ordered,
            maxPacketLifeTime,
            maxRetransmits,
            label,
            protocol,
          }) {
            this.assertSendDirection();
            const options = {
              negotiated: true,
              id: this._nextSendSctpStreamId,
              ordered,
              maxPacketLifeTime,
              maxRetransmitTime: maxPacketLifeTime, // NOTE: Old spec.
              maxRetransmits,
              protocol,
            };
            logger.debug("sendDataChannel() [options:%o]", options);
            const dataChannel = this._pc.createDataChannel(label, options);
            // Increase next id.
            this._nextSendSctpStreamId =
              ++this._nextSendSctpStreamId % SCTP_NUM_STREAMS.MIS;
            // If this is the first DataChannel we need to create the SDP answer with
            // m=application section.
            if (!this._hasDataChannelMediaSection) {
              const offer = await this._pc.createOffer();
              const localSdpObject = sdpTransform.parse(offer.sdp);
              const offerMediaObject = localSdpObject.media.find(
                (m) => m.type === "application"
              );
              if (!this._transportReady) {
                await this.setupTransport({
                  localDtlsRole: this._forcedLocalDtlsRole ?? "client",
                  localSdpObject,
                });
              }
              logger.debug(
                "sendDataChannel() | calling pc.setLocalDescription() [offer:%o]",
                offer
              );
              await this._pc.setLocalDescription(offer);
              this._remoteSdp.sendSctpAssociation({ offerMediaObject });
              const answer = { type: "answer", sdp: this._remoteSdp.getSdp() };
              logger.debug(
                "sendDataChannel() | calling pc.setRemoteDescription() [answer:%o]",
                answer
              );
              await this._pc.setRemoteDescription(answer);
              this._hasDataChannelMediaSection = true;
            }
            const sctpStreamParameters = {
              streamId: options.id,
              ordered: options.ordered,
              maxPacketLifeTime: options.maxPacketLifeTime,
              maxRetransmits: options.maxRetransmits,
            };
            return { dataChannel, sctpStreamParameters };
          }
          async receive(optionsList) {
            this.assertRecvDirection();
            const results = [];
            const mapStreamId = new Map();
            for (const options of optionsList) {
              const { trackId, kind, rtpParameters } = options;
              logger.debug("receive() [trackId:%s, kind:%s]", trackId, kind);
              const mid = kind;
              let streamId = options.streamId || rtpParameters.rtcp.cname;
              // NOTE: In React-Native we cannot reuse the same remote MediaStream for new
              // remote tracks. This is because react-native-webrtc does not react on new
              // tracks generated within already existing streams, so force the streamId
              // to be different. See:
              // https://github.com/react-native-webrtc/react-native-webrtc/issues/401
              logger.debug(
                "receive() | forcing a random remote streamId to avoid well known bug in react-native-webrtc"
              );
              streamId += `-hack-${utils.generateRandomNumber()}`;
              mapStreamId.set(trackId, streamId);
              this._remoteSdp.receive({
                mid,
                kind,
                offerRtpParameters: rtpParameters,
                streamId,
                trackId,
              });
            }
            const offer = { type: "offer", sdp: this._remoteSdp.getSdp() };
            logger.debug(
              "receive() | calling pc.setRemoteDescription() [offer:%o]",
              offer
            );
            await this._pc.setRemoteDescription(offer);
            let answer = await this._pc.createAnswer();
            const localSdpObject = sdpTransform.parse(answer.sdp);
            for (const options of optionsList) {
              const { kind, rtpParameters } = options;
              const mid = kind;
              const answerMediaObject = localSdpObject.media.find(
                (m) => String(m.mid) === mid
              );
              // May need to modify codec parameters in the answer based on codec
              // parameters in the offer.
              sdpCommonUtils.applyCodecParameters({
                offerRtpParameters: rtpParameters,
                answerMediaObject,
              });
            }
            answer = {
              type: "answer",
              sdp: sdpTransform.write(localSdpObject),
            };
            if (!this._transportReady) {
              await this.setupTransport({
                localDtlsRole: this._forcedLocalDtlsRole ?? "client",
                localSdpObject,
              });
            }
            logger.debug(
              "receive() | calling pc.setLocalDescription() [answer:%o]",
              answer
            );
            await this._pc.setLocalDescription(answer);
            for (const options of optionsList) {
              const { kind, trackId, rtpParameters } = options;
              const localId = trackId;
              const mid = kind;
              const streamId = mapStreamId.get(trackId);
              const stream = this._pc
                .getRemoteStreams()
                .find((s) => s.id === streamId);
              const track = stream.getTrackById(localId);
              if (!track) {
                throw new Error("remote track not found");
              }
              // Insert into the map.
              this._mapRecvLocalIdInfo.set(localId, { mid, rtpParameters });
              results.push({ localId, track });
            }
            return results;
          }
          async stopReceiving(localIds) {
            this.assertRecvDirection();
            for (const localId of localIds) {
              logger.debug("stopReceiving() [localId:%s]", localId);
              const { mid, rtpParameters } =
                this._mapRecvLocalIdInfo.get(localId) || {};
              // Remove from the map.
              this._mapRecvLocalIdInfo.delete(localId);
              this._remoteSdp.planBStopReceiving({
                mid: mid,
                offerRtpParameters: rtpParameters,
              });
            }
            const offer = { type: "offer", sdp: this._remoteSdp.getSdp() };
            logger.debug(
              "stopReceiving() | calling pc.setRemoteDescription() [offer:%o]",
              offer
            );
            await this._pc.setRemoteDescription(offer);
            const answer = await this._pc.createAnswer();
            logger.debug(
              "stopReceiving() | calling pc.setLocalDescription() [answer:%o]",
              answer
            );
            await this._pc.setLocalDescription(answer);
          }
          async pauseReceiving(
            // eslint-disable-next-line @typescript-eslint/no-unused-vars
            localIds
          ) {
            // Unimplemented.
          }
          async resumeReceiving(
            // eslint-disable-next-line @typescript-eslint/no-unused-vars
            localIds
          ) {
            // Unimplemented.
          }
          // eslint-disable-next-line @typescript-eslint/no-unused-vars
          async getReceiverStats(localId) {
            throw new errors_1.UnsupportedError("not implemented");
          }
          async receiveDataChannel({ sctpStreamParameters, label, protocol }) {
            this.assertRecvDirection();
            const { streamId, ordered, maxPacketLifeTime, maxRetransmits } =
              sctpStreamParameters;
            const options = {
              negotiated: true,
              id: streamId,
              ordered,
              maxPacketLifeTime,
              maxRetransmitTime: maxPacketLifeTime, // NOTE: Old spec.
              maxRetransmits,
              protocol,
            };
            logger.debug("receiveDataChannel() [options:%o]", options);
            const dataChannel = this._pc.createDataChannel(label, options);
            // If this is the first DataChannel we need to create the SDP offer with
            // m=application section.
            if (!this._hasDataChannelMediaSection) {
              this._remoteSdp.receiveSctpAssociation({
                oldDataChannelSpec: true,
              });
              const offer = { type: "offer", sdp: this._remoteSdp.getSdp() };
              logger.debug(
                "receiveDataChannel() | calling pc.setRemoteDescription() [offer:%o]",
                offer
              );
              await this._pc.setRemoteDescription(offer);
              const answer = await this._pc.createAnswer();
              if (!this._transportReady) {
                const localSdpObject = sdpTransform.parse(answer.sdp);
                await this.setupTransport({
                  localDtlsRole: this._forcedLocalDtlsRole ?? "client",
                  localSdpObject,
                });
              }
              logger.debug(
                "receiveDataChannel() | calling pc.setRemoteDescription() [answer:%o]",
                answer
              );
              await this._pc.setLocalDescription(answer);
              this._hasDataChannelMediaSection = true;
            }
            return { dataChannel };
          }
          async setupTransport({ localDtlsRole, localSdpObject }) {
            if (!localSdpObject) {
              localSdpObject = sdpTransform.parse(
                this._pc.localDescription.sdp
              );
            }
            // Get our local DTLS parameters.
            const dtlsParameters = sdpCommonUtils.extractDtlsParameters({
              sdpObject: localSdpObject,
            });
            // Set our DTLS role.
            dtlsParameters.role = localDtlsRole;
            // Update the remote DTLS role in the SDP.
            this._remoteSdp.updateDtlsRole(
              localDtlsRole === "client" ? "server" : "client"
            );
            // Need to tell the remote transport about our parameters.
            await new Promise((resolve, reject) => {
              this.safeEmit("@connect", { dtlsParameters }, resolve, reject);
            });
            this._transportReady = true;
          }
          assertSendDirection() {
            if (this._direction !== "send") {
              throw new Error(
                'method can just be called for handlers with "send" direction'
              );
            }
          }
          assertRecvDirection() {
            if (this._direction !== "recv") {
              throw new Error(
                'method can just be called for handlers with "recv" direction'
              );
            }
          }
        }
        exports.ReactNative = ReactNative;
      },
      {
        "../Logger": 43,
        "../errors": 48,
        "../ortc": 69,
        "../utils": 72,
        "./HandlerInterface": 56,
        "./sdp/RemoteSdp": 64,
        "./sdp/commonUtils": 65,
        "./sdp/planBUtils": 66,
        "sdp-transform": 79,
      },
    ],
    58: [
      function (require, module, exports) {
        "use strict";
        var __createBinding =
          (this && this.__createBinding) ||
          (Object.create
            ? function (o, m, k, k2) {
                if (k2 === undefined) k2 = k;
                var desc = Object.getOwnPropertyDescriptor(m, k);
                if (
                  !desc ||
                  ("get" in desc
                    ? !m.__esModule
                    : desc.writable || desc.configurable)
                ) {
                  desc = {
                    enumerable: true,
                    get: function () {
                      return m[k];
                    },
                  };
                }
                Object.defineProperty(o, k2, desc);
              }
            : function (o, m, k, k2) {
                if (k2 === undefined) k2 = k;
                o[k2] = m[k];
              });
        var __setModuleDefault =
          (this && this.__setModuleDefault) ||
          (Object.create
            ? function (o, v) {
                Object.defineProperty(o, "default", {
                  enumerable: true,
                  value: v,
                });
              }
            : function (o, v) {
                o["default"] = v;
              });
        var __importStar =
          (this && this.__importStar) ||
          function (mod) {
            if (mod && mod.__esModule) return mod;
            var result = {};
            if (mod != null)
              for (var k in mod)
                if (
                  k !== "default" &&
                  Object.prototype.hasOwnProperty.call(mod, k)
                )
                  __createBinding(result, mod, k);
            __setModuleDefault(result, mod);
            return result;
          };
        Object.defineProperty(exports, "__esModule", { value: true });
        exports.ReactNativeUnifiedPlan = void 0;
        const sdpTransform = __importStar(require("sdp-transform"));
        const Logger_1 = require("../Logger");
        const utils = __importStar(require("../utils"));
        const ortc = __importStar(require("../ortc"));
        const sdpCommonUtils = __importStar(require("./sdp/commonUtils"));
        const sdpUnifiedPlanUtils = __importStar(
          require("./sdp/unifiedPlanUtils")
        );
        const ortcUtils = __importStar(require("./ortc/utils"));
        const errors_1 = require("../errors");
        const HandlerInterface_1 = require("./HandlerInterface");
        const RemoteSdp_1 = require("./sdp/RemoteSdp");
        const scalabilityModes_1 = require("../scalabilityModes");
        const logger = new Logger_1.Logger("ReactNativeUnifiedPlan");
        const SCTP_NUM_STREAMS = { OS: 1024, MIS: 1024 };
        class ReactNativeUnifiedPlan extends HandlerInterface_1.HandlerInterface {
          /**
           * Creates a factory function.
           */
          static createFactory() {
            return () => new ReactNativeUnifiedPlan();
          }
          constructor() {
            super();
            // Closed flag.
            this._closed = false;
            // Map of RTCTransceivers indexed by MID.
            this._mapMidTransceiver = new Map();
            // Local stream for sending.
            this._sendStream = new MediaStream();
            // Whether a DataChannel m=application section has been created.
            this._hasDataChannelMediaSection = false;
            // Sending DataChannel id value counter. Incremented for each new DataChannel.
            this._nextSendSctpStreamId = 0;
            // Got transport local and remote parameters.
            this._transportReady = false;
          }
          get name() {
            return "ReactNativeUnifiedPlan";
          }
          close() {
            logger.debug("close()");
            if (this._closed) {
              return;
            }
            this._closed = true;
            // Free/dispose native MediaStream but DO NOT free/dispose native
            // MediaStreamTracks (that is parent's business).
            // @ts-ignore (proprietary API in react-native-webrtc).
            this._sendStream.release(/* releaseTracks */ false);
            // Close RTCPeerConnection.
            if (this._pc) {
              try {
                this._pc.close();
              } catch (error) {}
            }
            this.emit("@close");
          }
          async getNativeRtpCapabilities() {
            logger.debug("getNativeRtpCapabilities()");
            const pc = new RTCPeerConnection({
              iceServers: [],
              iceTransportPolicy: "all",
              bundlePolicy: "max-bundle",
              rtcpMuxPolicy: "require",
              sdpSemantics: "unified-plan",
            });
            try {
              pc.addTransceiver("audio");
              pc.addTransceiver("video");
              const offer = await pc.createOffer();
              try {
                pc.close();
              } catch (error) {}
              const sdpObject = sdpTransform.parse(offer.sdp);
              const nativeRtpCapabilities =
                sdpCommonUtils.extractRtpCapabilities({
                  sdpObject,
                });
              // libwebrtc supports NACK for OPUS but doesn't announce it.
              ortcUtils.addNackSuppportForOpus(nativeRtpCapabilities);
              return nativeRtpCapabilities;
            } catch (error) {
              try {
                pc.close();
              } catch (error2) {}
              throw error;
            }
          }
          async getNativeSctpCapabilities() {
            logger.debug("getNativeSctpCapabilities()");
            return {
              numStreams: SCTP_NUM_STREAMS,
            };
          }
          run({
            direction,
            iceParameters,
            iceCandidates,
            dtlsParameters,
            sctpParameters,
            iceServers,
            iceTransportPolicy,
            additionalSettings,
            proprietaryConstraints,
            extendedRtpCapabilities,
          }) {
            this.assertNotClosed();
            logger.debug("run()");
            this._direction = direction;
            this._remoteSdp = new RemoteSdp_1.RemoteSdp({
              iceParameters,
              iceCandidates,
              dtlsParameters,
              sctpParameters,
            });
            this._sendingRtpParametersByKind = {
              audio: ortc.getSendingRtpParameters(
                "audio",
                extendedRtpCapabilities
              ),
              video: ortc.getSendingRtpParameters(
                "video",
                extendedRtpCapabilities
              ),
            };
            this._sendingRemoteRtpParametersByKind = {
              audio: ortc.getSendingRemoteRtpParameters(
                "audio",
                extendedRtpCapabilities
              ),
              video: ortc.getSendingRemoteRtpParameters(
                "video",
                extendedRtpCapabilities
              ),
            };
            if (dtlsParameters.role && dtlsParameters.role !== "auto") {
              this._forcedLocalDtlsRole =
                dtlsParameters.role === "server" ? "client" : "server";
            }
            this._pc = new RTCPeerConnection(
              {
                iceServers: iceServers || [],
                iceTransportPolicy: iceTransportPolicy || "all",
                bundlePolicy: "max-bundle",
                rtcpMuxPolicy: "require",
                sdpSemantics: "unified-plan",
                ...additionalSettings,
              },
              proprietaryConstraints
            );
            this._pc.addEventListener("icegatheringstatechange", () => {
              this.emit("@icegatheringstatechange", this._pc.iceGatheringState);
            });
            if (this._pc.connectionState) {
              this._pc.addEventListener("connectionstatechange", () => {
                this.emit("@connectionstatechange", this._pc.connectionState);
              });
            } else {
              this._pc.addEventListener("iceconnectionstatechange", () => {
                logger.warn(
                  "run() | pc.connectionState not supported, using pc.iceConnectionState"
                );
                switch (this._pc.iceConnectionState) {
                  case "checking": {
                    this.emit("@connectionstatechange", "connecting");
                    break;
                  }
                  case "connected":
                  case "completed": {
                    this.emit("@connectionstatechange", "connected");
                    break;
                  }
                  case "failed": {
                    this.emit("@connectionstatechange", "failed");
                    break;
                  }
                  case "disconnected": {
                    this.emit("@connectionstatechange", "disconnected");
                    break;
                  }
                  case "closed": {
                    this.emit("@connectionstatechange", "closed");
                    break;
                  }
                }
              });
            }
          }
          async updateIceServers(iceServers) {
            this.assertNotClosed();
            logger.debug("updateIceServers()");
            const configuration = this._pc.getConfiguration();
            configuration.iceServers = iceServers;
            this._pc.setConfiguration(configuration);
          }
          async restartIce(iceParameters) {
            this.assertNotClosed();
            logger.debug("restartIce()");
            // Provide the remote SDP handler with new remote ICE parameters.
            this._remoteSdp.updateIceParameters(iceParameters);
            if (!this._transportReady) {
              return;
            }
            if (this._direction === "send") {
              const offer = await this._pc.createOffer({ iceRestart: true });
              logger.debug(
                "restartIce() | calling pc.setLocalDescription() [offer:%o]",
                offer
              );
              await this._pc.setLocalDescription(offer);
              const answer = { type: "answer", sdp: this._remoteSdp.getSdp() };
              logger.debug(
                "restartIce() | calling pc.setRemoteDescription() [answer:%o]",
                answer
              );
              await this._pc.setRemoteDescription(answer);
            } else {
              const offer = { type: "offer", sdp: this._remoteSdp.getSdp() };
              logger.debug(
                "restartIce() | calling pc.setRemoteDescription() [offer:%o]",
                offer
              );
              await this._pc.setRemoteDescription(offer);
              const answer = await this._pc.createAnswer();
              logger.debug(
                "restartIce() | calling pc.setLocalDescription() [answer:%o]",
                answer
              );
              await this._pc.setLocalDescription(answer);
            }
          }
          async getTransportStats() {
            this.assertNotClosed();
            return this._pc.getStats();
          }
          async send({ track, encodings, codecOptions, codec }) {
            this.assertNotClosed();
            this.assertSendDirection();
            logger.debug("send() [kind:%s, track.id:%s]", track.kind, track.id);
            if (encodings && encodings.length > 1) {
              encodings.forEach((encoding, idx) => {
                encoding.rid = `r${idx}`;
              });
            }
            const sendingRtpParameters = utils.clone(
              this._sendingRtpParametersByKind[track.kind]
            );
            // This may throw.
            sendingRtpParameters.codecs = ortc.reduceCodecs(
              sendingRtpParameters.codecs,
              codec
            );
            const sendingRemoteRtpParameters = utils.clone(
              this._sendingRemoteRtpParametersByKind[track.kind]
            );
            // This may throw.
            sendingRemoteRtpParameters.codecs = ortc.reduceCodecs(
              sendingRemoteRtpParameters.codecs,
              codec
            );
            const mediaSectionIdx = this._remoteSdp.getNextMediaSectionIdx();
            const transceiver = this._pc.addTransceiver(track, {
              direction: "sendonly",
              streams: [this._sendStream],
              sendEncodings: encodings,
            });
            let offer = await this._pc.createOffer();
            let localSdpObject = sdpTransform.parse(offer.sdp);
            let offerMediaObject;
            if (!this._transportReady) {
              await this.setupTransport({
                localDtlsRole: this._forcedLocalDtlsRole ?? "client",
                localSdpObject,
              });
            }
            // Special case for VP9 with SVC.
            let hackVp9Svc = false;
            const layers = (0, scalabilityModes_1.parse)(
              (encodings || [{}])[0].scalabilityMode
            );
            if (
              encodings &&
              encodings.length === 1 &&
              layers.spatialLayers > 1 &&
              sendingRtpParameters.codecs[0].mimeType.toLowerCase() ===
                "video/vp9"
            ) {
              logger.debug("send() | enabling legacy simulcast for VP9 SVC");
              hackVp9Svc = true;
              localSdpObject = sdpTransform.parse(offer.sdp);
              offerMediaObject = localSdpObject.media[mediaSectionIdx.idx];
              sdpUnifiedPlanUtils.addLegacySimulcast({
                offerMediaObject,
                numStreams: layers.spatialLayers,
              });
              offer = {
                type: "offer",
                sdp: sdpTransform.write(localSdpObject),
              };
            }
            logger.debug(
              "send() | calling pc.setLocalDescription() [offer:%o]",
              offer
            );
            await this._pc.setLocalDescription(offer);
            // We can now get the transceiver.mid.
            // NOTE: We cannot read generated MID on iOS react-native-webrtc 111.0.0
            // because transceiver.mid is not available until setRemoteDescription()
            // is called, so this is best effort.
            // Issue: https://github.com/react-native-webrtc/react-native-webrtc/issues/1404
            // NOTE: So let's fill MID in sendingRtpParameters later.
            // NOTE: This is fixed in react-native-webrtc 111.0.3.
            let localId = transceiver.mid ?? undefined;
            if (!localId) {
              logger.warn(
                "send() | missing transceiver.mid (bug in react-native-webrtc, using a workaround"
              );
            }
            // Set MID.
            // NOTE: As per above, it could be unset yet.
            sendingRtpParameters.mid = localId;
            localSdpObject = sdpTransform.parse(this._pc.localDescription.sdp);
            offerMediaObject = localSdpObject.media[mediaSectionIdx.idx];
            // Set RTCP CNAME.
            sendingRtpParameters.rtcp.cname = sdpCommonUtils.getCname({
              offerMediaObject,
            });
            // Set RTP encodings by parsing the SDP offer if no encodings are given.
            if (!encodings) {
              sendingRtpParameters.encodings =
                sdpUnifiedPlanUtils.getRtpEncodings({
                  offerMediaObject,
                });
            }
            // Set RTP encodings by parsing the SDP offer and complete them with given
            // one if just a single encoding has been given.
            else if (encodings.length === 1) {
              let newEncodings = sdpUnifiedPlanUtils.getRtpEncodings({
                offerMediaObject,
              });
              Object.assign(newEncodings[0], encodings[0]);
              // Hack for VP9 SVC.
              if (hackVp9Svc) {
                newEncodings = [newEncodings[0]];
              }
              sendingRtpParameters.encodings = newEncodings;
            }
            // Otherwise if more than 1 encoding are given use them verbatim.
            else {
              sendingRtpParameters.encodings = encodings;
            }
            // If VP8 or H264 and there is effective simulcast, add scalabilityMode to
            // each encoding.
            if (
              sendingRtpParameters.encodings.length > 1 &&
              (sendingRtpParameters.codecs[0].mimeType.toLowerCase() ===
                "video/vp8" ||
                sendingRtpParameters.codecs[0].mimeType.toLowerCase() ===
                  "video/h264")
            ) {
              for (const encoding of sendingRtpParameters.encodings) {
                if (encoding.scalabilityMode) {
                  encoding.scalabilityMode = `L1T${layers.temporalLayers}`;
                } else {
                  encoding.scalabilityMode = "L1T3";
                }
              }
            }
            this._remoteSdp.send({
              offerMediaObject,
              reuseMid: mediaSectionIdx.reuseMid,
              offerRtpParameters: sendingRtpParameters,
              answerRtpParameters: sendingRemoteRtpParameters,
              codecOptions,
              extmapAllowMixed: true,
            });
            const answer = { type: "answer", sdp: this._remoteSdp.getSdp() };
            logger.debug(
              "send() | calling pc.setRemoteDescription() [answer:%o]",
              answer
            );
            await this._pc.setRemoteDescription(answer);
            // Follow up of iOS react-native-webrtc 111.0.0 issue told above. Now yes,
            // we can read generated MID (if not done above) and fill sendingRtpParameters.
            // NOTE: This is fixed in react-native-webrtc 111.0.3 so this block isn't
            // needed starting from that version.
            if (!localId) {
              localId = transceiver.mid;
              sendingRtpParameters.mid = localId;
            }
            // Store in the map.
            this._mapMidTransceiver.set(localId, transceiver);
            return {
              localId,
              rtpParameters: sendingRtpParameters,
              rtpSender: transceiver.sender,
            };
          }
          async stopSending(localId) {
            this.assertSendDirection();
            if (this._closed) {
              return;
            }
            logger.debug("stopSending() [localId:%s]", localId);
            const transceiver = this._mapMidTransceiver.get(localId);
            if (!transceiver) {
              throw new Error("associated RTCRtpTransceiver not found");
            }
            transceiver.sender.replaceTrack(null);
            this._pc.removeTrack(transceiver.sender);
            const mediaSectionClosed = this._remoteSdp.closeMediaSection(
              transceiver.mid
            );
            if (mediaSectionClosed) {
              try {
                transceiver.stop();
              } catch (error) {}
            }
            const offer = await this._pc.createOffer();
            logger.debug(
              "stopSending() | calling pc.setLocalDescription() [offer:%o]",
              offer
            );
            await this._pc.setLocalDescription(offer);
            const answer = { type: "answer", sdp: this._remoteSdp.getSdp() };
            logger.debug(
              "stopSending() | calling pc.setRemoteDescription() [answer:%o]",
              answer
            );
            await this._pc.setRemoteDescription(answer);
            this._mapMidTransceiver.delete(localId);
          }
          async pauseSending(localId) {
            this.assertNotClosed();
            this.assertSendDirection();
            logger.debug("pauseSending() [localId:%s]", localId);
            const transceiver = this._mapMidTransceiver.get(localId);
            if (!transceiver) {
              throw new Error("associated RTCRtpTransceiver not found");
            }
            transceiver.direction = "inactive";
            this._remoteSdp.pauseMediaSection(localId);
            const offer = await this._pc.createOffer();
            logger.debug(
              "pauseSending() | calling pc.setLocalDescription() [offer:%o]",
              offer
            );
            await this._pc.setLocalDescription(offer);
            const answer = { type: "answer", sdp: this._remoteSdp.getSdp() };
            logger.debug(
              "pauseSending() | calling pc.setRemoteDescription() [answer:%o]",
              answer
            );
            await this._pc.setRemoteDescription(answer);
          }
          async resumeSending(localId) {
            this.assertNotClosed();
            this.assertSendDirection();
            logger.debug("resumeSending() [localId:%s]", localId);
            const transceiver = this._mapMidTransceiver.get(localId);
            this._remoteSdp.resumeSendingMediaSection(localId);
            if (!transceiver) {
              throw new Error("associated RTCRtpTransceiver not found");
            }
            transceiver.direction = "sendonly";
            const offer = await this._pc.createOffer();
            logger.debug(
              "resumeSending() | calling pc.setLocalDescription() [offer:%o]",
              offer
            );
            await this._pc.setLocalDescription(offer);
            const answer = { type: "answer", sdp: this._remoteSdp.getSdp() };
            logger.debug(
              "resumeSending() | calling pc.setRemoteDescription() [answer:%o]",
              answer
            );
            await this._pc.setRemoteDescription(answer);
          }
          async replaceTrack(localId, track) {
            this.assertNotClosed();
            this.assertSendDirection();
            if (track) {
              logger.debug(
                "replaceTrack() [localId:%s, track.id:%s]",
                localId,
                track.id
              );
            } else {
              logger.debug("replaceTrack() [localId:%s, no track]", localId);
            }
            const transceiver = this._mapMidTransceiver.get(localId);
            if (!transceiver) {
              throw new Error("associated RTCRtpTransceiver not found");
            }
            await transceiver.sender.replaceTrack(track);
          }
          async setMaxSpatialLayer(localId, spatialLayer) {
            this.assertNotClosed();
            this.assertSendDirection();
            logger.debug(
              "setMaxSpatialLayer() [localId:%s, spatialLayer:%s]",
              localId,
              spatialLayer
            );
            const transceiver = this._mapMidTransceiver.get(localId);
            if (!transceiver) {
              throw new Error("associated RTCRtpTransceiver not found");
            }
            const parameters = transceiver.sender.getParameters();
            parameters.encodings.forEach((encoding, idx) => {
              if (idx <= spatialLayer) {
                encoding.active = true;
              } else {
                encoding.active = false;
              }
            });
            await transceiver.sender.setParameters(parameters);
            this._remoteSdp.muxMediaSectionSimulcast(
              localId,
              parameters.encodings
            );
            const offer = await this._pc.createOffer();
            logger.debug(
              "setMaxSpatialLayer() | calling pc.setLocalDescription() [offer:%o]",
              offer
            );
            await this._pc.setLocalDescription(offer);
            const answer = { type: "answer", sdp: this._remoteSdp.getSdp() };
            logger.debug(
              "setMaxSpatialLayer() | calling pc.setRemoteDescription() [answer:%o]",
              answer
            );
            await this._pc.setRemoteDescription(answer);
          }
          async setRtpEncodingParameters(localId, params) {
            this.assertNotClosed();
            this.assertSendDirection();
            logger.debug(
              "setRtpEncodingParameters() [localId:%s, params:%o]",
              localId,
              params
            );
            const transceiver = this._mapMidTransceiver.get(localId);
            if (!transceiver) {
              throw new Error("associated RTCRtpTransceiver not found");
            }
            const parameters = transceiver.sender.getParameters();
            parameters.encodings.forEach((encoding, idx) => {
              parameters.encodings[idx] = { ...encoding, ...params };
            });
            await transceiver.sender.setParameters(parameters);
            this._remoteSdp.muxMediaSectionSimulcast(
              localId,
              parameters.encodings
            );
            const offer = await this._pc.createOffer();
            logger.debug(
              "setRtpEncodingParameters() | calling pc.setLocalDescription() [offer:%o]",
              offer
            );
            await this._pc.setLocalDescription(offer);
            const answer = { type: "answer", sdp: this._remoteSdp.getSdp() };
            logger.debug(
              "setRtpEncodingParameters() | calling pc.setRemoteDescription() [answer:%o]",
              answer
            );
            await this._pc.setRemoteDescription(answer);
          }
          async getSenderStats(localId) {
            this.assertNotClosed();
            this.assertSendDirection();
            const transceiver = this._mapMidTransceiver.get(localId);
            if (!transceiver) {
              throw new Error("associated RTCRtpTransceiver not found");
            }
            return transceiver.sender.getStats();
          }
          async sendDataChannel({
            ordered,
            maxPacketLifeTime,
            maxRetransmits,
            label,
            protocol,
          }) {
            this.assertNotClosed();
            this.assertSendDirection();
            const options = {
              negotiated: true,
              id: this._nextSendSctpStreamId,
              ordered,
              maxPacketLifeTime,
              maxRetransmits,
              protocol,
            };
            logger.debug("sendDataChannel() [options:%o]", options);
            const dataChannel = this._pc.createDataChannel(label, options);
            // Increase next id.
            this._nextSendSctpStreamId =
              ++this._nextSendSctpStreamId % SCTP_NUM_STREAMS.MIS;
            // If this is the first DataChannel we need to create the SDP answer with
            // m=application section.
            if (!this._hasDataChannelMediaSection) {
              const offer = await this._pc.createOffer();
              const localSdpObject = sdpTransform.parse(offer.sdp);
              const offerMediaObject = localSdpObject.media.find(
                (m) => m.type === "application"
              );
              if (!this._transportReady) {
                await this.setupTransport({
                  localDtlsRole: this._forcedLocalDtlsRole ?? "client",
                  localSdpObject,
                });
              }
              logger.debug(
                "sendDataChannel() | calling pc.setLocalDescription() [offer:%o]",
                offer
              );
              await this._pc.setLocalDescription(offer);
              this._remoteSdp.sendSctpAssociation({ offerMediaObject });
              const answer = { type: "answer", sdp: this._remoteSdp.getSdp() };
              logger.debug(
                "sendDataChannel() | calling pc.setRemoteDescription() [answer:%o]",
                answer
              );
              await this._pc.setRemoteDescription(answer);
              this._hasDataChannelMediaSection = true;
            }
            const sctpStreamParameters = {
              streamId: options.id,
              ordered: options.ordered,
              maxPacketLifeTime: options.maxPacketLifeTime,
              maxRetransmits: options.maxRetransmits,
            };
            return { dataChannel, sctpStreamParameters };
          }
          async receive(optionsList) {
            this.assertNotClosed();
            this.assertRecvDirection();
            const results = [];
            const mapLocalId = new Map();
            for (const options of optionsList) {
              const { trackId, kind, rtpParameters, streamId } = options;
              logger.debug("receive() [trackId:%s, kind:%s]", trackId, kind);
              const localId =
                rtpParameters.mid || String(this._mapMidTransceiver.size);
              mapLocalId.set(trackId, localId);
              this._remoteSdp.receive({
                mid: localId,
                kind,
                offerRtpParameters: rtpParameters,
                streamId: streamId || rtpParameters.rtcp.cname,
                trackId,
              });
            }
            const offer = { type: "offer", sdp: this._remoteSdp.getSdp() };
            logger.debug(
              "receive() | calling pc.setRemoteDescription() [offer:%o]",
              offer
            );
            await this._pc.setRemoteDescription(offer);
            let answer = await this._pc.createAnswer();
            const localSdpObject = sdpTransform.parse(answer.sdp);
            for (const options of optionsList) {
              const { trackId, rtpParameters } = options;
              const localId = mapLocalId.get(trackId);
              const answerMediaObject = localSdpObject.media.find(
                (m) => String(m.mid) === localId
              );
              // May need to modify codec parameters in the answer based on codec
              // parameters in the offer.
              sdpCommonUtils.applyCodecParameters({
                offerRtpParameters: rtpParameters,
                answerMediaObject,
              });
            }
            answer = {
              type: "answer",
              sdp: sdpTransform.write(localSdpObject),
            };
            if (!this._transportReady) {
              await this.setupTransport({
                localDtlsRole: this._forcedLocalDtlsRole ?? "client",
                localSdpObject,
              });
            }
            logger.debug(
              "receive() | calling pc.setLocalDescription() [answer:%o]",
              answer
            );
            await this._pc.setLocalDescription(answer);
            for (const options of optionsList) {
              const { trackId } = options;
              const localId = mapLocalId.get(trackId);
              const transceiver = this._pc
                .getTransceivers()
                .find((t) => t.mid === localId);
              if (!transceiver) {
                throw new Error("new RTCRtpTransceiver not found");
              } else {
                // Store in the map.
                this._mapMidTransceiver.set(localId, transceiver);
                results.push({
                  localId,
                  track: transceiver.receiver.track,
                  rtpReceiver: transceiver.receiver,
                });
              }
            }
            return results;
          }
          async stopReceiving(localIds) {
            this.assertRecvDirection();
            if (this._closed) {
              return;
            }
            for (const localId of localIds) {
              logger.debug("stopReceiving() [localId:%s]", localId);
              const transceiver = this._mapMidTransceiver.get(localId);
              if (!transceiver) {
                throw new Error("associated RTCRtpTransceiver not found");
              }
              this._remoteSdp.closeMediaSection(transceiver.mid);
            }
            const offer = { type: "offer", sdp: this._remoteSdp.getSdp() };
            logger.debug(
              "stopReceiving() | calling pc.setRemoteDescription() [offer:%o]",
              offer
            );
            await this._pc.setRemoteDescription(offer);
            const answer = await this._pc.createAnswer();
            logger.debug(
              "stopReceiving() | calling pc.setLocalDescription() [answer:%o]",
              answer
            );
            await this._pc.setLocalDescription(answer);
            for (const localId of localIds) {
              this._mapMidTransceiver.delete(localId);
            }
          }
          async pauseReceiving(localIds) {
            this.assertNotClosed();
            this.assertRecvDirection();
            for (const localId of localIds) {
              logger.debug("pauseReceiving() [localId:%s]", localId);
              const transceiver = this._mapMidTransceiver.get(localId);
              if (!transceiver) {
                throw new Error("associated RTCRtpTransceiver not found");
              }
              transceiver.direction = "inactive";
              this._remoteSdp.pauseMediaSection(localId);
            }
            const offer = { type: "offer", sdp: this._remoteSdp.getSdp() };
            logger.debug(
              "pauseReceiving() | calling pc.setRemoteDescription() [offer:%o]",
              offer
            );
            await this._pc.setRemoteDescription(offer);
            const answer = await this._pc.createAnswer();
            logger.debug(
              "pauseReceiving() | calling pc.setLocalDescription() [answer:%o]",
              answer
            );
            await this._pc.setLocalDescription(answer);
          }
          async resumeReceiving(localIds) {
            this.assertNotClosed();
            this.assertRecvDirection();
            for (const localId of localIds) {
              logger.debug("resumeReceiving() [localId:%s]", localId);
              const transceiver = this._mapMidTransceiver.get(localId);
              if (!transceiver) {
                throw new Error("associated RTCRtpTransceiver not found");
              }
              transceiver.direction = "recvonly";
              this._remoteSdp.resumeReceivingMediaSection(localId);
            }
            const offer = { type: "offer", sdp: this._remoteSdp.getSdp() };
            logger.debug(
              "resumeReceiving() | calling pc.setRemoteDescription() [offer:%o]",
              offer
            );
            await this._pc.setRemoteDescription(offer);
            const answer = await this._pc.createAnswer();
            logger.debug(
              "resumeReceiving() | calling pc.setLocalDescription() [answer:%o]",
              answer
            );
            await this._pc.setLocalDescription(answer);
          }
          async getReceiverStats(localId) {
            this.assertNotClosed();
            this.assertRecvDirection();
            const transceiver = this._mapMidTransceiver.get(localId);
            if (!transceiver) {
              throw new Error("associated RTCRtpTransceiver not found");
            }
            return transceiver.receiver.getStats();
          }
          async receiveDataChannel({ sctpStreamParameters, label, protocol }) {
            this.assertNotClosed();
            this.assertRecvDirection();
            const { streamId, ordered, maxPacketLifeTime, maxRetransmits } =
              sctpStreamParameters;
            const options = {
              negotiated: true,
              id: streamId,
              ordered,
              maxPacketLifeTime,
              maxRetransmits,
              protocol,
            };
            logger.debug("receiveDataChannel() [options:%o]", options);
            const dataChannel = this._pc.createDataChannel(label, options);
            // If this is the first DataChannel we need to create the SDP offer with
            // m=application section.
            if (!this._hasDataChannelMediaSection) {
              this._remoteSdp.receiveSctpAssociation();
              const offer = { type: "offer", sdp: this._remoteSdp.getSdp() };
              logger.debug(
                "receiveDataChannel() | calling pc.setRemoteDescription() [offer:%o]",
                offer
              );
              await this._pc.setRemoteDescription(offer);
              const answer = await this._pc.createAnswer();
              if (!this._transportReady) {
                const localSdpObject = sdpTransform.parse(answer.sdp);
                await this.setupTransport({
                  localDtlsRole: this._forcedLocalDtlsRole ?? "client",
                  localSdpObject,
                });
              }
              logger.debug(
                "receiveDataChannel() | calling pc.setRemoteDescription() [answer:%o]",
                answer
              );
              await this._pc.setLocalDescription(answer);
              this._hasDataChannelMediaSection = true;
            }
            return { dataChannel };
          }
          async setupTransport({ localDtlsRole, localSdpObject }) {
            if (!localSdpObject) {
              localSdpObject = sdpTransform.parse(
                this._pc.localDescription.sdp
              );
            }
            // Get our local DTLS parameters.
            const dtlsParameters = sdpCommonUtils.extractDtlsParameters({
              sdpObject: localSdpObject,
            });
            // Set our DTLS role.
            dtlsParameters.role = localDtlsRole;
            // Update the remote DTLS role in the SDP.
            this._remoteSdp.updateDtlsRole(
              localDtlsRole === "client" ? "server" : "client"
            );
            // Need to tell the remote transport about our parameters.
            await new Promise((resolve, reject) => {
              this.safeEmit("@connect", { dtlsParameters }, resolve, reject);
            });
            this._transportReady = true;
          }
          assertNotClosed() {
            if (this._closed) {
              throw new errors_1.InvalidStateError(
                "method called in a closed handler"
              );
            }
          }
          assertSendDirection() {
            if (this._direction !== "send") {
              throw new Error(
                'method can just be called for handlers with "send" direction'
              );
            }
          }
          assertRecvDirection() {
            if (this._direction !== "recv") {
              throw new Error(
                'method can just be called for handlers with "recv" direction'
              );
            }
          }
        }
        exports.ReactNativeUnifiedPlan = ReactNativeUnifiedPlan;
      },
      {
        "../Logger": 43,
        "../errors": 48,
        "../ortc": 69,
        "../scalabilityModes": 70,
        "../utils": 72,
        "./HandlerInterface": 56,
        "./ortc/utils": 62,
        "./sdp/RemoteSdp": 64,
        "./sdp/commonUtils": 65,
        "./sdp/unifiedPlanUtils": 67,
        "sdp-transform": 79,
      },
    ],
    59: [
      function (require, module, exports) {
        "use strict";
        var __createBinding =
          (this && this.__createBinding) ||
          (Object.create
            ? function (o, m, k, k2) {
                if (k2 === undefined) k2 = k;
                var desc = Object.getOwnPropertyDescriptor(m, k);
                if (
                  !desc ||
                  ("get" in desc
                    ? !m.__esModule
                    : desc.writable || desc.configurable)
                ) {
                  desc = {
                    enumerable: true,
                    get: function () {
                      return m[k];
                    },
                  };
                }
                Object.defineProperty(o, k2, desc);
              }
            : function (o, m, k, k2) {
                if (k2 === undefined) k2 = k;
                o[k2] = m[k];
              });
        var __setModuleDefault =
          (this && this.__setModuleDefault) ||
          (Object.create
            ? function (o, v) {
                Object.defineProperty(o, "default", {
                  enumerable: true,
                  value: v,
                });
              }
            : function (o, v) {
                o["default"] = v;
              });
        var __importStar =
          (this && this.__importStar) ||
          function (mod) {
            if (mod && mod.__esModule) return mod;
            var result = {};
            if (mod != null)
              for (var k in mod)
                if (
                  k !== "default" &&
                  Object.prototype.hasOwnProperty.call(mod, k)
                )
                  __createBinding(result, mod, k);
            __setModuleDefault(result, mod);
            return result;
          };
        Object.defineProperty(exports, "__esModule", { value: true });
        exports.Safari11 = void 0;
        const sdpTransform = __importStar(require("sdp-transform"));
        const Logger_1 = require("../Logger");
        const utils = __importStar(require("../utils"));
        const ortc = __importStar(require("../ortc"));
        const sdpCommonUtils = __importStar(require("./sdp/commonUtils"));
        const sdpPlanBUtils = __importStar(require("./sdp/planBUtils"));
        const HandlerInterface_1 = require("./HandlerInterface");
        const RemoteSdp_1 = require("./sdp/RemoteSdp");
        const logger = new Logger_1.Logger("Safari11");
        const SCTP_NUM_STREAMS = { OS: 1024, MIS: 1024 };
        class Safari11 extends HandlerInterface_1.HandlerInterface {
          /**
           * Creates a factory function.
           */
          static createFactory() {
            return () => new Safari11();
          }
          constructor() {
            super();
            // Local stream for sending.
            this._sendStream = new MediaStream();
            // Map of RTCRtpSender indexed by localId.
            this._mapSendLocalIdRtpSender = new Map();
            // Next sending localId.
            this._nextSendLocalId = 0;
            // Map of MID, RTP parameters and RTCRtpReceiver indexed by local id.
            // Value is an Object with mid, rtpParameters and rtpReceiver.
            this._mapRecvLocalIdInfo = new Map();
            // Whether a DataChannel m=application section has been created.
            this._hasDataChannelMediaSection = false;
            // Sending DataChannel id value counter. Incremented for each new DataChannel.
            this._nextSendSctpStreamId = 0;
            // Got transport local and remote parameters.
            this._transportReady = false;
          }
          get name() {
            return "Safari11";
          }
          close() {
            logger.debug("close()");
            // Close RTCPeerConnection.
            if (this._pc) {
              try {
                this._pc.close();
              } catch (error) {}
            }
            this.emit("@close");
          }
          async getNativeRtpCapabilities() {
            logger.debug("getNativeRtpCapabilities()");
            const pc = new RTCPeerConnection({
              iceServers: [],
              iceTransportPolicy: "all",
              bundlePolicy: "max-bundle",
              rtcpMuxPolicy: "require",
              sdpSemantics: "plan-b",
            });
            try {
              const offer = await pc.createOffer({
                offerToReceiveAudio: true,
                offerToReceiveVideo: true,
              });
              try {
                pc.close();
              } catch (error) {}
              const sdpObject = sdpTransform.parse(offer.sdp);
              const nativeRtpCapabilities =
                sdpCommonUtils.extractRtpCapabilities({
                  sdpObject,
                });
              return nativeRtpCapabilities;
            } catch (error) {
              try {
                pc.close();
              } catch (error2) {}
              throw error;
            }
          }
          async getNativeSctpCapabilities() {
            logger.debug("getNativeSctpCapabilities()");
            return {
              numStreams: SCTP_NUM_STREAMS,
            };
          }
          run({
            direction,
            iceParameters,
            iceCandidates,
            dtlsParameters,
            sctpParameters,
            iceServers,
            iceTransportPolicy,
            additionalSettings,
            proprietaryConstraints,
            extendedRtpCapabilities,
          }) {
            logger.debug("run()");
            this._direction = direction;
            this._remoteSdp = new RemoteSdp_1.RemoteSdp({
              iceParameters,
              iceCandidates,
              dtlsParameters,
              sctpParameters,
              planB: true,
            });
            this._sendingRtpParametersByKind = {
              audio: ortc.getSendingRtpParameters(
                "audio",
                extendedRtpCapabilities
              ),
              video: ortc.getSendingRtpParameters(
                "video",
                extendedRtpCapabilities
              ),
            };
            this._sendingRemoteRtpParametersByKind = {
              audio: ortc.getSendingRemoteRtpParameters(
                "audio",
                extendedRtpCapabilities
              ),
              video: ortc.getSendingRemoteRtpParameters(
                "video",
                extendedRtpCapabilities
              ),
            };
            if (dtlsParameters.role && dtlsParameters.role !== "auto") {
              this._forcedLocalDtlsRole =
                dtlsParameters.role === "server" ? "client" : "server";
            }
            this._pc = new RTCPeerConnection(
              {
                iceServers: iceServers || [],
                iceTransportPolicy: iceTransportPolicy || "all",
                bundlePolicy: "max-bundle",
                rtcpMuxPolicy: "require",
                ...additionalSettings,
              },
              proprietaryConstraints
            );
            this._pc.addEventListener("icegatheringstatechange", () => {
              this.emit("@icegatheringstatechange", this._pc.iceGatheringState);
            });
            if (this._pc.connectionState) {
              this._pc.addEventListener("connectionstatechange", () => {
                this.emit("@connectionstatechange", this._pc.connectionState);
              });
            } else {
              this._pc.addEventListener("iceconnectionstatechange", () => {
                logger.warn(
                  "run() | pc.connectionState not supported, using pc.iceConnectionState"
                );
                switch (this._pc.iceConnectionState) {
                  case "checking": {
                    this.emit("@connectionstatechange", "connecting");
                    break;
                  }
                  case "connected":
                  case "completed": {
                    this.emit("@connectionstatechange", "connected");
                    break;
                  }
                  case "failed": {
                    this.emit("@connectionstatechange", "failed");
                    break;
                  }
                  case "disconnected": {
                    this.emit("@connectionstatechange", "disconnected");
                    break;
                  }
                  case "closed": {
                    this.emit("@connectionstatechange", "closed");
                    break;
                  }
                }
              });
            }
          }
          async updateIceServers(iceServers) {
            logger.debug("updateIceServers()");
            const configuration = this._pc.getConfiguration();
            configuration.iceServers = iceServers;
            this._pc.setConfiguration(configuration);
          }
          async restartIce(iceParameters) {
            logger.debug("restartIce()");
            // Provide the remote SDP handler with new remote ICE parameters.
            this._remoteSdp.updateIceParameters(iceParameters);
            if (!this._transportReady) {
              return;
            }
            if (this._direction === "send") {
              const offer = await this._pc.createOffer({ iceRestart: true });
              logger.debug(
                "restartIce() | calling pc.setLocalDescription() [offer:%o]",
                offer
              );
              await this._pc.setLocalDescription(offer);
              const answer = { type: "answer", sdp: this._remoteSdp.getSdp() };
              logger.debug(
                "restartIce() | calling pc.setRemoteDescription() [answer:%o]",
                answer
              );
              await this._pc.setRemoteDescription(answer);
            } else {
              const offer = { type: "offer", sdp: this._remoteSdp.getSdp() };
              logger.debug(
                "restartIce() | calling pc.setRemoteDescription() [offer:%o]",
                offer
              );
              await this._pc.setRemoteDescription(offer);
              const answer = await this._pc.createAnswer();
              logger.debug(
                "restartIce() | calling pc.setLocalDescription() [answer:%o]",
                answer
              );
              await this._pc.setLocalDescription(answer);
            }
          }
          async getTransportStats() {
            return this._pc.getStats();
          }
          async send({ track, encodings, codecOptions, codec }) {
            this.assertSendDirection();
            logger.debug("send() [kind:%s, track.id:%s]", track.kind, track.id);
            if (codec) {
              logger.warn(
                "send() | codec selection is not available in %s handler",
                this.name
              );
            }
            this._sendStream.addTrack(track);
            this._pc.addTrack(track, this._sendStream);
            let offer = await this._pc.createOffer();
            let localSdpObject = sdpTransform.parse(offer.sdp);
            let offerMediaObject;
            const sendingRtpParameters = utils.clone(
              this._sendingRtpParametersByKind[track.kind]
            );
            sendingRtpParameters.codecs = ortc.reduceCodecs(
              sendingRtpParameters.codecs
            );
            const sendingRemoteRtpParameters = utils.clone(
              this._sendingRemoteRtpParametersByKind[track.kind]
            );
            sendingRemoteRtpParameters.codecs = ortc.reduceCodecs(
              sendingRemoteRtpParameters.codecs
            );
            if (!this._transportReady) {
              await this.setupTransport({
                localDtlsRole: this._forcedLocalDtlsRole ?? "client",
                localSdpObject,
              });
            }
            if (track.kind === "video" && encodings && encodings.length > 1) {
              logger.debug("send() | enabling simulcast");
              localSdpObject = sdpTransform.parse(offer.sdp);
              offerMediaObject = localSdpObject.media.find(
                (m) => m.type === "video"
              );
              sdpPlanBUtils.addLegacySimulcast({
                offerMediaObject,
                track,
                numStreams: encodings.length,
              });
              offer = {
                type: "offer",
                sdp: sdpTransform.write(localSdpObject),
              };
            }
            logger.debug(
              "send() | calling pc.setLocalDescription() [offer:%o]",
              offer
            );
            await this._pc.setLocalDescription(offer);
            localSdpObject = sdpTransform.parse(this._pc.localDescription.sdp);
            offerMediaObject = localSdpObject.media.find(
              (m) => m.type === track.kind
            );
            // Set RTCP CNAME.
            sendingRtpParameters.rtcp.cname = sdpCommonUtils.getCname({
              offerMediaObject,
            });
            // Set RTP encodings.
            sendingRtpParameters.encodings = sdpPlanBUtils.getRtpEncodings({
              offerMediaObject,
              track,
            });
            // Complete encodings with given values.
            if (encodings) {
              for (
                let idx = 0;
                idx < sendingRtpParameters.encodings.length;
                ++idx
              ) {
                if (encodings[idx]) {
                  Object.assign(
                    sendingRtpParameters.encodings[idx],
                    encodings[idx]
                  );
                }
              }
            }
            // If VP8 and there is effective simulcast, add scalabilityMode to each
            // encoding.
            if (
              sendingRtpParameters.encodings.length > 1 &&
              sendingRtpParameters.codecs[0].mimeType.toLowerCase() ===
                "video/vp8"
            ) {
              for (const encoding of sendingRtpParameters.encodings) {
                encoding.scalabilityMode = "L1T3";
              }
            }
            this._remoteSdp.send({
              offerMediaObject,
              offerRtpParameters: sendingRtpParameters,
              answerRtpParameters: sendingRemoteRtpParameters,
              codecOptions,
            });
            const answer = { type: "answer", sdp: this._remoteSdp.getSdp() };
            logger.debug(
              "send() | calling pc.setRemoteDescription() [answer:%o]",
              answer
            );
            await this._pc.setRemoteDescription(answer);
            const localId = String(this._nextSendLocalId);
            this._nextSendLocalId++;
            const rtpSender = this._pc
              .getSenders()
              .find((s) => s.track === track);
            // Insert into the map.
            this._mapSendLocalIdRtpSender.set(localId, rtpSender);
            return {
              localId: localId,
              rtpParameters: sendingRtpParameters,
              rtpSender,
            };
          }
          async stopSending(localId) {
            this.assertSendDirection();
            const rtpSender = this._mapSendLocalIdRtpSender.get(localId);
            if (!rtpSender) {
              throw new Error("associated RTCRtpSender not found");
            }
            if (rtpSender.track) {
              this._sendStream.removeTrack(rtpSender.track);
            }
            this._mapSendLocalIdRtpSender.delete(localId);
            const offer = await this._pc.createOffer();
            logger.debug(
              "stopSending() | calling pc.setLocalDescription() [offer:%o]",
              offer
            );
            try {
              await this._pc.setLocalDescription(offer);
            } catch (error) {
              // NOTE: If there are no sending tracks, setLocalDescription() will fail with
              // "Failed to create channels". If so, ignore it.
              if (this._sendStream.getTracks().length === 0) {
                logger.warn(
                  "stopSending() | ignoring expected error due no sending tracks: %s",
                  error.toString()
                );
                return;
              }
              throw error;
            }
            if (this._pc.signalingState === "stable") {
              return;
            }
            const answer = { type: "answer", sdp: this._remoteSdp.getSdp() };
            logger.debug(
              "stopSending() | calling pc.setRemoteDescription() [answer:%o]",
              answer
            );
            await this._pc.setRemoteDescription(answer);
          }
          // eslint-disable-next-line @typescript-eslint/no-unused-vars
          async pauseSending(localId) {
            // Unimplemented.
          }
          // eslint-disable-next-line @typescript-eslint/no-unused-vars
          async resumeSending(localId) {
            // Unimplemented.
          }
          async replaceTrack(localId, track) {
            this.assertSendDirection();
            if (track) {
              logger.debug(
                "replaceTrack() [localId:%s, track.id:%s]",
                localId,
                track.id
              );
            } else {
              logger.debug("replaceTrack() [localId:%s, no track]", localId);
            }
            const rtpSender = this._mapSendLocalIdRtpSender.get(localId);
            if (!rtpSender) {
              throw new Error("associated RTCRtpSender not found");
            }
            const oldTrack = rtpSender.track;
            await rtpSender.replaceTrack(track);
            // Remove the old track from the local stream.
            if (oldTrack) {
              this._sendStream.removeTrack(oldTrack);
            }
            // Add the new track to the local stream.
            if (track) {
              this._sendStream.addTrack(track);
            }
          }
          async setMaxSpatialLayer(localId, spatialLayer) {
            this.assertSendDirection();
            logger.debug(
              "setMaxSpatialLayer() [localId:%s, spatialLayer:%s]",
              localId,
              spatialLayer
            );
            const rtpSender = this._mapSendLocalIdRtpSender.get(localId);
            if (!rtpSender) {
              throw new Error("associated RTCRtpSender not found");
            }
            const parameters = rtpSender.getParameters();
            parameters.encodings.forEach((encoding, idx) => {
              if (idx <= spatialLayer) {
                encoding.active = true;
              } else {
                encoding.active = false;
              }
            });
            await rtpSender.setParameters(parameters);
          }
          async setRtpEncodingParameters(localId, params) {
            this.assertSendDirection();
            logger.debug(
              "setRtpEncodingParameters() [localId:%s, params:%o]",
              localId,
              params
            );
            const rtpSender = this._mapSendLocalIdRtpSender.get(localId);
            if (!rtpSender) {
              throw new Error("associated RTCRtpSender not found");
            }
            const parameters = rtpSender.getParameters();
            parameters.encodings.forEach((encoding, idx) => {
              parameters.encodings[idx] = { ...encoding, ...params };
            });
            await rtpSender.setParameters(parameters);
          }
          async getSenderStats(localId) {
            this.assertSendDirection();
            const rtpSender = this._mapSendLocalIdRtpSender.get(localId);
            if (!rtpSender) {
              throw new Error("associated RTCRtpSender not found");
            }
            return rtpSender.getStats();
          }
          async sendDataChannel({
            ordered,
            maxPacketLifeTime,
            maxRetransmits,
            label,
            protocol,
          }) {
            this.assertSendDirection();
            const options = {
              negotiated: true,
              id: this._nextSendSctpStreamId,
              ordered,
              maxPacketLifeTime,
              maxRetransmits,
              protocol,
            };
            logger.debug("sendDataChannel() [options:%o]", options);
            const dataChannel = this._pc.createDataChannel(label, options);
            // Increase next id.
            this._nextSendSctpStreamId =
              ++this._nextSendSctpStreamId % SCTP_NUM_STREAMS.MIS;
            // If this is the first DataChannel we need to create the SDP answer with
            // m=application section.
            if (!this._hasDataChannelMediaSection) {
              const offer = await this._pc.createOffer();
              const localSdpObject = sdpTransform.parse(offer.sdp);
              const offerMediaObject = localSdpObject.media.find(
                (m) => m.type === "application"
              );
              if (!this._transportReady) {
                await this.setupTransport({
                  localDtlsRole: this._forcedLocalDtlsRole ?? "client",
                  localSdpObject,
                });
              }
              logger.debug(
                "sendDataChannel() | calling pc.setLocalDescription() [offer:%o]",
                offer
              );
              await this._pc.setLocalDescription(offer);
              this._remoteSdp.sendSctpAssociation({ offerMediaObject });
              const answer = { type: "answer", sdp: this._remoteSdp.getSdp() };
              logger.debug(
                "sendDataChannel() | calling pc.setRemoteDescription() [answer:%o]",
                answer
              );
              await this._pc.setRemoteDescription(answer);
              this._hasDataChannelMediaSection = true;
            }
            const sctpStreamParameters = {
              streamId: options.id,
              ordered: options.ordered,
              maxPacketLifeTime: options.maxPacketLifeTime,
              maxRetransmits: options.maxRetransmits,
            };
            return { dataChannel, sctpStreamParameters };
          }
          async receive(optionsList) {
            this.assertRecvDirection();
            const results = [];
            for (const options of optionsList) {
              const { trackId, kind, rtpParameters, streamId } = options;
              logger.debug("receive() [trackId:%s, kind:%s]", trackId, kind);
              const mid = kind;
              this._remoteSdp.receive({
                mid,
                kind,
                offerRtpParameters: rtpParameters,
                streamId: streamId || rtpParameters.rtcp.cname,
                trackId,
              });
            }
            const offer = { type: "offer", sdp: this._remoteSdp.getSdp() };
            logger.debug(
              "receive() | calling pc.setRemoteDescription() [offer:%o]",
              offer
            );
            await this._pc.setRemoteDescription(offer);
            let answer = await this._pc.createAnswer();
            const localSdpObject = sdpTransform.parse(answer.sdp);
            for (const options of optionsList) {
              const { kind, rtpParameters } = options;
              const mid = kind;
              const answerMediaObject = localSdpObject.media.find(
                (m) => String(m.mid) === mid
              );
              // May need to modify codec parameters in the answer based on codec
              // parameters in the offer.
              sdpCommonUtils.applyCodecParameters({
                offerRtpParameters: rtpParameters,
                answerMediaObject,
              });
            }
            answer = {
              type: "answer",
              sdp: sdpTransform.write(localSdpObject),
            };
            if (!this._transportReady) {
              await this.setupTransport({
                localDtlsRole: this._forcedLocalDtlsRole ?? "client",
                localSdpObject,
              });
            }
            logger.debug(
              "receive() | calling pc.setLocalDescription() [answer:%o]",
              answer
            );
            await this._pc.setLocalDescription(answer);
            for (const options of optionsList) {
              const { kind, trackId, rtpParameters } = options;
              const mid = kind;
              const localId = trackId;
              const rtpReceiver = this._pc
                .getReceivers()
                .find((r) => r.track && r.track.id === localId);
              if (!rtpReceiver) {
                throw new Error("new RTCRtpReceiver not");
              }
              // Insert into the map.
              this._mapRecvLocalIdInfo.set(localId, {
                mid,
                rtpParameters,
                rtpReceiver,
              });
              results.push({
                localId,
                track: rtpReceiver.track,
                rtpReceiver,
              });
            }
            return results;
          }
          async stopReceiving(localIds) {
            this.assertRecvDirection();
            for (const localId of localIds) {
              logger.debug("stopReceiving() [localId:%s]", localId);
              const { mid, rtpParameters } =
                this._mapRecvLocalIdInfo.get(localId) || {};
              // Remove from the map.
              this._mapRecvLocalIdInfo.delete(localId);
              this._remoteSdp.planBStopReceiving({
                mid: mid,
                offerRtpParameters: rtpParameters,
              });
            }
            const offer = { type: "offer", sdp: this._remoteSdp.getSdp() };
            logger.debug(
              "stopReceiving() | calling pc.setRemoteDescription() [offer:%o]",
              offer
            );
            await this._pc.setRemoteDescription(offer);
            const answer = await this._pc.createAnswer();
            logger.debug(
              "stopReceiving() | calling pc.setLocalDescription() [answer:%o]",
              answer
            );
            await this._pc.setLocalDescription(answer);
          }
          async getReceiverStats(localId) {
            this.assertRecvDirection();
            const { rtpReceiver } = this._mapRecvLocalIdInfo.get(localId) || {};
            if (!rtpReceiver) {
              throw new Error("associated RTCRtpReceiver not found");
            }
            return rtpReceiver.getStats();
          }
          async pauseReceiving(
            // eslint-disable-next-line @typescript-eslint/no-unused-vars
            localIds
          ) {
            // Unimplemented.
          }
          async resumeReceiving(
            // eslint-disable-next-line @typescript-eslint/no-unused-vars
            localIds
          ) {
            // Unimplemented.
          }
          async receiveDataChannel({ sctpStreamParameters, label, protocol }) {
            this.assertRecvDirection();
            const { streamId, ordered, maxPacketLifeTime, maxRetransmits } =
              sctpStreamParameters;
            const options = {
              negotiated: true,
              id: streamId,
              ordered,
              maxPacketLifeTime,
              maxRetransmits,
              protocol,
            };
            logger.debug("receiveDataChannel() [options:%o]", options);
            const dataChannel = this._pc.createDataChannel(label, options);
            // If this is the first DataChannel we need to create the SDP offer with
            // m=application section.
            if (!this._hasDataChannelMediaSection) {
              this._remoteSdp.receiveSctpAssociation({
                oldDataChannelSpec: true,
              });
              const offer = { type: "offer", sdp: this._remoteSdp.getSdp() };
              logger.debug(
                "receiveDataChannel() | calling pc.setRemoteDescription() [offer:%o]",
                offer
              );
              await this._pc.setRemoteDescription(offer);
              const answer = await this._pc.createAnswer();
              if (!this._transportReady) {
                const localSdpObject = sdpTransform.parse(answer.sdp);
                await this.setupTransport({
                  localDtlsRole: this._forcedLocalDtlsRole ?? "client",
                  localSdpObject,
                });
              }
              logger.debug(
                "receiveDataChannel() | calling pc.setRemoteDescription() [answer:%o]",
                answer
              );
              await this._pc.setLocalDescription(answer);
              this._hasDataChannelMediaSection = true;
            }
            return { dataChannel };
          }
          async setupTransport({ localDtlsRole, localSdpObject }) {
            if (!localSdpObject) {
              localSdpObject = sdpTransform.parse(
                this._pc.localDescription.sdp
              );
            }
            // Get our local DTLS parameters.
            const dtlsParameters = sdpCommonUtils.extractDtlsParameters({
              sdpObject: localSdpObject,
            });
            // Set our DTLS role.
            dtlsParameters.role = localDtlsRole;
            // Update the remote DTLS role in the SDP.
            this._remoteSdp.updateDtlsRole(
              localDtlsRole === "client" ? "server" : "client"
            );
            // Need to tell the remote transport about our parameters.
            await new Promise((resolve, reject) => {
              this.safeEmit("@connect", { dtlsParameters }, resolve, reject);
            });
            this._transportReady = true;
          }
          assertSendDirection() {
            if (this._direction !== "send") {
              throw new Error(
                'method can just be called for handlers with "send" direction'
              );
            }
          }
          assertRecvDirection() {
            if (this._direction !== "recv") {
              throw new Error(
                'method can just be called for handlers with "recv" direction'
              );
            }
          }
        }
        exports.Safari11 = Safari11;
      },
      {
        "../Logger": 43,
        "../ortc": 69,
        "../utils": 72,
        "./HandlerInterface": 56,
        "./sdp/RemoteSdp": 64,
        "./sdp/commonUtils": 65,
        "./sdp/planBUtils": 66,
        "sdp-transform": 79,
      },
    ],
    60: [
      function (require, module, exports) {
        "use strict";
        var __createBinding =
          (this && this.__createBinding) ||
          (Object.create
            ? function (o, m, k, k2) {
                if (k2 === undefined) k2 = k;
                var desc = Object.getOwnPropertyDescriptor(m, k);
                if (
                  !desc ||
                  ("get" in desc
                    ? !m.__esModule
                    : desc.writable || desc.configurable)
                ) {
                  desc = {
                    enumerable: true,
                    get: function () {
                      return m[k];
                    },
                  };
                }
                Object.defineProperty(o, k2, desc);
              }
            : function (o, m, k, k2) {
                if (k2 === undefined) k2 = k;
                o[k2] = m[k];
              });
        var __setModuleDefault =
          (this && this.__setModuleDefault) ||
          (Object.create
            ? function (o, v) {
                Object.defineProperty(o, "default", {
                  enumerable: true,
                  value: v,
                });
              }
            : function (o, v) {
                o["default"] = v;
              });
        var __importStar =
          (this && this.__importStar) ||
          function (mod) {
            if (mod && mod.__esModule) return mod;
            var result = {};
            if (mod != null)
              for (var k in mod)
                if (
                  k !== "default" &&
                  Object.prototype.hasOwnProperty.call(mod, k)
                )
                  __createBinding(result, mod, k);
            __setModuleDefault(result, mod);
            return result;
          };
        Object.defineProperty(exports, "__esModule", { value: true });
        exports.Safari12 = void 0;
        const sdpTransform = __importStar(require("sdp-transform"));
        const Logger_1 = require("../Logger");
        const utils = __importStar(require("../utils"));
        const ortc = __importStar(require("../ortc"));
        const sdpCommonUtils = __importStar(require("./sdp/commonUtils"));
        const sdpUnifiedPlanUtils = __importStar(
          require("./sdp/unifiedPlanUtils")
        );
        const ortcUtils = __importStar(require("./ortc/utils"));
        const errors_1 = require("../errors");
        const HandlerInterface_1 = require("./HandlerInterface");
        const RemoteSdp_1 = require("./sdp/RemoteSdp");
        const scalabilityModes_1 = require("../scalabilityModes");
        const logger = new Logger_1.Logger("Safari12");
        const SCTP_NUM_STREAMS = { OS: 1024, MIS: 1024 };
        class Safari12 extends HandlerInterface_1.HandlerInterface {
          /**
           * Creates a factory function.
           */
          static createFactory() {
            return () => new Safari12();
          }
          constructor() {
            super();
            // Closed flag.
            this._closed = false;
            // Map of RTCTransceivers indexed by MID.
            this._mapMidTransceiver = new Map();
            // Local stream for sending.
            this._sendStream = new MediaStream();
            // Whether a DataChannel m=application section has been created.
            this._hasDataChannelMediaSection = false;
            // Sending DataChannel id value counter. Incremented for each new DataChannel.
            this._nextSendSctpStreamId = 0;
            // Got transport local and remote parameters.
            this._transportReady = false;
          }
          get name() {
            return "Safari12";
          }
          close() {
            logger.debug("close()");
            if (this._closed) {
              return;
            }
            this._closed = true;
            // Close RTCPeerConnection.
            if (this._pc) {
              try {
                this._pc.close();
              } catch (error) {}
            }
            this.emit("@close");
          }
          async getNativeRtpCapabilities() {
            logger.debug("getNativeRtpCapabilities()");
            const pc = new RTCPeerConnection({
              iceServers: [],
              iceTransportPolicy: "all",
              bundlePolicy: "max-bundle",
              rtcpMuxPolicy: "require",
            });
            try {
              pc.addTransceiver("audio");
              pc.addTransceiver("video");
              const offer = await pc.createOffer();
              try {
                pc.close();
              } catch (error) {}
              const sdpObject = sdpTransform.parse(offer.sdp);
              const nativeRtpCapabilities =
                sdpCommonUtils.extractRtpCapabilities({
                  sdpObject,
                });
              // libwebrtc supports NACK for OPUS but doesn't announce it.
              ortcUtils.addNackSuppportForOpus(nativeRtpCapabilities);
              return nativeRtpCapabilities;
            } catch (error) {
              try {
                pc.close();
              } catch (error2) {}
              throw error;
            }
          }
          async getNativeSctpCapabilities() {
            logger.debug("getNativeSctpCapabilities()");
            return {
              numStreams: SCTP_NUM_STREAMS,
            };
          }
          run({
            direction,
            iceParameters,
            iceCandidates,
            dtlsParameters,
            sctpParameters,
            iceServers,
            iceTransportPolicy,
            additionalSettings,
            proprietaryConstraints,
            extendedRtpCapabilities,
          }) {
            this.assertNotClosed();
            logger.debug("run()");
            this._direction = direction;
            this._remoteSdp = new RemoteSdp_1.RemoteSdp({
              iceParameters,
              iceCandidates,
              dtlsParameters,
              sctpParameters,
            });
            this._sendingRtpParametersByKind = {
              audio: ortc.getSendingRtpParameters(
                "audio",
                extendedRtpCapabilities
              ),
              video: ortc.getSendingRtpParameters(
                "video",
                extendedRtpCapabilities
              ),
            };
            this._sendingRemoteRtpParametersByKind = {
              audio: ortc.getSendingRemoteRtpParameters(
                "audio",
                extendedRtpCapabilities
              ),
              video: ortc.getSendingRemoteRtpParameters(
                "video",
                extendedRtpCapabilities
              ),
            };
            if (dtlsParameters.role && dtlsParameters.role !== "auto") {
              this._forcedLocalDtlsRole =
                dtlsParameters.role === "server" ? "client" : "server";
            }
            this._pc = new RTCPeerConnection(
              {
                iceServers: iceServers || [],
                iceTransportPolicy: iceTransportPolicy || "all",
                bundlePolicy: "max-bundle",
                rtcpMuxPolicy: "require",
                ...additionalSettings,
              },
              proprietaryConstraints
            );
            this._pc.addEventListener("icegatheringstatechange", () => {
              this.emit("@icegatheringstatechange", this._pc.iceGatheringState);
            });
            if (this._pc.connectionState) {
              this._pc.addEventListener("connectionstatechange", () => {
                this.emit("@connectionstatechange", this._pc.connectionState);
              });
            } else {
              this._pc.addEventListener("iceconnectionstatechange", () => {
                logger.warn(
                  "run() | pc.connectionState not supported, using pc.iceConnectionState"
                );
                switch (this._pc.iceConnectionState) {
                  case "checking": {
                    this.emit("@connectionstatechange", "connecting");
                    break;
                  }
                  case "connected":
                  case "completed": {
                    this.emit("@connectionstatechange", "connected");
                    break;
                  }
                  case "failed": {
                    this.emit("@connectionstatechange", "failed");
                    break;
                  }
                  case "disconnected": {
                    this.emit("@connectionstatechange", "disconnected");
                    break;
                  }
                  case "closed": {
                    this.emit("@connectionstatechange", "closed");
                    break;
                  }
                }
              });
            }
          }
          async updateIceServers(iceServers) {
            this.assertNotClosed();
            logger.debug("updateIceServers()");
            const configuration = this._pc.getConfiguration();
            configuration.iceServers = iceServers;
            this._pc.setConfiguration(configuration);
          }
          async restartIce(iceParameters) {
            this.assertNotClosed();
            logger.debug("restartIce()");
            // Provide the remote SDP handler with new remote ICE parameters.
            this._remoteSdp.updateIceParameters(iceParameters);
            if (!this._transportReady) {
              return;
            }
            if (this._direction === "send") {
              const offer = await this._pc.createOffer({ iceRestart: true });
              logger.debug(
                "restartIce() | calling pc.setLocalDescription() [offer:%o]",
                offer
              );
              await this._pc.setLocalDescription(offer);
              const answer = { type: "answer", sdp: this._remoteSdp.getSdp() };
              logger.debug(
                "restartIce() | calling pc.setRemoteDescription() [answer:%o]",
                answer
              );
              await this._pc.setRemoteDescription(answer);
            } else {
              const offer = { type: "offer", sdp: this._remoteSdp.getSdp() };
              logger.debug(
                "restartIce() | calling pc.setRemoteDescription() [offer:%o]",
                offer
              );
              await this._pc.setRemoteDescription(offer);
              const answer = await this._pc.createAnswer();
              logger.debug(
                "restartIce() | calling pc.setLocalDescription() [answer:%o]",
                answer
              );
              await this._pc.setLocalDescription(answer);
            }
          }
          async getTransportStats() {
            this.assertNotClosed();
            return this._pc.getStats();
          }
          async send({ track, encodings, codecOptions, codec }) {
            this.assertNotClosed();
            this.assertSendDirection();
            logger.debug("send() [kind:%s, track.id:%s]", track.kind, track.id);
            const sendingRtpParameters = utils.clone(
              this._sendingRtpParametersByKind[track.kind]
            );
            // This may throw.
            sendingRtpParameters.codecs = ortc.reduceCodecs(
              sendingRtpParameters.codecs,
              codec
            );
            const sendingRemoteRtpParameters = utils.clone(
              this._sendingRemoteRtpParametersByKind[track.kind]
            );
            // This may throw.
            sendingRemoteRtpParameters.codecs = ortc.reduceCodecs(
              sendingRemoteRtpParameters.codecs,
              codec
            );
            const mediaSectionIdx = this._remoteSdp.getNextMediaSectionIdx();
            const transceiver = this._pc.addTransceiver(track, {
              direction: "sendonly",
              streams: [this._sendStream],
            });
            let offer = await this._pc.createOffer();
            let localSdpObject = sdpTransform.parse(offer.sdp);
            let offerMediaObject;
            if (!this._transportReady) {
              await this.setupTransport({
                localDtlsRole: this._forcedLocalDtlsRole ?? "client",
                localSdpObject,
              });
            }
            const layers = (0, scalabilityModes_1.parse)(
              (encodings || [{}])[0].scalabilityMode
            );
            if (encodings && encodings.length > 1) {
              logger.debug("send() | enabling legacy simulcast");
              localSdpObject = sdpTransform.parse(offer.sdp);
              offerMediaObject = localSdpObject.media[mediaSectionIdx.idx];
              sdpUnifiedPlanUtils.addLegacySimulcast({
                offerMediaObject,
                numStreams: encodings.length,
              });
              offer = {
                type: "offer",
                sdp: sdpTransform.write(localSdpObject),
              };
            }
            logger.debug(
              "send() | calling pc.setLocalDescription() [offer:%o]",
              offer
            );
            await this._pc.setLocalDescription(offer);
            // We can now get the transceiver.mid.
            const localId = transceiver.mid;
            // Set MID.
            sendingRtpParameters.mid = localId;
            localSdpObject = sdpTransform.parse(this._pc.localDescription.sdp);
            offerMediaObject = localSdpObject.media[mediaSectionIdx.idx];
            // Set RTCP CNAME.
            sendingRtpParameters.rtcp.cname = sdpCommonUtils.getCname({
              offerMediaObject,
            });
            // Set RTP encodings.
            sendingRtpParameters.encodings =
              sdpUnifiedPlanUtils.getRtpEncodings({
                offerMediaObject,
              });
            // Complete encodings with given values.
            if (encodings) {
              for (
                let idx = 0;
                idx < sendingRtpParameters.encodings.length;
                ++idx
              ) {
                if (encodings[idx]) {
                  Object.assign(
                    sendingRtpParameters.encodings[idx],
                    encodings[idx]
                  );
                }
              }
            }
            // If VP8 or H264 and there is effective simulcast, add scalabilityMode to
            // each encoding.
            if (
              sendingRtpParameters.encodings.length > 1 &&
              (sendingRtpParameters.codecs[0].mimeType.toLowerCase() ===
                "video/vp8" ||
                sendingRtpParameters.codecs[0].mimeType.toLowerCase() ===
                  "video/h264")
            ) {
              for (const encoding of sendingRtpParameters.encodings) {
                if (encoding.scalabilityMode) {
                  encoding.scalabilityMode = `L1T${layers.temporalLayers}`;
                } else {
                  encoding.scalabilityMode = "L1T3";
                }
              }
            }
            this._remoteSdp.send({
              offerMediaObject,
              reuseMid: mediaSectionIdx.reuseMid,
              offerRtpParameters: sendingRtpParameters,
              answerRtpParameters: sendingRemoteRtpParameters,
              codecOptions,
            });
            const answer = { type: "answer", sdp: this._remoteSdp.getSdp() };
            logger.debug(
              "send() | calling pc.setRemoteDescription() [answer:%o]",
              answer
            );
            await this._pc.setRemoteDescription(answer);
            // Store in the map.
            this._mapMidTransceiver.set(localId, transceiver);
            return {
              localId,
              rtpParameters: sendingRtpParameters,
              rtpSender: transceiver.sender,
            };
          }
          async stopSending(localId) {
            this.assertSendDirection();
            if (this._closed) {
              return;
            }
            logger.debug("stopSending() [localId:%s]", localId);
            const transceiver = this._mapMidTransceiver.get(localId);
            if (!transceiver) {
              throw new Error("associated RTCRtpTransceiver not found");
            }
            transceiver.sender.replaceTrack(null);
            this._pc.removeTrack(transceiver.sender);
            const mediaSectionClosed = this._remoteSdp.closeMediaSection(
              transceiver.mid
            );
            if (mediaSectionClosed) {
              try {
                transceiver.stop();
              } catch (error) {}
            }
            const offer = await this._pc.createOffer();
            logger.debug(
              "stopSending() | calling pc.setLocalDescription() [offer:%o]",
              offer
            );
            await this._pc.setLocalDescription(offer);
            const answer = { type: "answer", sdp: this._remoteSdp.getSdp() };
            logger.debug(
              "stopSending() | calling pc.setRemoteDescription() [answer:%o]",
              answer
            );
            await this._pc.setRemoteDescription(answer);
            this._mapMidTransceiver.delete(localId);
          }
          // eslint-disable-next-line @typescript-eslint/no-unused-vars
          async pauseSending(localId) {
            this.assertNotClosed();
            this.assertSendDirection();
            logger.debug("pauseSending() [localId:%s]", localId);
            const transceiver = this._mapMidTransceiver.get(localId);
            if (!transceiver) {
              throw new Error("associated RTCRtpTransceiver not found");
            }
            transceiver.direction = "inactive";
            this._remoteSdp.pauseMediaSection(localId);
            const offer = await this._pc.createOffer();
            logger.debug(
              "pauseSending() | calling pc.setLocalDescription() [offer:%o]",
              offer
            );
            await this._pc.setLocalDescription(offer);
            const answer = { type: "answer", sdp: this._remoteSdp.getSdp() };
            logger.debug(
              "pauseSending() | calling pc.setRemoteDescription() [answer:%o]",
              answer
            );
            await this._pc.setRemoteDescription(answer);
          }
          // eslint-disable-next-line @typescript-eslint/no-unused-vars
          async resumeSending(localId) {
            this.assertNotClosed();
            this.assertSendDirection();
            logger.debug("resumeSending() [localId:%s]", localId);
            const transceiver = this._mapMidTransceiver.get(localId);
            if (!transceiver) {
              throw new Error("associated RTCRtpTransceiver not found");
            }
            transceiver.direction = "sendonly";
            this._remoteSdp.resumeSendingMediaSection(localId);
            const offer = await this._pc.createOffer();
            logger.debug(
              "resumeSending() | calling pc.setLocalDescription() [offer:%o]",
              offer
            );
            await this._pc.setLocalDescription(offer);
            const answer = { type: "answer", sdp: this._remoteSdp.getSdp() };
            logger.debug(
              "resumeSending() | calling pc.setRemoteDescription() [answer:%o]",
              answer
            );
            await this._pc.setRemoteDescription(answer);
          }
          async replaceTrack(localId, track) {
            this.assertNotClosed();
            this.assertSendDirection();
            if (track) {
              logger.debug(
                "replaceTrack() [localId:%s, track.id:%s]",
                localId,
                track.id
              );
            } else {
              logger.debug("replaceTrack() [localId:%s, no track]", localId);
            }
            const transceiver = this._mapMidTransceiver.get(localId);
            if (!transceiver) {
              throw new Error("associated RTCRtpTransceiver not found");
            }
            await transceiver.sender.replaceTrack(track);
          }
          async setMaxSpatialLayer(localId, spatialLayer) {
            this.assertNotClosed();
            this.assertSendDirection();
            logger.debug(
              "setMaxSpatialLayer() [localId:%s, spatialLayer:%s]",
              localId,
              spatialLayer
            );
            const transceiver = this._mapMidTransceiver.get(localId);
            if (!transceiver) {
              throw new Error("associated RTCRtpTransceiver not found");
            }
            const parameters = transceiver.sender.getParameters();
            parameters.encodings.forEach((encoding, idx) => {
              if (idx <= spatialLayer) {
                encoding.active = true;
              } else {
                encoding.active = false;
              }
            });
            await transceiver.sender.setParameters(parameters);
            this._remoteSdp.muxMediaSectionSimulcast(
              localId,
              parameters.encodings
            );
            const offer = await this._pc.createOffer();
            logger.debug(
              "setMaxSpatialLayer() | calling pc.setLocalDescription() [offer:%o]",
              offer
            );
            await this._pc.setLocalDescription(offer);
            const answer = { type: "answer", sdp: this._remoteSdp.getSdp() };
            logger.debug(
              "setMaxSpatialLayer() | calling pc.setRemoteDescription() [answer:%o]",
              answer
            );
            await this._pc.setRemoteDescription(answer);
          }
          async setRtpEncodingParameters(localId, params) {
            this.assertNotClosed();
            this.assertSendDirection();
            logger.debug(
              "setRtpEncodingParameters() [localId:%s, params:%o]",
              localId,
              params
            );
            const transceiver = this._mapMidTransceiver.get(localId);
            if (!transceiver) {
              throw new Error("associated RTCRtpTransceiver not found");
            }
            const parameters = transceiver.sender.getParameters();
            parameters.encodings.forEach((encoding, idx) => {
              parameters.encodings[idx] = { ...encoding, ...params };
            });
            await transceiver.sender.setParameters(parameters);
            this._remoteSdp.muxMediaSectionSimulcast(
              localId,
              parameters.encodings
            );
            const offer = await this._pc.createOffer();
            logger.debug(
              "setRtpEncodingParameters() | calling pc.setLocalDescription() [offer:%o]",
              offer
            );
            await this._pc.setLocalDescription(offer);
            const answer = { type: "answer", sdp: this._remoteSdp.getSdp() };
            logger.debug(
              "setRtpEncodingParameters() | calling pc.setRemoteDescription() [answer:%o]",
              answer
            );
            await this._pc.setRemoteDescription(answer);
          }
          async getSenderStats(localId) {
            this.assertNotClosed();
            this.assertSendDirection();
            const transceiver = this._mapMidTransceiver.get(localId);
            if (!transceiver) {
              throw new Error("associated RTCRtpTransceiver not found");
            }
            return transceiver.sender.getStats();
          }
          async sendDataChannel({
            ordered,
            maxPacketLifeTime,
            maxRetransmits,
            label,
            protocol,
          }) {
            this.assertNotClosed();
            this.assertSendDirection();
            const options = {
              negotiated: true,
              id: this._nextSendSctpStreamId,
              ordered,
              maxPacketLifeTime,
              maxRetransmits,
              protocol,
            };
            logger.debug("sendDataChannel() [options:%o]", options);
            const dataChannel = this._pc.createDataChannel(label, options);
            // Increase next id.
            this._nextSendSctpStreamId =
              ++this._nextSendSctpStreamId % SCTP_NUM_STREAMS.MIS;
            // If this is the first DataChannel we need to create the SDP answer with
            // m=application section.
            if (!this._hasDataChannelMediaSection) {
              const offer = await this._pc.createOffer();
              const localSdpObject = sdpTransform.parse(offer.sdp);
              const offerMediaObject = localSdpObject.media.find(
                (m) => m.type === "application"
              );
              if (!this._transportReady) {
                await this.setupTransport({
                  localDtlsRole: this._forcedLocalDtlsRole ?? "client",
                  localSdpObject,
                });
              }
              logger.debug(
                "sendDataChannel() | calling pc.setLocalDescription() [offer:%o]",
                offer
              );
              await this._pc.setLocalDescription(offer);
              this._remoteSdp.sendSctpAssociation({ offerMediaObject });
              const answer = { type: "answer", sdp: this._remoteSdp.getSdp() };
              logger.debug(
                "sendDataChannel() | calling pc.setRemoteDescription() [answer:%o]",
                answer
              );
              await this._pc.setRemoteDescription(answer);
              this._hasDataChannelMediaSection = true;
            }
            const sctpStreamParameters = {
              streamId: options.id,
              ordered: options.ordered,
              maxPacketLifeTime: options.maxPacketLifeTime,
              maxRetransmits: options.maxRetransmits,
            };
            return { dataChannel, sctpStreamParameters };
          }
          async receive(optionsList) {
            this.assertNotClosed();
            this.assertRecvDirection();
            const results = [];
            const mapLocalId = new Map();
            for (const options of optionsList) {
              const { trackId, kind, rtpParameters, streamId } = options;
              logger.debug("receive() [trackId:%s, kind:%s]", trackId, kind);
              const localId =
                rtpParameters.mid || String(this._mapMidTransceiver.size);
              mapLocalId.set(trackId, localId);
              this._remoteSdp.receive({
                mid: localId,
                kind,
                offerRtpParameters: rtpParameters,
                streamId: streamId || rtpParameters.rtcp.cname,
                trackId,
              });
            }
            const offer = { type: "offer", sdp: this._remoteSdp.getSdp() };
            logger.debug(
              "receive() | calling pc.setRemoteDescription() [offer:%o]",
              offer
            );
            await this._pc.setRemoteDescription(offer);
            let answer = await this._pc.createAnswer();
            const localSdpObject = sdpTransform.parse(answer.sdp);
            for (const options of optionsList) {
              const { trackId, rtpParameters } = options;
              const localId = mapLocalId.get(trackId);
              const answerMediaObject = localSdpObject.media.find(
                (m) => String(m.mid) === localId
              );
              // May need to modify codec parameters in the answer based on codec
              // parameters in the offer.
              sdpCommonUtils.applyCodecParameters({
                offerRtpParameters: rtpParameters,
                answerMediaObject,
              });
            }
            answer = {
              type: "answer",
              sdp: sdpTransform.write(localSdpObject),
            };
            if (!this._transportReady) {
              await this.setupTransport({
                localDtlsRole: this._forcedLocalDtlsRole ?? "client",
                localSdpObject,
              });
            }
            logger.debug(
              "receive() | calling pc.setLocalDescription() [answer:%o]",
              answer
            );
            await this._pc.setLocalDescription(answer);
            for (const options of optionsList) {
              const { trackId } = options;
              const localId = mapLocalId.get(trackId);
              const transceiver = this._pc
                .getTransceivers()
                .find((t) => t.mid === localId);
              if (!transceiver) {
                throw new Error("new RTCRtpTransceiver not found");
              }
              // Store in the map.
              this._mapMidTransceiver.set(localId, transceiver);
              results.push({
                localId,
                track: transceiver.receiver.track,
                rtpReceiver: transceiver.receiver,
              });
            }
            return results;
          }
          async stopReceiving(localIds) {
            this.assertRecvDirection();
            if (this._closed) {
              return;
            }
            for (const localId of localIds) {
              logger.debug("stopReceiving() [localId:%s]", localId);
              const transceiver = this._mapMidTransceiver.get(localId);
              if (!transceiver) {
                throw new Error("associated RTCRtpTransceiver not found");
              }
              this._remoteSdp.closeMediaSection(transceiver.mid);
            }
            const offer = { type: "offer", sdp: this._remoteSdp.getSdp() };
            logger.debug(
              "stopReceiving() | calling pc.setRemoteDescription() [offer:%o]",
              offer
            );
            await this._pc.setRemoteDescription(offer);
            const answer = await this._pc.createAnswer();
            logger.debug(
              "stopReceiving() | calling pc.setLocalDescription() [answer:%o]",
              answer
            );
            await this._pc.setLocalDescription(answer);
            for (const localId of localIds) {
              this._mapMidTransceiver.delete(localId);
            }
          }
          async pauseReceiving(localIds) {
            this.assertNotClosed();
            this.assertRecvDirection();
            for (const localId of localIds) {
              logger.debug("pauseReceiving() [localId:%s]", localId);
              const transceiver = this._mapMidTransceiver.get(localId);
              if (!transceiver) {
                throw new Error("associated RTCRtpTransceiver not found");
              }
              transceiver.direction = "inactive";
              this._remoteSdp.pauseMediaSection(localId);
            }
            const offer = { type: "offer", sdp: this._remoteSdp.getSdp() };
            logger.debug(
              "pauseReceiving() | calling pc.setRemoteDescription() [offer:%o]",
              offer
            );
            await this._pc.setRemoteDescription(offer);
            const answer = await this._pc.createAnswer();
            logger.debug(
              "pauseReceiving() | calling pc.setLocalDescription() [answer:%o]",
              answer
            );
            await this._pc.setLocalDescription(answer);
          }
          async resumeReceiving(localIds) {
            this.assertNotClosed();
            this.assertRecvDirection();
            for (const localId of localIds) {
              logger.debug("resumeReceiving() [localId:%s]", localId);
              const transceiver = this._mapMidTransceiver.get(localId);
              if (!transceiver) {
                throw new Error("associated RTCRtpTransceiver not found");
              }
              transceiver.direction = "recvonly";
              this._remoteSdp.resumeReceivingMediaSection(localId);
            }
            const offer = { type: "offer", sdp: this._remoteSdp.getSdp() };
            logger.debug(
              "resumeReceiving() | calling pc.setRemoteDescription() [offer:%o]",
              offer
            );
            await this._pc.setRemoteDescription(offer);
            const answer = await this._pc.createAnswer();
            logger.debug(
              "resumeReceiving() | calling pc.setLocalDescription() [answer:%o]",
              answer
            );
            await this._pc.setLocalDescription(answer);
          }
          async getReceiverStats(localId) {
            this.assertNotClosed();
            this.assertRecvDirection();
            const transceiver = this._mapMidTransceiver.get(localId);
            if (!transceiver) {
              throw new Error("associated RTCRtpTransceiver not found");
            }
            return transceiver.receiver.getStats();
          }
          async receiveDataChannel({ sctpStreamParameters, label, protocol }) {
            this.assertNotClosed();
            this.assertRecvDirection();
            const { streamId, ordered, maxPacketLifeTime, maxRetransmits } =
              sctpStreamParameters;
            const options = {
              negotiated: true,
              id: streamId,
              ordered,
              maxPacketLifeTime,
              maxRetransmits,
              protocol,
            };
            logger.debug("receiveDataChannel() [options:%o]", options);
            const dataChannel = this._pc.createDataChannel(label, options);
            // If this is the first DataChannel we need to create the SDP offer with
            // m=application section.
            if (!this._hasDataChannelMediaSection) {
              this._remoteSdp.receiveSctpAssociation();
              const offer = { type: "offer", sdp: this._remoteSdp.getSdp() };
              logger.debug(
                "receiveDataChannel() | calling pc.setRemoteDescription() [offer:%o]",
                offer
              );
              await this._pc.setRemoteDescription(offer);
              const answer = await this._pc.createAnswer();
              if (!this._transportReady) {
                const localSdpObject = sdpTransform.parse(answer.sdp);
                await this.setupTransport({
                  localDtlsRole: this._forcedLocalDtlsRole ?? "client",
                  localSdpObject,
                });
              }
              logger.debug(
                "receiveDataChannel() | calling pc.setRemoteDescription() [answer:%o]",
                answer
              );
              await this._pc.setLocalDescription(answer);
              this._hasDataChannelMediaSection = true;
            }
            return { dataChannel };
          }
          async setupTransport({ localDtlsRole, localSdpObject }) {
            if (!localSdpObject) {
              localSdpObject = sdpTransform.parse(
                this._pc.localDescription.sdp
              );
            }
            // Get our local DTLS parameters.
            const dtlsParameters = sdpCommonUtils.extractDtlsParameters({
              sdpObject: localSdpObject,
            });
            // Set our DTLS role.
            dtlsParameters.role = localDtlsRole;
            // Update the remote DTLS role in the SDP.
            this._remoteSdp.updateDtlsRole(
              localDtlsRole === "client" ? "server" : "client"
            );
            // Need to tell the remote transport about our parameters.
            await new Promise((resolve, reject) => {
              this.safeEmit("@connect", { dtlsParameters }, resolve, reject);
            });
            this._transportReady = true;
          }
          assertNotClosed() {
            if (this._closed) {
              throw new errors_1.InvalidStateError(
                "method called in a closed handler"
              );
            }
          }
          assertSendDirection() {
            if (this._direction !== "send") {
              throw new Error(
                'method can just be called for handlers with "send" direction'
              );
            }
          }
          assertRecvDirection() {
            if (this._direction !== "recv") {
              throw new Error(
                'method can just be called for handlers with "recv" direction'
              );
            }
          }
        }
        exports.Safari12 = Safari12;
      },
      {
        "../Logger": 43,
        "../errors": 48,
        "../ortc": 69,
        "../scalabilityModes": 70,
        "../utils": 72,
        "./HandlerInterface": 56,
        "./ortc/utils": 62,
        "./sdp/RemoteSdp": 64,
        "./sdp/commonUtils": 65,
        "./sdp/unifiedPlanUtils": 67,
        "sdp-transform": 79,
      },
    ],
    61: [
      function (require, module, exports) {
        "use strict";
        var __createBinding =
          (this && this.__createBinding) ||
          (Object.create
            ? function (o, m, k, k2) {
                if (k2 === undefined) k2 = k;
                var desc = Object.getOwnPropertyDescriptor(m, k);
                if (
                  !desc ||
                  ("get" in desc
                    ? !m.__esModule
                    : desc.writable || desc.configurable)
                ) {
                  desc = {
                    enumerable: true,
                    get: function () {
                      return m[k];
                    },
                  };
                }
                Object.defineProperty(o, k2, desc);
              }
            : function (o, m, k, k2) {
                if (k2 === undefined) k2 = k;
                o[k2] = m[k];
              });
        var __setModuleDefault =
          (this && this.__setModuleDefault) ||
          (Object.create
            ? function (o, v) {
                Object.defineProperty(o, "default", {
                  enumerable: true,
                  value: v,
                });
              }
            : function (o, v) {
                o["default"] = v;
              });
        var __importStar =
          (this && this.__importStar) ||
          function (mod) {
            if (mod && mod.__esModule) return mod;
            var result = {};
            if (mod != null)
              for (var k in mod)
                if (
                  k !== "default" &&
                  Object.prototype.hasOwnProperty.call(mod, k)
                )
                  __createBinding(result, mod, k);
            __setModuleDefault(result, mod);
            return result;
          };
        Object.defineProperty(exports, "__esModule", { value: true });
        exports.mangleRtpParameters = exports.getCapabilities = void 0;
        const utils = __importStar(require("../../utils"));
        /**
         * Normalize ORTC based Edge's RTCRtpReceiver.getCapabilities() to produce a full
         * compliant ORTC RTCRtpCapabilities.
         */
        function getCapabilities() {
          const nativeCaps = RTCRtpReceiver.getCapabilities();
          const caps = utils.clone(nativeCaps);
          for (const codec of caps.codecs ?? []) {
            // Rename numChannels to channels.
            // @ts-ignore
            codec.channels = codec.numChannels;
            // @ts-ignore
            delete codec.numChannels;
            // Add mimeType.
            // @ts-ignore (due to codec.name).
            codec.mimeType = codec.mimeType || `${codec.kind}/${codec.name}`;
            // NOTE: Edge sets some numeric parameters as string rather than number. Fix them.
            if (codec.parameters) {
              const parameters = codec.parameters;
              if (parameters.apt) {
                parameters.apt = Number(parameters.apt);
              }
              if (parameters["packetization-mode"]) {
                parameters["packetization-mode"] = Number(
                  parameters["packetization-mode"]
                );
              }
            }
            // Delete emty parameter String in rtcpFeedback.
            for (const feedback of codec.rtcpFeedback || []) {
              if (!feedback.parameter) {
                feedback.parameter = "";
              }
            }
          }
          return caps;
        }
        exports.getCapabilities = getCapabilities;
        /**
         * Generate RTCRtpParameters as ORTC based Edge likes.
         */
        function mangleRtpParameters(rtpParameters) {
          const params = utils.clone(rtpParameters);
          // Rename mid to muxId.
          if (params.mid) {
            // @ts-ignore (due to muxId).
            params.muxId = params.mid;
            delete params.mid;
          }
          for (const codec of params.codecs) {
            // Rename channels to numChannels.
            if (codec.channels) {
              // @ts-ignore.
              codec.numChannels = codec.channels;
              delete codec.channels;
            }
            // Add codec.name (requried by Edge).
            // @ts-ignore (due to name).
            if (codec.mimeType && !codec.name) {
              // @ts-ignore (due to name).
              codec.name = codec.mimeType.split("/")[1];
            }
            // Remove mimeType.
            // @ts-ignore
            delete codec.mimeType;
          }
          return params;
        }
        exports.mangleRtpParameters = mangleRtpParameters;
      },
      { "../../utils": 72 },
    ],
    62: [
      function (require, module, exports) {
        "use strict";
        Object.defineProperty(exports, "__esModule", { value: true });
        exports.addNackSuppportForOpus = void 0;
        /**
         * This function adds RTCP NACK support for OPUS codec in given capabilities.
         */
        function addNackSuppportForOpus(rtpCapabilities) {
          for (const codec of rtpCapabilities.codecs || []) {
            if (
              (codec.mimeType.toLowerCase() === "audio/opus" ||
                codec.mimeType.toLowerCase() === "audio/multiopus") &&
              !codec.rtcpFeedback?.some(
                (fb) => fb.type === "nack" && !fb.parameter
              )
            ) {
              if (!codec.rtcpFeedback) {
                codec.rtcpFeedback = [];
              }
              codec.rtcpFeedback.push({ type: "nack" });
            }
          }
        }
        exports.addNackSuppportForOpus = addNackSuppportForOpus;
      },
      {},
    ],
    63: [
      function (require, module, exports) {
        "use strict";
        var __createBinding =
          (this && this.__createBinding) ||
          (Object.create
            ? function (o, m, k, k2) {
                if (k2 === undefined) k2 = k;
                var desc = Object.getOwnPropertyDescriptor(m, k);
                if (
                  !desc ||
                  ("get" in desc
                    ? !m.__esModule
                    : desc.writable || desc.configurable)
                ) {
                  desc = {
                    enumerable: true,
                    get: function () {
                      return m[k];
                    },
                  };
                }
                Object.defineProperty(o, k2, desc);
              }
            : function (o, m, k, k2) {
                if (k2 === undefined) k2 = k;
                o[k2] = m[k];
              });
        var __setModuleDefault =
          (this && this.__setModuleDefault) ||
          (Object.create
            ? function (o, v) {
                Object.defineProperty(o, "default", {
                  enumerable: true,
                  value: v,
                });
              }
            : function (o, v) {
                o["default"] = v;
              });
        var __importStar =
          (this && this.__importStar) ||
          function (mod) {
            if (mod && mod.__esModule) return mod;
            var result = {};
            if (mod != null)
              for (var k in mod)
                if (
                  k !== "default" &&
                  Object.prototype.hasOwnProperty.call(mod, k)
                )
                  __createBinding(result, mod, k);
            __setModuleDefault(result, mod);
            return result;
          };
        Object.defineProperty(exports, "__esModule", { value: true });
        exports.OfferMediaSection =
          exports.AnswerMediaSection =
          exports.MediaSection =
            void 0;
        const sdpTransform = __importStar(require("sdp-transform"));
        const utils = __importStar(require("../../utils"));
        class MediaSection {
          constructor({
            iceParameters,
            iceCandidates,
            dtlsParameters,
            planB = false,
          }) {
            this._mediaObject = {};
            this._planB = planB;
            if (iceParameters) {
              this.setIceParameters(iceParameters);
            }
            if (iceCandidates) {
              this._mediaObject.candidates = [];
              for (const candidate of iceCandidates) {
                const candidateObject = {};
                // mediasoup does mandates rtcp-mux so candidates component is always
                // RTP (1).
                candidateObject.component = 1;
                candidateObject.foundation = candidate.foundation;
                candidateObject.ip = candidate.ip;
                candidateObject.port = candidate.port;
                candidateObject.priority = candidate.priority;
                candidateObject.transport = candidate.protocol;
                candidateObject.type = candidate.type;
                if (candidate.tcpType) {
                  candidateObject.tcptype = candidate.tcpType;
                }
                this._mediaObject.candidates.push(candidateObject);
              }
              this._mediaObject.endOfCandidates = "end-of-candidates";
              this._mediaObject.iceOptions = "renomination";
            }
            if (dtlsParameters) {
              this.setDtlsRole(dtlsParameters.role);
            }
          }
          get mid() {
            return String(this._mediaObject.mid);
          }
          get closed() {
            return this._mediaObject.port === 0;
          }
          getObject() {
            return this._mediaObject;
          }
          setIceParameters(iceParameters) {
            this._mediaObject.iceUfrag = iceParameters.usernameFragment;
            this._mediaObject.icePwd = iceParameters.password;
          }
          pause() {
            this._mediaObject.direction = "inactive";
          }
          disable() {
            this.pause();
            delete this._mediaObject.ext;
            delete this._mediaObject.ssrcs;
            delete this._mediaObject.ssrcGroups;
            delete this._mediaObject.simulcast;
            delete this._mediaObject.simulcast_03;
            delete this._mediaObject.rids;
            delete this._mediaObject.extmapAllowMixed;
          }
          close() {
            this.disable();
            this._mediaObject.port = 0;
          }
        }
        exports.MediaSection = MediaSection;
        class AnswerMediaSection extends MediaSection {
          constructor({
            iceParameters,
            iceCandidates,
            dtlsParameters,
            sctpParameters,
            plainRtpParameters,
            planB = false,
            offerMediaObject,
            offerRtpParameters,
            answerRtpParameters,
            codecOptions,
            extmapAllowMixed = false,
          }) {
            super({ iceParameters, iceCandidates, dtlsParameters, planB });
            this._mediaObject.mid = String(offerMediaObject.mid);
            this._mediaObject.type = offerMediaObject.type;
            this._mediaObject.protocol = offerMediaObject.protocol;
            if (!plainRtpParameters) {
              this._mediaObject.connection = { ip: "127.0.0.1", version: 4 };
              this._mediaObject.port = 7;
            } else {
              this._mediaObject.connection = {
                ip: plainRtpParameters.ip,
                version: plainRtpParameters.ipVersion,
              };
              this._mediaObject.port = plainRtpParameters.port;
            }
            switch (offerMediaObject.type) {
              case "audio":
              case "video": {
                this._mediaObject.direction = "recvonly";
                this._mediaObject.rtp = [];
                this._mediaObject.rtcpFb = [];
                this._mediaObject.fmtp = [];
                for (const codec of answerRtpParameters.codecs) {
                  const rtp = {
                    payload: codec.payloadType,
                    codec: getCodecName(codec),
                    rate: codec.clockRate,
                  };
                  if (codec.channels > 1) {
                    rtp.encoding = codec.channels;
                  }
                  this._mediaObject.rtp.push(rtp);
                  const codecParameters = utils.clone(codec.parameters) ?? {};
                  let codecRtcpFeedback = utils.clone(codec.rtcpFeedback) ?? [];
                  if (codecOptions) {
                    const {
                      opusStereo,
                      opusFec,
                      opusDtx,
                      opusMaxPlaybackRate,
                      opusMaxAverageBitrate,
                      opusPtime,
                      opusNack,
                      videoGoogleStartBitrate,
                      videoGoogleMaxBitrate,
                      videoGoogleMinBitrate,
                    } = codecOptions;
                    const offerCodec = offerRtpParameters.codecs.find(
                      (c) => c.payloadType === codec.payloadType
                    );
                    switch (codec.mimeType.toLowerCase()) {
                      case "audio/opus":
                      case "audio/multiopus": {
                        if (opusStereo !== undefined) {
                          offerCodec.parameters["sprop-stereo"] = opusStereo
                            ? 1
                            : 0;
                          codecParameters.stereo = opusStereo ? 1 : 0;
                        }
                        if (opusFec !== undefined) {
                          offerCodec.parameters.useinbandfec = opusFec ? 1 : 0;
                          codecParameters.useinbandfec = opusFec ? 1 : 0;
                        }
                        if (opusDtx !== undefined) {
                          offerCodec.parameters.usedtx = opusDtx ? 1 : 0;
                          codecParameters.usedtx = opusDtx ? 1 : 0;
                        }
                        if (opusMaxPlaybackRate !== undefined) {
                          codecParameters.maxplaybackrate = opusMaxPlaybackRate;
                        }
                        if (opusMaxAverageBitrate !== undefined) {
                          codecParameters.maxaveragebitrate =
                            opusMaxAverageBitrate;
                        }
                        if (opusPtime !== undefined) {
                          offerCodec.parameters.ptime = opusPtime;
                          codecParameters.ptime = opusPtime;
                        }
                        // If opusNack is not set, we must remove NACK support for OPUS.
                        // Otherwise it would be enabled for those handlers that artificially
                        // announce it in their RTP capabilities.
                        if (!opusNack) {
                          offerCodec.rtcpFeedback =
                            offerCodec.rtcpFeedback.filter(
                              (fb) => fb.type !== "nack" || fb.parameter
                            );
                          codecRtcpFeedback = codecRtcpFeedback.filter(
                            (fb) => fb.type !== "nack" || fb.parameter
                          );
                        }
                        break;
                      }
                      case "video/vp8":
                      case "video/vp9":
                      case "video/h264":
                      case "video/h265": {
                        if (videoGoogleStartBitrate !== undefined) {
                          codecParameters["x-google-start-bitrate"] =
                            videoGoogleStartBitrate;
                        }
                        if (videoGoogleMaxBitrate !== undefined) {
                          codecParameters["x-google-max-bitrate"] =
                            videoGoogleMaxBitrate;
                        }
                        if (videoGoogleMinBitrate !== undefined) {
                          codecParameters["x-google-min-bitrate"] =
                            videoGoogleMinBitrate;
                        }
                        break;
                      }
                    }
                  }
                  const fmtp = {
                    payload: codec.payloadType,
                    config: "",
                  };
                  for (const key of Object.keys(codecParameters)) {
                    if (fmtp.config) {
                      fmtp.config += ";";
                    }
                    fmtp.config += `${key}=${codecParameters[key]}`;
                  }
                  if (fmtp.config) {
                    this._mediaObject.fmtp.push(fmtp);
                  }
                  for (const fb of codecRtcpFeedback) {
                    this._mediaObject.rtcpFb.push({
                      payload: codec.payloadType,
                      type: fb.type,
                      subtype: fb.parameter,
                    });
                  }
                }
                this._mediaObject.payloads = answerRtpParameters.codecs
                  .map((codec) => codec.payloadType)
                  .join(" ");
                this._mediaObject.ext = [];
                for (const ext of answerRtpParameters.headerExtensions) {
                  // Don't add a header extension if not present in the offer.
                  const found = (offerMediaObject.ext || []).some(
                    (localExt) => localExt.uri === ext.uri
                  );
                  if (!found) {
                    continue;
                  }
                  this._mediaObject.ext.push({
                    uri: ext.uri,
                    value: ext.id,
                  });
                }
                // Allow both 1 byte and 2 bytes length header extensions.
                if (
                  extmapAllowMixed &&
                  offerMediaObject.extmapAllowMixed === "extmap-allow-mixed"
                ) {
                  this._mediaObject.extmapAllowMixed = "extmap-allow-mixed";
                }
                // Simulcast.
                if (offerMediaObject.simulcast) {
                  this._mediaObject.simulcast = {
                    dir1: "recv",
                    list1: offerMediaObject.simulcast.list1,
                  };
                  this._mediaObject.rids = [];
                  for (const rid of offerMediaObject.rids || []) {
                    if (rid.direction !== "send") {
                      continue;
                    }
                    this._mediaObject.rids.push({
                      id: rid.id,
                      direction: "recv",
                    });
                  }
                }
                // Simulcast (draft version 03).
                else if (offerMediaObject.simulcast_03) {
                  // eslint-disable-next-line camelcase
                  this._mediaObject.simulcast_03 = {
                    value: offerMediaObject.simulcast_03.value.replace(
                      /send/g,
                      "recv"
                    ),
                  };
                  this._mediaObject.rids = [];
                  for (const rid of offerMediaObject.rids || []) {
                    if (rid.direction !== "send") {
                      continue;
                    }
                    this._mediaObject.rids.push({
                      id: rid.id,
                      direction: "recv",
                    });
                  }
                }
                this._mediaObject.rtcpMux = "rtcp-mux";
                this._mediaObject.rtcpRsize = "rtcp-rsize";
                if (this._planB && this._mediaObject.type === "video") {
                  this._mediaObject.xGoogleFlag = "conference";
                }
                break;
              }
              case "application": {
                // New spec.
                if (typeof offerMediaObject.sctpPort === "number") {
                  this._mediaObject.payloads = "webrtc-datachannel";
                  this._mediaObject.sctpPort = sctpParameters.port;
                  this._mediaObject.maxMessageSize =
                    sctpParameters.maxMessageSize;
                }
                // Old spec.
                else if (offerMediaObject.sctpmap) {
                  this._mediaObject.payloads = sctpParameters.port;
                  this._mediaObject.sctpmap = {
                    app: "webrtc-datachannel",
                    sctpmapNumber: sctpParameters.port,
                    maxMessageSize: sctpParameters.maxMessageSize,
                  };
                }
                break;
              }
            }
          }
          setDtlsRole(role) {
            switch (role) {
              case "client": {
                this._mediaObject.setup = "active";
                break;
              }
              case "server": {
                this._mediaObject.setup = "passive";
                break;
              }
              case "auto": {
                this._mediaObject.setup = "actpass";
                break;
              }
            }
          }
          resume() {
            this._mediaObject.direction = "recvonly";
          }
          muxSimulcastStreams(encodings) {
            if (
              !this._mediaObject.simulcast ||
              !this._mediaObject.simulcast.list1
            ) {
              return;
            }
            const layers = {};
            for (const encoding of encodings) {
              if (encoding.rid) {
                layers[encoding.rid] = encoding;
              }
            }
            const raw = this._mediaObject.simulcast.list1;
            const simulcastStreams = sdpTransform.parseSimulcastStreamList(raw);
            for (const simulcastStream of simulcastStreams) {
              for (const simulcastFormat of simulcastStream) {
                simulcastFormat.paused = !layers[simulcastFormat.scid]?.active;
              }
            }
            this._mediaObject.simulcast.list1 = simulcastStreams
              .map((simulcastFormats) =>
                simulcastFormats
                  .map((f) => `${f.paused ? "~" : ""}${f.scid}`)
                  .join(",")
              )
              .join(";");
          }
        }
        exports.AnswerMediaSection = AnswerMediaSection;
        class OfferMediaSection extends MediaSection {
          constructor({
            iceParameters,
            iceCandidates,
            dtlsParameters,
            sctpParameters,
            plainRtpParameters,
            planB = false,
            mid,
            kind,
            offerRtpParameters,
            streamId,
            trackId,
            oldDataChannelSpec = false,
          }) {
            super({ iceParameters, iceCandidates, dtlsParameters, planB });
            this._mediaObject.mid = String(mid);
            this._mediaObject.type = kind;
            if (!plainRtpParameters) {
              this._mediaObject.connection = { ip: "127.0.0.1", version: 4 };
              if (!sctpParameters) {
                this._mediaObject.protocol = "UDP/TLS/RTP/SAVPF";
              } else {
                this._mediaObject.protocol = "UDP/DTLS/SCTP";
              }
              this._mediaObject.port = 7;
            } else {
              this._mediaObject.connection = {
                ip: plainRtpParameters.ip,
                version: plainRtpParameters.ipVersion,
              };
              this._mediaObject.protocol = "RTP/AVP";
              this._mediaObject.port = plainRtpParameters.port;
            }
            switch (kind) {
              case "audio":
              case "video": {
                this._mediaObject.direction = "sendonly";
                this._mediaObject.rtp = [];
                this._mediaObject.rtcpFb = [];
                this._mediaObject.fmtp = [];
                if (!this._planB) {
                  this._mediaObject.msid = `${streamId || "-"} ${trackId}`;
                }
                for (const codec of offerRtpParameters.codecs) {
                  const rtp = {
                    payload: codec.payloadType,
                    codec: getCodecName(codec),
                    rate: codec.clockRate,
                  };
                  if (codec.channels > 1) {
                    rtp.encoding = codec.channels;
                  }
                  this._mediaObject.rtp.push(rtp);
                  const fmtp = {
                    payload: codec.payloadType,
                    config: "",
                  };
                  for (const key of Object.keys(codec.parameters)) {
                    if (fmtp.config) {
                      fmtp.config += ";";
                    }
                    fmtp.config += `${key}=${codec.parameters[key]}`;
                  }
                  if (fmtp.config) {
                    this._mediaObject.fmtp.push(fmtp);
                  }
                  for (const fb of codec.rtcpFeedback) {
                    this._mediaObject.rtcpFb.push({
                      payload: codec.payloadType,
                      type: fb.type,
                      subtype: fb.parameter,
                    });
                  }
                }
                this._mediaObject.payloads = offerRtpParameters.codecs
                  .map((codec) => codec.payloadType)
                  .join(" ");
                this._mediaObject.ext = [];
                for (const ext of offerRtpParameters.headerExtensions) {
                  this._mediaObject.ext.push({
                    uri: ext.uri,
                    value: ext.id,
                  });
                }
                this._mediaObject.rtcpMux = "rtcp-mux";
                this._mediaObject.rtcpRsize = "rtcp-rsize";
                const encoding = offerRtpParameters.encodings[0];
                const ssrc = encoding.ssrc;
                const rtxSsrc =
                  encoding.rtx && encoding.rtx.ssrc
                    ? encoding.rtx.ssrc
                    : undefined;
                this._mediaObject.ssrcs = [];
                this._mediaObject.ssrcGroups = [];
                if (offerRtpParameters.rtcp.cname) {
                  this._mediaObject.ssrcs.push({
                    id: ssrc,
                    attribute: "cname",
                    value: offerRtpParameters.rtcp.cname,
                  });
                }
                if (this._planB) {
                  this._mediaObject.ssrcs.push({
                    id: ssrc,
                    attribute: "msid",
                    value: `${streamId || "-"} ${trackId}`,
                  });
                }
                if (rtxSsrc) {
                  if (offerRtpParameters.rtcp.cname) {
                    this._mediaObject.ssrcs.push({
                      id: rtxSsrc,
                      attribute: "cname",
                      value: offerRtpParameters.rtcp.cname,
                    });
                  }
                  if (this._planB) {
                    this._mediaObject.ssrcs.push({
                      id: rtxSsrc,
                      attribute: "msid",
                      value: `${streamId || "-"} ${trackId}`,
                    });
                  }
                  // Associate original and retransmission SSRCs.
                  this._mediaObject.ssrcGroups.push({
                    semantics: "FID",
                    ssrcs: `${ssrc} ${rtxSsrc}`,
                  });
                }
                break;
              }
              case "application": {
                // New spec.
                if (!oldDataChannelSpec) {
                  this._mediaObject.payloads = "webrtc-datachannel";
                  this._mediaObject.sctpPort = sctpParameters.port;
                  this._mediaObject.maxMessageSize =
                    sctpParameters.maxMessageSize;
                }
                // Old spec.
                else {
                  this._mediaObject.payloads = sctpParameters.port;
                  this._mediaObject.sctpmap = {
                    app: "webrtc-datachannel",
                    sctpmapNumber: sctpParameters.port,
                    maxMessageSize: sctpParameters.maxMessageSize,
                  };
                }
                break;
              }
            }
          }
          // eslint-disable-next-line @typescript-eslint/no-unused-vars
          setDtlsRole(role) {
            // Always 'actpass'.
            this._mediaObject.setup = "actpass";
          }
          resume() {
            this._mediaObject.direction = "sendonly";
          }
          planBReceive({ offerRtpParameters, streamId, trackId }) {
            const encoding = offerRtpParameters.encodings[0];
            const ssrc = encoding.ssrc;
            const rtxSsrc =
              encoding.rtx && encoding.rtx.ssrc ? encoding.rtx.ssrc : undefined;
            const payloads = this._mediaObject.payloads.split(" ");
            for (const codec of offerRtpParameters.codecs) {
              if (payloads.includes(String(codec.payloadType))) {
                continue;
              }
              const rtp = {
                payload: codec.payloadType,
                codec: getCodecName(codec),
                rate: codec.clockRate,
              };
              if (codec.channels > 1) {
                rtp.encoding = codec.channels;
              }
              this._mediaObject.rtp.push(rtp);
              const fmtp = {
                payload: codec.payloadType,
                config: "",
              };
              for (const key of Object.keys(codec.parameters)) {
                if (fmtp.config) {
                  fmtp.config += ";";
                }
                fmtp.config += `${key}=${codec.parameters[key]}`;
              }
              if (fmtp.config) {
                this._mediaObject.fmtp.push(fmtp);
              }
              for (const fb of codec.rtcpFeedback) {
                this._mediaObject.rtcpFb.push({
                  payload: codec.payloadType,
                  type: fb.type,
                  subtype: fb.parameter,
                });
              }
            }
            this._mediaObject.payloads += ` ${offerRtpParameters.codecs
              .filter(
                (codec) =>
                  !this._mediaObject.payloads.includes(codec.payloadType)
              )
              .map((codec) => codec.payloadType)
              .join(" ")}`;
            this._mediaObject.payloads = this._mediaObject.payloads.trim();
            if (offerRtpParameters.rtcp.cname) {
              this._mediaObject.ssrcs.push({
                id: ssrc,
                attribute: "cname",
                value: offerRtpParameters.rtcp.cname,
              });
            }
            this._mediaObject.ssrcs.push({
              id: ssrc,
              attribute: "msid",
              value: `${streamId || "-"} ${trackId}`,
            });
            if (rtxSsrc) {
              if (offerRtpParameters.rtcp.cname) {
                this._mediaObject.ssrcs.push({
                  id: rtxSsrc,
                  attribute: "cname",
                  value: offerRtpParameters.rtcp.cname,
                });
              }
              this._mediaObject.ssrcs.push({
                id: rtxSsrc,
                attribute: "msid",
                value: `${streamId || "-"} ${trackId}`,
              });
              // Associate original and retransmission SSRCs.
              this._mediaObject.ssrcGroups.push({
                semantics: "FID",
                ssrcs: `${ssrc} ${rtxSsrc}`,
              });
            }
          }
          planBStopReceiving({ offerRtpParameters }) {
            const encoding = offerRtpParameters.encodings[0];
            const ssrc = encoding.ssrc;
            const rtxSsrc =
              encoding.rtx && encoding.rtx.ssrc ? encoding.rtx.ssrc : undefined;
            this._mediaObject.ssrcs = this._mediaObject.ssrcs.filter(
              (s) => s.id !== ssrc && s.id !== rtxSsrc
            );
            if (rtxSsrc) {
              this._mediaObject.ssrcGroups =
                this._mediaObject.ssrcGroups.filter(
                  (group) => group.ssrcs !== `${ssrc} ${rtxSsrc}`
                );
            }
          }
        }
        exports.OfferMediaSection = OfferMediaSection;
        function getCodecName(codec) {
          const MimeTypeRegex = new RegExp("^(audio|video)/(.+)", "i");
          const mimeTypeMatch = MimeTypeRegex.exec(codec.mimeType);
          if (!mimeTypeMatch) {
            throw new TypeError("invalid codec.mimeType");
          }
          return mimeTypeMatch[2];
        }
      },
      { "../../utils": 72, "sdp-transform": 79 },
    ],
    64: [
      function (require, module, exports) {
        "use strict";
        var __createBinding =
          (this && this.__createBinding) ||
          (Object.create
            ? function (o, m, k, k2) {
                if (k2 === undefined) k2 = k;
                var desc = Object.getOwnPropertyDescriptor(m, k);
                if (
                  !desc ||
                  ("get" in desc
                    ? !m.__esModule
                    : desc.writable || desc.configurable)
                ) {
                  desc = {
                    enumerable: true,
                    get: function () {
                      return m[k];
                    },
                  };
                }
                Object.defineProperty(o, k2, desc);
              }
            : function (o, m, k, k2) {
                if (k2 === undefined) k2 = k;
                o[k2] = m[k];
              });
        var __setModuleDefault =
          (this && this.__setModuleDefault) ||
          (Object.create
            ? function (o, v) {
                Object.defineProperty(o, "default", {
                  enumerable: true,
                  value: v,
                });
              }
            : function (o, v) {
                o["default"] = v;
              });
        var __importStar =
          (this && this.__importStar) ||
          function (mod) {
            if (mod && mod.__esModule) return mod;
            var result = {};
            if (mod != null)
              for (var k in mod)
                if (
                  k !== "default" &&
                  Object.prototype.hasOwnProperty.call(mod, k)
                )
                  __createBinding(result, mod, k);
            __setModuleDefault(result, mod);
            return result;
          };
        Object.defineProperty(exports, "__esModule", { value: true });
        exports.RemoteSdp = void 0;
        const sdpTransform = __importStar(require("sdp-transform"));
        const Logger_1 = require("../../Logger");
        const MediaSection_1 = require("./MediaSection");
        const logger = new Logger_1.Logger("RemoteSdp");
        class RemoteSdp {
          constructor({
            iceParameters,
            iceCandidates,
            dtlsParameters,
            sctpParameters,
            plainRtpParameters,
            planB = false,
          }) {
            // MediaSection instances with same order as in the SDP.
            this._mediaSections = [];
            // MediaSection indices indexed by MID.
            this._midToIndex = new Map();
            this._iceParameters = iceParameters;
            this._iceCandidates = iceCandidates;
            this._dtlsParameters = dtlsParameters;
            this._sctpParameters = sctpParameters;
            this._plainRtpParameters = plainRtpParameters;
            this._planB = planB;
            this._sdpObject = {
              version: 0,
              origin: {
                address: "0.0.0.0",
                ipVer: 4,
                netType: "IN",
                sessionId: 10000,
                sessionVersion: 0,
                username: "mediasoup-client",
              },
              name: "-",
              timing: { start: 0, stop: 0 },
              media: [],
            };
            // If ICE parameters are given, add ICE-Lite indicator.
            if (iceParameters && iceParameters.iceLite) {
              this._sdpObject.icelite = "ice-lite";
            }
            // If DTLS parameters are given, assume WebRTC and BUNDLE.
            if (dtlsParameters) {
              this._sdpObject.msidSemantic = { semantic: "WMS", token: "*" };
              // NOTE: We take the latest fingerprint.
              const numFingerprints = this._dtlsParameters.fingerprints.length;
              this._sdpObject.fingerprint = {
                type: dtlsParameters.fingerprints[numFingerprints - 1]
                  .algorithm,
                hash: dtlsParameters.fingerprints[numFingerprints - 1].value,
              };
              this._sdpObject.groups = [{ type: "BUNDLE", mids: "" }];
            }
            // If there are plain RPT parameters, override SDP origin.
            if (plainRtpParameters) {
              this._sdpObject.origin.address = plainRtpParameters.ip;
              this._sdpObject.origin.ipVer = plainRtpParameters.ipVersion;
            }
          }
          updateIceParameters(iceParameters) {
            logger.debug(
              "updateIceParameters() [iceParameters:%o]",
              iceParameters
            );
            this._iceParameters = iceParameters;
            this._sdpObject.icelite = iceParameters.iceLite
              ? "ice-lite"
              : undefined;
            for (const mediaSection of this._mediaSections) {
              mediaSection.setIceParameters(iceParameters);
            }
          }
          updateDtlsRole(role) {
            logger.debug("updateDtlsRole() [role:%s]", role);
            this._dtlsParameters.role = role;
            for (const mediaSection of this._mediaSections) {
              mediaSection.setDtlsRole(role);
            }
          }
          getNextMediaSectionIdx() {
            // If a closed media section is found, return its index.
            for (let idx = 0; idx < this._mediaSections.length; ++idx) {
              const mediaSection = this._mediaSections[idx];
              if (mediaSection.closed) {
                return { idx, reuseMid: mediaSection.mid };
              }
            }
            // If no closed media section is found, return next one.
            return { idx: this._mediaSections.length };
          }
          send({
            offerMediaObject,
            reuseMid,
            offerRtpParameters,
            answerRtpParameters,
            codecOptions,
            extmapAllowMixed = false,
          }) {
            const mediaSection = new MediaSection_1.AnswerMediaSection({
              iceParameters: this._iceParameters,
              iceCandidates: this._iceCandidates,
              dtlsParameters: this._dtlsParameters,
              plainRtpParameters: this._plainRtpParameters,
              planB: this._planB,
              offerMediaObject,
              offerRtpParameters,
              answerRtpParameters,
              codecOptions,
              extmapAllowMixed,
            });
            // Unified-Plan with closed media section replacement.
            if (reuseMid) {
              this._replaceMediaSection(mediaSection, reuseMid);
            }
            // Unified-Plan or Plan-B with different media kind.
            else if (!this._midToIndex.has(mediaSection.mid)) {
              this._addMediaSection(mediaSection);
            }
            // Plan-B with same media kind.
            else {
              this._replaceMediaSection(mediaSection);
            }
          }
          receive({ mid, kind, offerRtpParameters, streamId, trackId }) {
            const idx = this._midToIndex.get(mid);
            let mediaSection;
            if (idx !== undefined) {
              mediaSection = this._mediaSections[idx];
            }
            // Unified-Plan or different media kind.
            if (!mediaSection) {
              mediaSection = new MediaSection_1.OfferMediaSection({
                iceParameters: this._iceParameters,
                iceCandidates: this._iceCandidates,
                dtlsParameters: this._dtlsParameters,
                plainRtpParameters: this._plainRtpParameters,
                planB: this._planB,
                mid,
                kind,
                offerRtpParameters,
                streamId,
                trackId,
              });
              // Let's try to recycle a closed media section (if any).
              // NOTE: Yes, we can recycle a closed m=audio section with a new m=video.
              const oldMediaSection = this._mediaSections.find((m) => m.closed);
              if (oldMediaSection) {
                this._replaceMediaSection(mediaSection, oldMediaSection.mid);
              } else {
                this._addMediaSection(mediaSection);
              }
            }
            // Plan-B.
            else {
              mediaSection.planBReceive({
                offerRtpParameters,
                streamId,
                trackId,
              });
              this._replaceMediaSection(mediaSection);
            }
          }
          pauseMediaSection(mid) {
            const mediaSection = this._findMediaSection(mid);
            mediaSection.pause();
          }
          resumeSendingMediaSection(mid) {
            const mediaSection = this._findMediaSection(mid);
            mediaSection.resume();
          }
          resumeReceivingMediaSection(mid) {
            const mediaSection = this._findMediaSection(mid);
            mediaSection.resume();
          }
          disableMediaSection(mid) {
            const mediaSection = this._findMediaSection(mid);
            mediaSection.disable();
          }
          /**
           * Closes media section. Returns true if the given MID corresponds to a m
           * section that has been indeed closed. False otherwise.
           *
           * NOTE: Closing the first m section is a pain since it invalidates the bundled
           * transport, so instead closing it we just disable it.
           */
          closeMediaSection(mid) {
            const mediaSection = this._findMediaSection(mid);
            // NOTE: Closing the first m section is a pain since it invalidates the
            // bundled transport, so let's avoid it.
            if (mid === this._firstMid) {
              logger.debug(
                "closeMediaSection() | cannot close first media section, disabling it instead [mid:%s]",
                mid
              );
              this.disableMediaSection(mid);
              return false;
            }
            mediaSection.close();
            // Regenerate BUNDLE mids.
            this._regenerateBundleMids();
            return true;
          }
          muxMediaSectionSimulcast(mid, encodings) {
            const mediaSection = this._findMediaSection(mid);
            mediaSection.muxSimulcastStreams(encodings);
            this._replaceMediaSection(mediaSection);
          }
          planBStopReceiving({ mid, offerRtpParameters }) {
            const mediaSection = this._findMediaSection(mid);
            mediaSection.planBStopReceiving({ offerRtpParameters });
            this._replaceMediaSection(mediaSection);
          }
          sendSctpAssociation({ offerMediaObject }) {
            const mediaSection = new MediaSection_1.AnswerMediaSection({
              iceParameters: this._iceParameters,
              iceCandidates: this._iceCandidates,
              dtlsParameters: this._dtlsParameters,
              sctpParameters: this._sctpParameters,
              plainRtpParameters: this._plainRtpParameters,
              offerMediaObject,
            });
            this._addMediaSection(mediaSection);
          }
          receiveSctpAssociation({ oldDataChannelSpec = false } = {}) {
            const mediaSection = new MediaSection_1.OfferMediaSection({
              iceParameters: this._iceParameters,
              iceCandidates: this._iceCandidates,
              dtlsParameters: this._dtlsParameters,
              sctpParameters: this._sctpParameters,
              plainRtpParameters: this._plainRtpParameters,
              mid: "datachannel",
              kind: "application",
              oldDataChannelSpec,
            });
            this._addMediaSection(mediaSection);
          }
          getSdp() {
            // Increase SDP version.
            this._sdpObject.origin.sessionVersion++;
            return sdpTransform.write(this._sdpObject);
          }
          _addMediaSection(newMediaSection) {
            if (!this._firstMid) {
              this._firstMid = newMediaSection.mid;
            }
            // Add to the vector.
            this._mediaSections.push(newMediaSection);
            // Add to the map.
            this._midToIndex.set(
              newMediaSection.mid,
              this._mediaSections.length - 1
            );
            // Add to the SDP object.
            this._sdpObject.media.push(newMediaSection.getObject());
            // Regenerate BUNDLE mids.
            this._regenerateBundleMids();
          }
          _replaceMediaSection(newMediaSection, reuseMid) {
            // Store it in the map.
            if (typeof reuseMid === "string") {
              const idx = this._midToIndex.get(reuseMid);
              if (idx === undefined) {
                throw new Error(
                  `no media section found for reuseMid '${reuseMid}'`
                );
              }
              const oldMediaSection = this._mediaSections[idx];
              // Replace the index in the vector with the new media section.
              this._mediaSections[idx] = newMediaSection;
              // Update the map.
              this._midToIndex.delete(oldMediaSection.mid);
              this._midToIndex.set(newMediaSection.mid, idx);
              // Update the SDP object.
              this._sdpObject.media[idx] = newMediaSection.getObject();
              // Regenerate BUNDLE mids.
              this._regenerateBundleMids();
            } else {
              const idx = this._midToIndex.get(newMediaSection.mid);
              if (idx === undefined) {
                throw new Error(
                  `no media section found with mid '${newMediaSection.mid}'`
                );
              }
              // Replace the index in the vector with the new media section.
              this._mediaSections[idx] = newMediaSection;
              // Update the SDP object.
              this._sdpObject.media[idx] = newMediaSection.getObject();
            }
          }
          _findMediaSection(mid) {
            const idx = this._midToIndex.get(mid);
            if (idx === undefined) {
              throw new Error(`no media section found with mid '${mid}'`);
            }
            return this._mediaSections[idx];
          }
          _regenerateBundleMids() {
            if (!this._dtlsParameters) {
              return;
            }
            this._sdpObject.groups[0].mids = this._mediaSections
              .filter((mediaSection) => !mediaSection.closed)
              .map((mediaSection) => mediaSection.mid)
              .join(" ");
          }
        }
        exports.RemoteSdp = RemoteSdp;
      },
      { "../../Logger": 43, "./MediaSection": 63, "sdp-transform": 79 },
    ],
    65: [
      function (require, module, exports) {
        "use strict";
        var __createBinding =
          (this && this.__createBinding) ||
          (Object.create
            ? function (o, m, k, k2) {
                if (k2 === undefined) k2 = k;
                var desc = Object.getOwnPropertyDescriptor(m, k);
                if (
                  !desc ||
                  ("get" in desc
                    ? !m.__esModule
                    : desc.writable || desc.configurable)
                ) {
                  desc = {
                    enumerable: true,
                    get: function () {
                      return m[k];
                    },
                  };
                }
                Object.defineProperty(o, k2, desc);
              }
            : function (o, m, k, k2) {
                if (k2 === undefined) k2 = k;
                o[k2] = m[k];
              });
        var __setModuleDefault =
          (this && this.__setModuleDefault) ||
          (Object.create
            ? function (o, v) {
                Object.defineProperty(o, "default", {
                  enumerable: true,
                  value: v,
                });
              }
            : function (o, v) {
                o["default"] = v;
              });
        var __importStar =
          (this && this.__importStar) ||
          function (mod) {
            if (mod && mod.__esModule) return mod;
            var result = {};
            if (mod != null)
              for (var k in mod)
                if (
                  k !== "default" &&
                  Object.prototype.hasOwnProperty.call(mod, k)
                )
                  __createBinding(result, mod, k);
            __setModuleDefault(result, mod);
            return result;
          };
        Object.defineProperty(exports, "__esModule", { value: true });
        exports.applyCodecParameters =
          exports.getCname =
          exports.extractDtlsParameters =
          exports.extractRtpCapabilities =
            void 0;
        const sdpTransform = __importStar(require("sdp-transform"));
        /**
         * This function must be called with an SDP with 1 m=audio and 1 m=video
         * sections.
         */
        function extractRtpCapabilities({ sdpObject }) {
          // Map of RtpCodecParameters indexed by payload type.
          const codecsMap = new Map();
          // Array of RtpHeaderExtensions.
          const headerExtensions = [];
          // Whether a m=audio/video section has been already found.
          let gotAudio = false;
          let gotVideo = false;
          for (const m of sdpObject.media) {
            const kind = m.type;
            switch (kind) {
              case "audio": {
                if (gotAudio) {
                  continue;
                }
                gotAudio = true;
                break;
              }
              case "video": {
                if (gotVideo) {
                  continue;
                }
                gotVideo = true;
                break;
              }
              default: {
                continue;
              }
            }
            // Get codecs.
            for (const rtp of m.rtp) {
              const codec = {
                kind: kind,
                mimeType: `${kind}/${rtp.codec}`,
                preferredPayloadType: rtp.payload,
                clockRate: rtp.rate,
                channels: rtp.encoding,
                parameters: {},
                rtcpFeedback: [],
              };
              codecsMap.set(codec.preferredPayloadType, codec);
            }
            // Get codec parameters.
            for (const fmtp of m.fmtp || []) {
              const parameters = sdpTransform.parseParams(fmtp.config);
              const codec = codecsMap.get(fmtp.payload);
              if (!codec) {
                continue;
              }
              // Specials case to convert parameter value to string.
              if (parameters && parameters.hasOwnProperty("profile-level-id")) {
                parameters["profile-level-id"] = String(
                  parameters["profile-level-id"]
                );
              }
              codec.parameters = parameters;
            }
            // Get RTCP feedback for each codec.
            for (const fb of m.rtcpFb || []) {
              const feedback = {
                type: fb.type,
                parameter: fb.subtype,
              };
              if (!feedback.parameter) {
                delete feedback.parameter;
              }
              // rtcp-fb payload is not '*', so just apply it to its corresponding
              // codec.
              if (fb.payload !== "*") {
                const codec = codecsMap.get(fb.payload);
                if (!codec) {
                  continue;
                }
                codec.rtcpFeedback.push(feedback);
              }
              // If rtcp-fb payload is '*' it must be applied to all codecs with same
              // kind (with some exceptions such as RTX codec).
              else {
                for (const codec of codecsMap.values()) {
                  if (
                    codec.kind === kind &&
                    !/.+\/rtx$/i.test(codec.mimeType)
                  ) {
                    codec.rtcpFeedback.push(feedback);
                  }
                }
              }
            }
            // Get RTP header extensions.
            for (const ext of m.ext || []) {
              // Ignore encrypted extensions (not yet supported in mediasoup).
              if (ext["encrypt-uri"]) {
                continue;
              }
              const headerExtension = {
                kind: kind,
                uri: ext.uri,
                preferredId: ext.value,
              };
              headerExtensions.push(headerExtension);
            }
          }
          const rtpCapabilities = {
            codecs: Array.from(codecsMap.values()),
            headerExtensions: headerExtensions,
          };
          return rtpCapabilities;
        }
        exports.extractRtpCapabilities = extractRtpCapabilities;
        function extractDtlsParameters({ sdpObject }) {
          let setup = sdpObject.setup;
          let fingerprint = sdpObject.fingerprint;
          if (!setup || !fingerprint) {
            const mediaObject = (sdpObject.media || []).find(
              (m) => m.port !== 0
            );
            if (mediaObject) {
              setup ?? (setup = mediaObject.setup);
              fingerprint ?? (fingerprint = mediaObject.fingerprint);
            }
          }
          if (!setup) {
            throw new Error("no a=setup found at SDP session or media level");
          } else if (!fingerprint) {
            throw new Error(
              "no a=fingerprint found at SDP session or media level"
            );
          }
          let role;
          switch (setup) {
            case "active": {
              role = "client";
              break;
            }
            case "passive": {
              role = "server";
              break;
            }
            case "actpass": {
              role = "auto";
              break;
            }
          }
          const dtlsParameters = {
            role,
            fingerprints: [
              {
                algorithm: fingerprint.type,
                value: fingerprint.hash,
              },
            ],
          };
          return dtlsParameters;
        }
        exports.extractDtlsParameters = extractDtlsParameters;
        function getCname({ offerMediaObject }) {
          const ssrcCnameLine = (offerMediaObject.ssrcs || []).find(
            (line) => line.attribute === "cname"
          );
          if (!ssrcCnameLine) {
            return "";
          }
          return ssrcCnameLine.value;
        }
        exports.getCname = getCname;
        /**
         * Apply codec parameters in the given SDP m= section answer based on the
         * given RTP parameters of an offer.
         */
        function applyCodecParameters({
          offerRtpParameters,
          answerMediaObject,
        }) {
          for (const codec of offerRtpParameters.codecs) {
            const mimeType = codec.mimeType.toLowerCase();
            // Avoid parsing codec parameters for unhandled codecs.
            if (mimeType !== "audio/opus") {
              continue;
            }
            const rtp = (answerMediaObject.rtp || []).find(
              (r) => r.payload === codec.payloadType
            );
            if (!rtp) {
              continue;
            }
            // Just in case.
            answerMediaObject.fmtp = answerMediaObject.fmtp || [];
            let fmtp = answerMediaObject.fmtp.find(
              (f) => f.payload === codec.payloadType
            );
            if (!fmtp) {
              fmtp = { payload: codec.payloadType, config: "" };
              answerMediaObject.fmtp.push(fmtp);
            }
            const parameters = sdpTransform.parseParams(fmtp.config);
            switch (mimeType) {
              case "audio/opus": {
                const spropStereo = codec.parameters["sprop-stereo"];
                if (spropStereo !== undefined) {
                  parameters.stereo = spropStereo ? 1 : 0;
                }
                break;
              }
            }
            // Write the codec fmtp.config back.
            fmtp.config = "";
            for (const key of Object.keys(parameters)) {
              if (fmtp.config) {
                fmtp.config += ";";
              }
              fmtp.config += `${key}=${parameters[key]}`;
            }
          }
        }
        exports.applyCodecParameters = applyCodecParameters;
      },
      { "sdp-transform": 79 },
    ],
    66: [
      function (require, module, exports) {
        "use strict";
        Object.defineProperty(exports, "__esModule", { value: true });
        exports.addLegacySimulcast = exports.getRtpEncodings = void 0;
        function getRtpEncodings({ offerMediaObject, track }) {
          // First media SSRC (or the only one).
          let firstSsrc;
          const ssrcs = new Set();
          for (const line of offerMediaObject.ssrcs || []) {
            if (line.attribute !== "msid") {
              continue;
            }
            const trackId = line.value.split(" ")[1];
            if (trackId === track.id) {
              const ssrc = line.id;
              ssrcs.add(ssrc);
              if (!firstSsrc) {
                firstSsrc = ssrc;
              }
            }
          }
          if (ssrcs.size === 0) {
            throw new Error(
              `a=ssrc line with msid information not found [track.id:${track.id}]`
            );
          }
          const ssrcToRtxSsrc = new Map();
          // First assume RTX is used.
          for (const line of offerMediaObject.ssrcGroups || []) {
            if (line.semantics !== "FID") {
              continue;
            }
            let [ssrc, rtxSsrc] = line.ssrcs.split(/\s+/);
            ssrc = Number(ssrc);
            rtxSsrc = Number(rtxSsrc);
            if (ssrcs.has(ssrc)) {
              // Remove both the SSRC and RTX SSRC from the set so later we know that they
              // are already handled.
              ssrcs.delete(ssrc);
              ssrcs.delete(rtxSsrc);
              // Add to the map.
              ssrcToRtxSsrc.set(ssrc, rtxSsrc);
            }
          }
          // If the set of SSRCs is not empty it means that RTX is not being used, so take
          // media SSRCs from there.
          for (const ssrc of ssrcs) {
            // Add to the map.
            ssrcToRtxSsrc.set(ssrc, null);
          }
          const encodings = [];
          for (const [ssrc, rtxSsrc] of ssrcToRtxSsrc) {
            const encoding = { ssrc };
            if (rtxSsrc) {
              encoding.rtx = { ssrc: rtxSsrc };
            }
            encodings.push(encoding);
          }
          return encodings;
        }
        exports.getRtpEncodings = getRtpEncodings;
        /**
         * Adds multi-ssrc based simulcast into the given SDP media section offer.
         */
        function addLegacySimulcast({ offerMediaObject, track, numStreams }) {
          if (numStreams <= 1) {
            throw new TypeError("numStreams must be greater than 1");
          }
          let firstSsrc;
          let firstRtxSsrc;
          let streamId;
          // Get the SSRC.
          const ssrcMsidLine = (offerMediaObject.ssrcs || []).find((line) => {
            if (line.attribute !== "msid") {
              return false;
            }
            const trackId = line.value.split(" ")[1];
            if (trackId === track.id) {
              firstSsrc = line.id;
              streamId = line.value.split(" ")[0];
              return true;
            } else {
              return false;
            }
          });
          if (!ssrcMsidLine) {
            throw new Error(
              `a=ssrc line with msid information not found [track.id:${track.id}]`
            );
          }
          // Get the SSRC for RTX.
          (offerMediaObject.ssrcGroups || []).some((line) => {
            if (line.semantics !== "FID") {
              return false;
            }
            const ssrcs = line.ssrcs.split(/\s+/);
            if (Number(ssrcs[0]) === firstSsrc) {
              firstRtxSsrc = Number(ssrcs[1]);
              return true;
            } else {
              return false;
            }
          });
          const ssrcCnameLine = offerMediaObject.ssrcs.find(
            (line) => line.attribute === "cname" && line.id === firstSsrc
          );
          if (!ssrcCnameLine) {
            throw new Error(
              `a=ssrc line with cname information not found [track.id:${track.id}]`
            );
          }
          const cname = ssrcCnameLine.value;
          const ssrcs = [];
          const rtxSsrcs = [];
          for (let i = 0; i < numStreams; ++i) {
            ssrcs.push(firstSsrc + i);
            if (firstRtxSsrc) {
              rtxSsrcs.push(firstRtxSsrc + i);
            }
          }
          offerMediaObject.ssrcGroups = offerMediaObject.ssrcGroups || [];
          offerMediaObject.ssrcs = offerMediaObject.ssrcs || [];
          offerMediaObject.ssrcGroups.push({
            semantics: "SIM",
            ssrcs: ssrcs.join(" "),
          });
          for (let i = 0; i < ssrcs.length; ++i) {
            const ssrc = ssrcs[i];
            offerMediaObject.ssrcs.push({
              id: ssrc,
              attribute: "cname",
              value: cname,
            });
            offerMediaObject.ssrcs.push({
              id: ssrc,
              attribute: "msid",
              value: `${streamId} ${track.id}`,
            });
          }
          for (let i = 0; i < rtxSsrcs.length; ++i) {
            const ssrc = ssrcs[i];
            const rtxSsrc = rtxSsrcs[i];
            offerMediaObject.ssrcs.push({
              id: rtxSsrc,
              attribute: "cname",
              value: cname,
            });
            offerMediaObject.ssrcs.push({
              id: rtxSsrc,
              attribute: "msid",
              value: `${streamId} ${track.id}`,
            });
            offerMediaObject.ssrcGroups.push({
              semantics: "FID",
              ssrcs: `${ssrc} ${rtxSsrc}`,
            });
          }
        }
        exports.addLegacySimulcast = addLegacySimulcast;
      },
      {},
    ],
    67: [
      function (require, module, exports) {
        "use strict";
        Object.defineProperty(exports, "__esModule", { value: true });
        exports.addLegacySimulcast = exports.getRtpEncodings = void 0;
        function getRtpEncodings({ offerMediaObject }) {
          const ssrcs = new Set();
          for (const line of offerMediaObject.ssrcs || []) {
            const ssrc = line.id;
            ssrcs.add(ssrc);
          }
          if (ssrcs.size === 0) {
            throw new Error("no a=ssrc lines found");
          }
          const ssrcToRtxSsrc = new Map();
          // First assume RTX is used.
          for (const line of offerMediaObject.ssrcGroups || []) {
            if (line.semantics !== "FID") {
              continue;
            }
            let [ssrc, rtxSsrc] = line.ssrcs.split(/\s+/);
            ssrc = Number(ssrc);
            rtxSsrc = Number(rtxSsrc);
            if (ssrcs.has(ssrc)) {
              // Remove both the SSRC and RTX SSRC from the set so later we know
              // that they are already handled.
              ssrcs.delete(ssrc);
              ssrcs.delete(rtxSsrc);
              // Add to the map.
              ssrcToRtxSsrc.set(ssrc, rtxSsrc);
            }
          }
          // If the set of SSRCs is not empty it means that RTX is not being used, so
          // take media SSRCs from there.
          for (const ssrc of ssrcs) {
            // Add to the map.
            ssrcToRtxSsrc.set(ssrc, null);
          }
          const encodings = [];
          for (const [ssrc, rtxSsrc] of ssrcToRtxSsrc) {
            const encoding = { ssrc };
            if (rtxSsrc) {
              encoding.rtx = { ssrc: rtxSsrc };
            }
            encodings.push(encoding);
          }
          return encodings;
        }
        exports.getRtpEncodings = getRtpEncodings;
        /**
         * Adds multi-ssrc based simulcast into the given SDP media section offer.
         */
        function addLegacySimulcast({ offerMediaObject, numStreams }) {
          if (numStreams <= 1) {
            throw new TypeError("numStreams must be greater than 1");
          }
          // Get the SSRC.
          const ssrcMsidLine = (offerMediaObject.ssrcs || []).find(
            (line) => line.attribute === "msid"
          );
          if (!ssrcMsidLine) {
            throw new Error("a=ssrc line with msid information not found");
          }
          const [streamId, trackId] = ssrcMsidLine.value.split(" ");
          const firstSsrc = ssrcMsidLine.id;
          let firstRtxSsrc;
          // Get the SSRC for RTX.
          (offerMediaObject.ssrcGroups || []).some((line) => {
            if (line.semantics !== "FID") {
              return false;
            }
            const ssrcs = line.ssrcs.split(/\s+/);
            if (Number(ssrcs[0]) === firstSsrc) {
              firstRtxSsrc = Number(ssrcs[1]);
              return true;
            } else {
              return false;
            }
          });
          const ssrcCnameLine = offerMediaObject.ssrcs.find(
            (line) => line.attribute === "cname"
          );
          if (!ssrcCnameLine) {
            throw new Error("a=ssrc line with cname information not found");
          }
          const cname = ssrcCnameLine.value;
          const ssrcs = [];
          const rtxSsrcs = [];
          for (let i = 0; i < numStreams; ++i) {
            ssrcs.push(firstSsrc + i);
            if (firstRtxSsrc) {
              rtxSsrcs.push(firstRtxSsrc + i);
            }
          }
          offerMediaObject.ssrcGroups = [];
          offerMediaObject.ssrcs = [];
          offerMediaObject.ssrcGroups.push({
            semantics: "SIM",
            ssrcs: ssrcs.join(" "),
          });
          for (let i = 0; i < ssrcs.length; ++i) {
            const ssrc = ssrcs[i];
            offerMediaObject.ssrcs.push({
              id: ssrc,
              attribute: "cname",
              value: cname,
            });
            offerMediaObject.ssrcs.push({
              id: ssrc,
              attribute: "msid",
              value: `${streamId} ${trackId}`,
            });
          }
          for (let i = 0; i < rtxSsrcs.length; ++i) {
            const ssrc = ssrcs[i];
            const rtxSsrc = rtxSsrcs[i];
            offerMediaObject.ssrcs.push({
              id: rtxSsrc,
              attribute: "cname",
              value: cname,
            });
            offerMediaObject.ssrcs.push({
              id: rtxSsrc,
              attribute: "msid",
              value: `${streamId} ${trackId}`,
            });
            offerMediaObject.ssrcGroups.push({
              semantics: "FID",
              ssrcs: `${ssrc} ${rtxSsrc}`,
            });
          }
        }
        exports.addLegacySimulcast = addLegacySimulcast;
      },
      {},
    ],
    68: [
      function (require, module, exports) {
        "use strict";
        var __createBinding =
          (this && this.__createBinding) ||
          (Object.create
            ? function (o, m, k, k2) {
                if (k2 === undefined) k2 = k;
                var desc = Object.getOwnPropertyDescriptor(m, k);
                if (
                  !desc ||
                  ("get" in desc
                    ? !m.__esModule
                    : desc.writable || desc.configurable)
                ) {
                  desc = {
                    enumerable: true,
                    get: function () {
                      return m[k];
                    },
                  };
                }
                Object.defineProperty(o, k2, desc);
              }
            : function (o, m, k, k2) {
                if (k2 === undefined) k2 = k;
                o[k2] = m[k];
              });
        var __setModuleDefault =
          (this && this.__setModuleDefault) ||
          (Object.create
            ? function (o, v) {
                Object.defineProperty(o, "default", {
                  enumerable: true,
                  value: v,
                });
              }
            : function (o, v) {
                o["default"] = v;
              });
        var __importStar =
          (this && this.__importStar) ||
          function (mod) {
            if (mod && mod.__esModule) return mod;
            var result = {};
            if (mod != null)
              for (var k in mod)
                if (
                  k !== "default" &&
                  Object.prototype.hasOwnProperty.call(mod, k)
                )
                  __createBinding(result, mod, k);
            __setModuleDefault(result, mod);
            return result;
          };
        var __importDefault =
          (this && this.__importDefault) ||
          function (mod) {
            return mod && mod.__esModule ? mod : { default: mod };
          };
        Object.defineProperty(exports, "__esModule", { value: true });
        exports.debug =
          exports.parseScalabilityMode =
          exports.detectDevice =
          exports.Device =
          exports.version =
          exports.types =
            void 0;
        const debug_1 = __importDefault(require("debug"));
        exports.debug = debug_1.default;
        const Device_1 = require("./Device");
        Object.defineProperty(exports, "Device", {
          enumerable: true,
          get: function () {
            return Device_1.Device;
          },
        });
        Object.defineProperty(exports, "detectDevice", {
          enumerable: true,
          get: function () {
            return Device_1.detectDevice;
          },
        });
        const types = __importStar(require("./types"));
        exports.types = types;
        /**
         * Expose mediasoup-client version.
         */
        exports.version = "3.7.2";
        /**
         * Expose parseScalabilityMode() function.
         */
        var scalabilityModes_1 = require("./scalabilityModes");
        Object.defineProperty(exports, "parseScalabilityMode", {
          enumerable: true,
          get: function () {
            return scalabilityModes_1.parse;
          },
        });
      },
      { "./Device": 41, "./scalabilityModes": 70, "./types": 71, debug: 73 },
    ],
    69: [
      function (require, module, exports) {
        "use strict";
        var __createBinding =
          (this && this.__createBinding) ||
          (Object.create
            ? function (o, m, k, k2) {
                if (k2 === undefined) k2 = k;
                var desc = Object.getOwnPropertyDescriptor(m, k);
                if (
                  !desc ||
                  ("get" in desc
                    ? !m.__esModule
                    : desc.writable || desc.configurable)
                ) {
                  desc = {
                    enumerable: true,
                    get: function () {
                      return m[k];
                    },
                  };
                }
                Object.defineProperty(o, k2, desc);
              }
            : function (o, m, k, k2) {
                if (k2 === undefined) k2 = k;
                o[k2] = m[k];
              });
        var __setModuleDefault =
          (this && this.__setModuleDefault) ||
          (Object.create
            ? function (o, v) {
                Object.defineProperty(o, "default", {
                  enumerable: true,
                  value: v,
                });
              }
            : function (o, v) {
                o["default"] = v;
              });
        var __importStar =
          (this && this.__importStar) ||
          function (mod) {
            if (mod && mod.__esModule) return mod;
            var result = {};
            if (mod != null)
              for (var k in mod)
                if (
                  k !== "default" &&
                  Object.prototype.hasOwnProperty.call(mod, k)
                )
                  __createBinding(result, mod, k);
            __setModuleDefault(result, mod);
            return result;
          };
        Object.defineProperty(exports, "__esModule", { value: true });
        exports.canReceive =
          exports.canSend =
          exports.generateProbatorRtpParameters =
          exports.reduceCodecs =
          exports.getSendingRemoteRtpParameters =
          exports.getSendingRtpParameters =
          exports.getRecvRtpCapabilities =
          exports.getExtendedRtpCapabilities =
          exports.validateSctpStreamParameters =
          exports.validateSctpParameters =
          exports.validateNumSctpStreams =
          exports.validateSctpCapabilities =
          exports.validateRtcpParameters =
          exports.validateRtpEncodingParameters =
          exports.validateRtpHeaderExtensionParameters =
          exports.validateRtpCodecParameters =
          exports.validateRtpParameters =
          exports.validateRtpHeaderExtension =
          exports.validateRtcpFeedback =
          exports.validateRtpCodecCapability =
          exports.validateRtpCapabilities =
            void 0;
        const h264 = __importStar(require("h264-profile-level-id"));
        const utils = __importStar(require("./utils"));
        const RTP_PROBATOR_MID = "probator";
        const RTP_PROBATOR_SSRC = 1234;
        const RTP_PROBATOR_CODEC_PAYLOAD_TYPE = 127;
        /**
         * Validates RtpCapabilities. It may modify given data by adding missing
         * fields with default values.
         * It throws if invalid.
         */
        function validateRtpCapabilities(caps) {
          if (typeof caps !== "object") {
            throw new TypeError("caps is not an object");
          }
          // codecs is optional. If unset, fill with an empty array.
          if (caps.codecs && !Array.isArray(caps.codecs)) {
            throw new TypeError("caps.codecs is not an array");
          } else if (!caps.codecs) {
            caps.codecs = [];
          }
          for (const codec of caps.codecs) {
            validateRtpCodecCapability(codec);
          }
          // headerExtensions is optional. If unset, fill with an empty array.
          if (caps.headerExtensions && !Array.isArray(caps.headerExtensions)) {
            throw new TypeError("caps.headerExtensions is not an array");
          } else if (!caps.headerExtensions) {
            caps.headerExtensions = [];
          }
          for (const ext of caps.headerExtensions) {
            validateRtpHeaderExtension(ext);
          }
        }
        exports.validateRtpCapabilities = validateRtpCapabilities;
        /**
         * Validates RtpCodecCapability. It may modify given data by adding missing
         * fields with default values.
         * It throws if invalid.
         */
        function validateRtpCodecCapability(codec) {
          const MimeTypeRegex = new RegExp("^(audio|video)/(.+)", "i");
          if (typeof codec !== "object") {
            throw new TypeError("codec is not an object");
          }
          // mimeType is mandatory.
          if (!codec.mimeType || typeof codec.mimeType !== "string") {
            throw new TypeError("missing codec.mimeType");
          }
          const mimeTypeMatch = MimeTypeRegex.exec(codec.mimeType);
          if (!mimeTypeMatch) {
            throw new TypeError("invalid codec.mimeType");
          }
          // Just override kind with media component of mimeType.
          codec.kind = mimeTypeMatch[1].toLowerCase();
          // preferredPayloadType is optional.
          if (
            codec.preferredPayloadType &&
            typeof codec.preferredPayloadType !== "number"
          ) {
            throw new TypeError("invalid codec.preferredPayloadType");
          }
          // clockRate is mandatory.
          if (typeof codec.clockRate !== "number") {
            throw new TypeError("missing codec.clockRate");
          }
          // channels is optional. If unset, set it to 1 (just if audio).
          if (codec.kind === "audio") {
            if (typeof codec.channels !== "number") {
              codec.channels = 1;
            }
          } else {
            delete codec.channels;
          }
          // parameters is optional. If unset, set it to an empty object.
          if (!codec.parameters || typeof codec.parameters !== "object") {
            codec.parameters = {};
          }
          for (const key of Object.keys(codec.parameters)) {
            let value = codec.parameters[key];
            if (value === undefined) {
              codec.parameters[key] = "";
              value = "";
            }
            if (typeof value !== "string" && typeof value !== "number") {
              throw new TypeError(
                `invalid codec parameter [key:${key}s, value:${value}]`
              );
            }
            // Specific parameters validation.
            if (key === "apt") {
              if (typeof value !== "number") {
                throw new TypeError("invalid codec apt parameter");
              }
            }
          }
          // rtcpFeedback is optional. If unset, set it to an empty array.
          if (!codec.rtcpFeedback || !Array.isArray(codec.rtcpFeedback)) {
            codec.rtcpFeedback = [];
          }
          for (const fb of codec.rtcpFeedback) {
            validateRtcpFeedback(fb);
          }
        }
        exports.validateRtpCodecCapability = validateRtpCodecCapability;
        /**
         * Validates RtcpFeedback. It may modify given data by adding missing
         * fields with default values.
         * It throws if invalid.
         */
        function validateRtcpFeedback(fb) {
          if (typeof fb !== "object") {
            throw new TypeError("fb is not an object");
          }
          // type is mandatory.
          if (!fb.type || typeof fb.type !== "string") {
            throw new TypeError("missing fb.type");
          }
          // parameter is optional. If unset set it to an empty string.
          if (!fb.parameter || typeof fb.parameter !== "string") {
            fb.parameter = "";
          }
        }
        exports.validateRtcpFeedback = validateRtcpFeedback;
        /**
         * Validates RtpHeaderExtension. It may modify given data by adding missing
         * fields with default values.
         * It throws if invalid.
         */
        function validateRtpHeaderExtension(ext) {
          if (typeof ext !== "object") {
            throw new TypeError("ext is not an object");
          }
          // kind is mandatory.
          if (ext.kind !== "audio" && ext.kind !== "video") {
            throw new TypeError("invalid ext.kind");
          }
          // uri is mandatory.
          if (!ext.uri || typeof ext.uri !== "string") {
            throw new TypeError("missing ext.uri");
          }
          // preferredId is mandatory.
          if (typeof ext.preferredId !== "number") {
            throw new TypeError("missing ext.preferredId");
          }
          // preferredEncrypt is optional. If unset set it to false.
          if (
            ext.preferredEncrypt &&
            typeof ext.preferredEncrypt !== "boolean"
          ) {
            throw new TypeError("invalid ext.preferredEncrypt");
          } else if (!ext.preferredEncrypt) {
            ext.preferredEncrypt = false;
          }
          // direction is optional. If unset set it to sendrecv.
          if (ext.direction && typeof ext.direction !== "string") {
            throw new TypeError("invalid ext.direction");
          } else if (!ext.direction) {
            ext.direction = "sendrecv";
          }
        }
        exports.validateRtpHeaderExtension = validateRtpHeaderExtension;
        /**
         * Validates RtpParameters. It may modify given data by adding missing
         * fields with default values.
         * It throws if invalid.
         */
        function validateRtpParameters(params) {
          if (typeof params !== "object") {
            throw new TypeError("params is not an object");
          }
          // mid is optional.
          if (params.mid && typeof params.mid !== "string") {
            throw new TypeError("params.mid is not a string");
          }
          // codecs is mandatory.
          if (!Array.isArray(params.codecs)) {
            throw new TypeError("missing params.codecs");
          }
          for (const codec of params.codecs) {
            validateRtpCodecParameters(codec);
          }
          // headerExtensions is optional. If unset, fill with an empty array.
          if (
            params.headerExtensions &&
            !Array.isArray(params.headerExtensions)
          ) {
            throw new TypeError("params.headerExtensions is not an array");
          } else if (!params.headerExtensions) {
            params.headerExtensions = [];
          }
          for (const ext of params.headerExtensions) {
            validateRtpHeaderExtensionParameters(ext);
          }
          // encodings is optional. If unset, fill with an empty array.
          if (params.encodings && !Array.isArray(params.encodings)) {
            throw new TypeError("params.encodings is not an array");
          } else if (!params.encodings) {
            params.encodings = [];
          }
          for (const encoding of params.encodings) {
            validateRtpEncodingParameters(encoding);
          }
          // rtcp is optional. If unset, fill with an empty object.
          if (params.rtcp && typeof params.rtcp !== "object") {
            throw new TypeError("params.rtcp is not an object");
          } else if (!params.rtcp) {
            params.rtcp = {};
          }
          validateRtcpParameters(params.rtcp);
        }
        exports.validateRtpParameters = validateRtpParameters;
        /**
         * Validates RtpCodecParameters. It may modify given data by adding missing
         * fields with default values.
         * It throws if invalid.
         */
        function validateRtpCodecParameters(codec) {
          const MimeTypeRegex = new RegExp("^(audio|video)/(.+)", "i");
          if (typeof codec !== "object") {
            throw new TypeError("codec is not an object");
          }
          // mimeType is mandatory.
          if (!codec.mimeType || typeof codec.mimeType !== "string") {
            throw new TypeError("missing codec.mimeType");
          }
          const mimeTypeMatch = MimeTypeRegex.exec(codec.mimeType);
          if (!mimeTypeMatch) {
            throw new TypeError("invalid codec.mimeType");
          }
          // payloadType is mandatory.
          if (typeof codec.payloadType !== "number") {
            throw new TypeError("missing codec.payloadType");
          }
          // clockRate is mandatory.
          if (typeof codec.clockRate !== "number") {
            throw new TypeError("missing codec.clockRate");
          }
          const kind = mimeTypeMatch[1].toLowerCase();
          // channels is optional. If unset, set it to 1 (just if audio).
          if (kind === "audio") {
            if (typeof codec.channels !== "number") {
              codec.channels = 1;
            }
          } else {
            delete codec.channels;
          }
          // parameters is optional. If unset, set it to an empty object.
          if (!codec.parameters || typeof codec.parameters !== "object") {
            codec.parameters = {};
          }
          for (const key of Object.keys(codec.parameters)) {
            let value = codec.parameters[key];
            if (value === undefined) {
              codec.parameters[key] = "";
              value = "";
            }
            if (typeof value !== "string" && typeof value !== "number") {
              throw new TypeError(
                `invalid codec parameter [key:${key}s, value:${value}]`
              );
            }
            // Specific parameters validation.
            if (key === "apt") {
              if (typeof value !== "number") {
                throw new TypeError("invalid codec apt parameter");
              }
            }
          }
          // rtcpFeedback is optional. If unset, set it to an empty array.
          if (!codec.rtcpFeedback || !Array.isArray(codec.rtcpFeedback)) {
            codec.rtcpFeedback = [];
          }
          for (const fb of codec.rtcpFeedback) {
            validateRtcpFeedback(fb);
          }
        }
        exports.validateRtpCodecParameters = validateRtpCodecParameters;
        /**
         * Validates RtpHeaderExtensionParameteters. It may modify given data by adding missing
         * fields with default values.
         * It throws if invalid.
         */
        function validateRtpHeaderExtensionParameters(ext) {
          if (typeof ext !== "object") {
            throw new TypeError("ext is not an object");
          }
          // uri is mandatory.
          if (!ext.uri || typeof ext.uri !== "string") {
            throw new TypeError("missing ext.uri");
          }
          // id is mandatory.
          if (typeof ext.id !== "number") {
            throw new TypeError("missing ext.id");
          }
          // encrypt is optional. If unset set it to false.
          if (ext.encrypt && typeof ext.encrypt !== "boolean") {
            throw new TypeError("invalid ext.encrypt");
          } else if (!ext.encrypt) {
            ext.encrypt = false;
          }
          // parameters is optional. If unset, set it to an empty object.
          if (!ext.parameters || typeof ext.parameters !== "object") {
            ext.parameters = {};
          }
          for (const key of Object.keys(ext.parameters)) {
            let value = ext.parameters[key];
            if (value === undefined) {
              ext.parameters[key] = "";
              value = "";
            }
            if (typeof value !== "string" && typeof value !== "number") {
              throw new TypeError("invalid header extension parameter");
            }
          }
        }
        exports.validateRtpHeaderExtensionParameters =
          validateRtpHeaderExtensionParameters;
        /**
         * Validates RtpEncodingParameters. It may modify given data by adding missing
         * fields with default values.
         * It throws if invalid.
         */
        function validateRtpEncodingParameters(encoding) {
          if (typeof encoding !== "object") {
            throw new TypeError("encoding is not an object");
          }
          // ssrc is optional.
          if (encoding.ssrc && typeof encoding.ssrc !== "number") {
            throw new TypeError("invalid encoding.ssrc");
          }
          // rid is optional.
          if (encoding.rid && typeof encoding.rid !== "string") {
            throw new TypeError("invalid encoding.rid");
          }
          // rtx is optional.
          if (encoding.rtx && typeof encoding.rtx !== "object") {
            throw new TypeError("invalid encoding.rtx");
          } else if (encoding.rtx) {
            // RTX ssrc is mandatory if rtx is present.
            if (typeof encoding.rtx.ssrc !== "number") {
              throw new TypeError("missing encoding.rtx.ssrc");
            }
          }
          // dtx is optional. If unset set it to false.
          if (!encoding.dtx || typeof encoding.dtx !== "boolean") {
            encoding.dtx = false;
          }
          // scalabilityMode is optional.
          if (
            encoding.scalabilityMode &&
            typeof encoding.scalabilityMode !== "string"
          ) {
            throw new TypeError("invalid encoding.scalabilityMode");
          }
        }
        exports.validateRtpEncodingParameters = validateRtpEncodingParameters;
        /**
         * Validates RtcpParameters. It may modify given data by adding missing
         * fields with default values.
         * It throws if invalid.
         */
        function validateRtcpParameters(rtcp) {
          if (typeof rtcp !== "object") {
            throw new TypeError("rtcp is not an object");
          }
          // cname is optional.
          if (rtcp.cname && typeof rtcp.cname !== "string") {
            throw new TypeError("invalid rtcp.cname");
          }
          // reducedSize is optional. If unset set it to true.
          if (!rtcp.reducedSize || typeof rtcp.reducedSize !== "boolean") {
            rtcp.reducedSize = true;
          }
        }
        exports.validateRtcpParameters = validateRtcpParameters;
        /**
         * Validates SctpCapabilities. It may modify given data by adding missing
         * fields with default values.
         * It throws if invalid.
         */
        function validateSctpCapabilities(caps) {
          if (typeof caps !== "object") {
            throw new TypeError("caps is not an object");
          }
          // numStreams is mandatory.
          if (!caps.numStreams || typeof caps.numStreams !== "object") {
            throw new TypeError("missing caps.numStreams");
          }
          validateNumSctpStreams(caps.numStreams);
        }
        exports.validateSctpCapabilities = validateSctpCapabilities;
        /**
         * Validates NumSctpStreams. It may modify given data by adding missing
         * fields with default values.
         * It throws if invalid.
         */
        function validateNumSctpStreams(numStreams) {
          if (typeof numStreams !== "object") {
            throw new TypeError("numStreams is not an object");
          }
          // OS is mandatory.
          if (typeof numStreams.OS !== "number") {
            throw new TypeError("missing numStreams.OS");
          }
          // MIS is mandatory.
          if (typeof numStreams.MIS !== "number") {
            throw new TypeError("missing numStreams.MIS");
          }
        }
        exports.validateNumSctpStreams = validateNumSctpStreams;
        /**
         * Validates SctpParameters. It may modify given data by adding missing
         * fields with default values.
         * It throws if invalid.
         */
        function validateSctpParameters(params) {
          if (typeof params !== "object") {
            throw new TypeError("params is not an object");
          }
          // port is mandatory.
          if (typeof params.port !== "number") {
            throw new TypeError("missing params.port");
          }
          // OS is mandatory.
          if (typeof params.OS !== "number") {
            throw new TypeError("missing params.OS");
          }
          // MIS is mandatory.
          if (typeof params.MIS !== "number") {
            throw new TypeError("missing params.MIS");
          }
          // maxMessageSize is mandatory.
          if (typeof params.maxMessageSize !== "number") {
            throw new TypeError("missing params.maxMessageSize");
          }
        }
        exports.validateSctpParameters = validateSctpParameters;
        /**
         * Validates SctpStreamParameters. It may modify given data by adding missing
         * fields with default values.
         * It throws if invalid.
         */
        function validateSctpStreamParameters(params) {
          if (typeof params !== "object") {
            throw new TypeError("params is not an object");
          }
          // streamId is mandatory.
          if (typeof params.streamId !== "number") {
            throw new TypeError("missing params.streamId");
          }
          // ordered is optional.
          let orderedGiven = false;
          if (typeof params.ordered === "boolean") {
            orderedGiven = true;
          } else {
            params.ordered = true;
          }
          // maxPacketLifeTime is optional.
          if (
            params.maxPacketLifeTime &&
            typeof params.maxPacketLifeTime !== "number"
          ) {
            throw new TypeError("invalid params.maxPacketLifeTime");
          }
          // maxRetransmits is optional.
          if (
            params.maxRetransmits &&
            typeof params.maxRetransmits !== "number"
          ) {
            throw new TypeError("invalid params.maxRetransmits");
          }
          if (params.maxPacketLifeTime && params.maxRetransmits) {
            throw new TypeError(
              "cannot provide both maxPacketLifeTime and maxRetransmits"
            );
          }
          if (
            orderedGiven &&
            params.ordered &&
            (params.maxPacketLifeTime || params.maxRetransmits)
          ) {
            throw new TypeError(
              "cannot be ordered with maxPacketLifeTime or maxRetransmits"
            );
          } else if (
            !orderedGiven &&
            (params.maxPacketLifeTime || params.maxRetransmits)
          ) {
            params.ordered = false;
          }
          // label is optional.
          if (params.label && typeof params.label !== "string") {
            throw new TypeError("invalid params.label");
          }
          // protocol is optional.
          if (params.protocol && typeof params.protocol !== "string") {
            throw new TypeError("invalid params.protocol");
          }
        }
        exports.validateSctpStreamParameters = validateSctpStreamParameters;
        /**
         * Generate extended RTP capabilities for sending and receiving.
         */
        function getExtendedRtpCapabilities(localCaps, remoteCaps) {
          const extendedRtpCapabilities = {
            codecs: [],
            headerExtensions: [],
          };
          // Match media codecs and keep the order preferred by remoteCaps.
          for (const remoteCodec of remoteCaps.codecs || []) {
            if (isRtxCodec(remoteCodec)) {
              continue;
            }
            const matchingLocalCodec = (localCaps.codecs || []).find(
              (localCodec) =>
                matchCodecs(localCodec, remoteCodec, {
                  strict: true,
                  modify: true,
                })
            );
            if (!matchingLocalCodec) {
              continue;
            }
            const extendedCodec = {
              mimeType: matchingLocalCodec.mimeType,
              kind: matchingLocalCodec.kind,
              clockRate: matchingLocalCodec.clockRate,
              channels: matchingLocalCodec.channels,
              localPayloadType: matchingLocalCodec.preferredPayloadType,
              localRtxPayloadType: undefined,
              remotePayloadType: remoteCodec.preferredPayloadType,
              remoteRtxPayloadType: undefined,
              localParameters: matchingLocalCodec.parameters,
              remoteParameters: remoteCodec.parameters,
              rtcpFeedback: reduceRtcpFeedback(matchingLocalCodec, remoteCodec),
            };
            extendedRtpCapabilities.codecs.push(extendedCodec);
          }
          // Match RTX codecs.
          for (const extendedCodec of extendedRtpCapabilities.codecs) {
            const matchingLocalRtxCodec = localCaps.codecs.find(
              (localCodec) =>
                isRtxCodec(localCodec) &&
                localCodec.parameters.apt === extendedCodec.localPayloadType
            );
            const matchingRemoteRtxCodec = remoteCaps.codecs.find(
              (remoteCodec) =>
                isRtxCodec(remoteCodec) &&
                remoteCodec.parameters.apt === extendedCodec.remotePayloadType
            );
            if (matchingLocalRtxCodec && matchingRemoteRtxCodec) {
              extendedCodec.localRtxPayloadType =
                matchingLocalRtxCodec.preferredPayloadType;
              extendedCodec.remoteRtxPayloadType =
                matchingRemoteRtxCodec.preferredPayloadType;
            }
          }
          // Match header extensions.
          for (const remoteExt of remoteCaps.headerExtensions) {
            const matchingLocalExt = localCaps.headerExtensions.find(
              (localExt) => matchHeaderExtensions(localExt, remoteExt)
            );
            if (!matchingLocalExt) {
              continue;
            }
            const extendedExt = {
              kind: remoteExt.kind,
              uri: remoteExt.uri,
              sendId: matchingLocalExt.preferredId,
              recvId: remoteExt.preferredId,
              encrypt: matchingLocalExt.preferredEncrypt,
              direction: "sendrecv",
            };
            switch (remoteExt.direction) {
              case "sendrecv": {
                extendedExt.direction = "sendrecv";
                break;
              }
              case "recvonly": {
                extendedExt.direction = "sendonly";
                break;
              }
              case "sendonly": {
                extendedExt.direction = "recvonly";
                break;
              }
              case "inactive": {
                extendedExt.direction = "inactive";
                break;
              }
            }
            extendedRtpCapabilities.headerExtensions.push(extendedExt);
          }
          return extendedRtpCapabilities;
        }
        exports.getExtendedRtpCapabilities = getExtendedRtpCapabilities;
        /**
         * Generate RTP capabilities for receiving media based on the given extended
         * RTP capabilities.
         */
        function getRecvRtpCapabilities(extendedRtpCapabilities) {
          const rtpCapabilities = {
            codecs: [],
            headerExtensions: [],
          };
          for (const extendedCodec of extendedRtpCapabilities.codecs) {
            const codec = {
              mimeType: extendedCodec.mimeType,
              kind: extendedCodec.kind,
              preferredPayloadType: extendedCodec.remotePayloadType,
              clockRate: extendedCodec.clockRate,
              channels: extendedCodec.channels,
              parameters: extendedCodec.localParameters,
              rtcpFeedback: extendedCodec.rtcpFeedback,
            };
            rtpCapabilities.codecs.push(codec);
            // Add RTX codec.
            if (!extendedCodec.remoteRtxPayloadType) {
              continue;
            }
            const rtxCodec = {
              mimeType: `${extendedCodec.kind}/rtx`,
              kind: extendedCodec.kind,
              preferredPayloadType: extendedCodec.remoteRtxPayloadType,
              clockRate: extendedCodec.clockRate,
              parameters: {
                apt: extendedCodec.remotePayloadType,
              },
              rtcpFeedback: [],
            };
            rtpCapabilities.codecs.push(rtxCodec);
            // TODO: In the future, we need to add FEC, CN, etc, codecs.
          }
          for (const extendedExtension of extendedRtpCapabilities.headerExtensions) {
            // Ignore RTP extensions not valid for receiving.
            if (
              extendedExtension.direction !== "sendrecv" &&
              extendedExtension.direction !== "recvonly"
            ) {
              continue;
            }
            const ext = {
              kind: extendedExtension.kind,
              uri: extendedExtension.uri,
              preferredId: extendedExtension.recvId,
              preferredEncrypt: extendedExtension.encrypt,
              direction: extendedExtension.direction,
            };
            rtpCapabilities.headerExtensions.push(ext);
          }
          return rtpCapabilities;
        }
        exports.getRecvRtpCapabilities = getRecvRtpCapabilities;
        /**
         * Generate RTP parameters of the given kind for sending media.
         * NOTE: mid, encodings and rtcp fields are left empty.
         */
        function getSendingRtpParameters(kind, extendedRtpCapabilities) {
          const rtpParameters = {
            mid: undefined,
            codecs: [],
            headerExtensions: [],
            encodings: [],
            rtcp: {},
          };
          for (const extendedCodec of extendedRtpCapabilities.codecs) {
            if (extendedCodec.kind !== kind) {
              continue;
            }
            const codec = {
              mimeType: extendedCodec.mimeType,
              payloadType: extendedCodec.localPayloadType,
              clockRate: extendedCodec.clockRate,
              channels: extendedCodec.channels,
              parameters: extendedCodec.localParameters,
              rtcpFeedback: extendedCodec.rtcpFeedback,
            };
            rtpParameters.codecs.push(codec);
            // Add RTX codec.
            if (extendedCodec.localRtxPayloadType) {
              const rtxCodec = {
                mimeType: `${extendedCodec.kind}/rtx`,
                payloadType: extendedCodec.localRtxPayloadType,
                clockRate: extendedCodec.clockRate,
                parameters: {
                  apt: extendedCodec.localPayloadType,
                },
                rtcpFeedback: [],
              };
              rtpParameters.codecs.push(rtxCodec);
            }
          }
          for (const extendedExtension of extendedRtpCapabilities.headerExtensions) {
            // Ignore RTP extensions of a different kind and those not valid for sending.
            if (
              (extendedExtension.kind && extendedExtension.kind !== kind) ||
              (extendedExtension.direction !== "sendrecv" &&
                extendedExtension.direction !== "sendonly")
            ) {
              continue;
            }
            const ext = {
              uri: extendedExtension.uri,
              id: extendedExtension.sendId,
              encrypt: extendedExtension.encrypt,
              parameters: {},
            };
            rtpParameters.headerExtensions.push(ext);
          }
          return rtpParameters;
        }
        exports.getSendingRtpParameters = getSendingRtpParameters;
        /**
         * Generate RTP parameters of the given kind suitable for the remote SDP answer.
         */
        function getSendingRemoteRtpParameters(kind, extendedRtpCapabilities) {
          const rtpParameters = {
            mid: undefined,
            codecs: [],
            headerExtensions: [],
            encodings: [],
            rtcp: {},
          };
          for (const extendedCodec of extendedRtpCapabilities.codecs) {
            if (extendedCodec.kind !== kind) {
              continue;
            }
            const codec = {
              mimeType: extendedCodec.mimeType,
              payloadType: extendedCodec.localPayloadType,
              clockRate: extendedCodec.clockRate,
              channels: extendedCodec.channels,
              parameters: extendedCodec.remoteParameters,
              rtcpFeedback: extendedCodec.rtcpFeedback,
            };
            rtpParameters.codecs.push(codec);
            // Add RTX codec.
            if (extendedCodec.localRtxPayloadType) {
              const rtxCodec = {
                mimeType: `${extendedCodec.kind}/rtx`,
                payloadType: extendedCodec.localRtxPayloadType,
                clockRate: extendedCodec.clockRate,
                parameters: {
                  apt: extendedCodec.localPayloadType,
                },
                rtcpFeedback: [],
              };
              rtpParameters.codecs.push(rtxCodec);
            }
          }
          for (const extendedExtension of extendedRtpCapabilities.headerExtensions) {
            // Ignore RTP extensions of a different kind and those not valid for sending.
            if (
              (extendedExtension.kind && extendedExtension.kind !== kind) ||
              (extendedExtension.direction !== "sendrecv" &&
                extendedExtension.direction !== "sendonly")
            ) {
              continue;
            }
            const ext = {
              uri: extendedExtension.uri,
              id: extendedExtension.sendId,
              encrypt: extendedExtension.encrypt,
              parameters: {},
            };
            rtpParameters.headerExtensions.push(ext);
          }
          // Reduce codecs' RTCP feedback. Use Transport-CC if available, REMB otherwise.
          if (
            rtpParameters.headerExtensions.some(
              (ext) =>
                ext.uri ===
                "http://www.ietf.org/id/draft-holmer-rmcat-transport-wide-cc-extensions-01"
            )
          ) {
            for (const codec of rtpParameters.codecs) {
              codec.rtcpFeedback = (codec.rtcpFeedback || []).filter(
                (fb) => fb.type !== "goog-remb"
              );
            }
          } else if (
            rtpParameters.headerExtensions.some(
              (ext) =>
                ext.uri ===
                "http://www.webrtc.org/experiments/rtp-hdrext/abs-send-time"
            )
          ) {
            for (const codec of rtpParameters.codecs) {
              codec.rtcpFeedback = (codec.rtcpFeedback || []).filter(
                (fb) => fb.type !== "transport-cc"
              );
            }
          } else {
            for (const codec of rtpParameters.codecs) {
              codec.rtcpFeedback = (codec.rtcpFeedback || []).filter(
                (fb) => fb.type !== "transport-cc" && fb.type !== "goog-remb"
              );
            }
          }
          return rtpParameters;
        }
        exports.getSendingRemoteRtpParameters = getSendingRemoteRtpParameters;
        /**
         * Reduce given codecs by returning an array of codecs "compatible" with the
         * given capability codec. If no capability codec is given, take the first
         * one(s).
         *
         * Given codecs must be generated by ortc.getSendingRtpParameters() or
         * ortc.getSendingRemoteRtpParameters().
         *
         * The returned array of codecs also include a RTX codec if available.
         */
        function reduceCodecs(codecs, capCodec) {
          const filteredCodecs = [];
          // If no capability codec is given, take the first one (and RTX).
          if (!capCodec) {
            filteredCodecs.push(codecs[0]);
            if (isRtxCodec(codecs[1])) {
              filteredCodecs.push(codecs[1]);
            }
          }
          // Otherwise look for a compatible set of codecs.
          else {
            for (let idx = 0; idx < codecs.length; ++idx) {
              if (matchCodecs(codecs[idx], capCodec)) {
                filteredCodecs.push(codecs[idx]);
                if (isRtxCodec(codecs[idx + 1])) {
                  filteredCodecs.push(codecs[idx + 1]);
                }
                break;
              }
            }
            if (filteredCodecs.length === 0) {
              throw new TypeError("no matching codec found");
            }
          }
          return filteredCodecs;
        }
        exports.reduceCodecs = reduceCodecs;
        /**
         * Create RTP parameters for a Consumer for the RTP probator.
         */
        function generateProbatorRtpParameters(videoRtpParameters) {
          // Clone given reference video RTP parameters.
          videoRtpParameters = utils.clone(videoRtpParameters);
          // This may throw.
          validateRtpParameters(videoRtpParameters);
          const rtpParameters = {
            mid: RTP_PROBATOR_MID,
            codecs: [],
            headerExtensions: [],
            encodings: [{ ssrc: RTP_PROBATOR_SSRC }],
            rtcp: { cname: "probator" },
          };
          rtpParameters.codecs.push(videoRtpParameters.codecs[0]);
          rtpParameters.codecs[0].payloadType = RTP_PROBATOR_CODEC_PAYLOAD_TYPE;
          rtpParameters.headerExtensions = videoRtpParameters.headerExtensions;
          return rtpParameters;
        }
        exports.generateProbatorRtpParameters = generateProbatorRtpParameters;
        /**
         * Whether media can be sent based on the given RTP capabilities.
         */
        function canSend(kind, extendedRtpCapabilities) {
          return extendedRtpCapabilities.codecs.some(
            (codec) => codec.kind === kind
          );
        }
        exports.canSend = canSend;
        /**
         * Whether the given RTP parameters can be received with the given RTP
         * capabilities.
         */
        function canReceive(rtpParameters, extendedRtpCapabilities) {
          // This may throw.
          validateRtpParameters(rtpParameters);
          if (rtpParameters.codecs.length === 0) {
            return false;
          }
          const firstMediaCodec = rtpParameters.codecs[0];
          return extendedRtpCapabilities.codecs.some(
            (codec) => codec.remotePayloadType === firstMediaCodec.payloadType
          );
        }
        exports.canReceive = canReceive;
        function isRtxCodec(codec) {
          if (!codec) {
            return false;
          }
          return /.+\/rtx$/i.test(codec.mimeType);
        }
        function matchCodecs(
          aCodec,
          bCodec,
          { strict = false, modify = false } = {}
        ) {
          const aMimeType = aCodec.mimeType.toLowerCase();
          const bMimeType = bCodec.mimeType.toLowerCase();
          if (aMimeType !== bMimeType) {
            return false;
          }
          if (aCodec.clockRate !== bCodec.clockRate) {
            return false;
          }
          if (aCodec.channels !== bCodec.channels) {
            return false;
          }
          // Per codec special checks.
          switch (aMimeType) {
            case "video/h264": {
              if (strict) {
                const aPacketizationMode =
                  aCodec.parameters["packetization-mode"] || 0;
                const bPacketizationMode =
                  bCodec.parameters["packetization-mode"] || 0;
                if (aPacketizationMode !== bPacketizationMode) {
                  return false;
                }
                if (!h264.isSameProfile(aCodec.parameters, bCodec.parameters)) {
                  return false;
                }
                let selectedProfileLevelId;
                try {
                  selectedProfileLevelId =
                    h264.generateProfileLevelIdStringForAnswer(
                      aCodec.parameters,
                      bCodec.parameters
                    );
                } catch (error) {
                  return false;
                }
                if (modify) {
                  if (selectedProfileLevelId) {
                    aCodec.parameters["profile-level-id"] =
                      selectedProfileLevelId;
                    bCodec.parameters["profile-level-id"] =
                      selectedProfileLevelId;
                  } else {
                    delete aCodec.parameters["profile-level-id"];
                    delete bCodec.parameters["profile-level-id"];
                  }
                }
              }
              break;
            }
            case "video/vp9": {
              if (strict) {
                const aProfileId = aCodec.parameters["profile-id"] || 0;
                const bProfileId = bCodec.parameters["profile-id"] || 0;
                if (aProfileId !== bProfileId) {
                  return false;
                }
              }
              break;
            }
          }
          return true;
        }
        function matchHeaderExtensions(aExt, bExt) {
          if (aExt.kind && bExt.kind && aExt.kind !== bExt.kind) {
            return false;
          }
          if (aExt.uri !== bExt.uri) {
            return false;
          }
          return true;
        }
        function reduceRtcpFeedback(codecA, codecB) {
          const reducedRtcpFeedback = [];
          for (const aFb of codecA.rtcpFeedback || []) {
            const matchingBFb = (codecB.rtcpFeedback || []).find(
              (bFb) =>
                bFb.type === aFb.type &&
                (bFb.parameter === aFb.parameter ||
                  (!bFb.parameter && !aFb.parameter))
            );
            if (matchingBFb) {
              reducedRtcpFeedback.push(matchingBFb);
            }
          }
          return reducedRtcpFeedback;
        }
      },
      { "./utils": 72, "h264-profile-level-id": 33 },
    ],
    70: [
      function (require, module, exports) {
        "use strict";
        Object.defineProperty(exports, "__esModule", { value: true });
        exports.parse = void 0;
        const ScalabilityModeRegex = new RegExp(
          "^[LS]([1-9]\\d{0,1})T([1-9]\\d{0,1})"
        );
        function parse(scalabilityMode) {
          const match = ScalabilityModeRegex.exec(scalabilityMode || "");
          if (match) {
            return {
              spatialLayers: Number(match[1]),
              temporalLayers: Number(match[2]),
            };
          } else {
            return {
              spatialLayers: 1,
              temporalLayers: 1,
            };
          }
        }
        exports.parse = parse;
      },
      {},
    ],
    71: [
      function (require, module, exports) {
        "use strict";
        var __createBinding =
          (this && this.__createBinding) ||
          (Object.create
            ? function (o, m, k, k2) {
                if (k2 === undefined) k2 = k;
                var desc = Object.getOwnPropertyDescriptor(m, k);
                if (
                  !desc ||
                  ("get" in desc
                    ? !m.__esModule
                    : desc.writable || desc.configurable)
                ) {
                  desc = {
                    enumerable: true,
                    get: function () {
                      return m[k];
                    },
                  };
                }
                Object.defineProperty(o, k2, desc);
              }
            : function (o, m, k, k2) {
                if (k2 === undefined) k2 = k;
                o[k2] = m[k];
              });
        var __exportStar =
          (this && this.__exportStar) ||
          function (m, exports) {
            for (var p in m)
              if (
                p !== "default" &&
                !Object.prototype.hasOwnProperty.call(exports, p)
              )
                __createBinding(exports, m, p);
          };
        Object.defineProperty(exports, "__esModule", { value: true });
        __exportStar(require("./Device"), exports);
        __exportStar(require("./Transport"), exports);
        __exportStar(require("./Producer"), exports);
        __exportStar(require("./Consumer"), exports);
        __exportStar(require("./DataProducer"), exports);
        __exportStar(require("./DataConsumer"), exports);
        __exportStar(require("./RtpParameters"), exports);
        __exportStar(require("./SctpParameters"), exports);
        __exportStar(require("./handlers/HandlerInterface"), exports);
        __exportStar(require("./errors"), exports);
      },
      {
        "./Consumer": 38,
        "./DataConsumer": 39,
        "./DataProducer": 40,
        "./Device": 41,
        "./Producer": 44,
        "./RtpParameters": 45,
        "./SctpParameters": 46,
        "./Transport": 47,
        "./errors": 48,
        "./handlers/HandlerInterface": 56,
      },
    ],
    72: [
      function (require, module, exports) {
        "use strict";
        Object.defineProperty(exports, "__esModule", { value: true });
        exports.generateRandomNumber = exports.clone = void 0;
        /**
         * Clones the given value.
         */
        function clone(value) {
          if (value === undefined) {
            return undefined;
          } else if (Number.isNaN(value)) {
            return NaN;
          } else if (typeof structuredClone === "function") {
            // Available in Node >= 18.
            return structuredClone(value);
          } else {
            return JSON.parse(JSON.stringify(value));
          }
        }
        exports.clone = clone;
        /**
         * Generates a random positive integer.
         */
        function generateRandomNumber() {
          return Math.round(Math.random() * 10000000);
        }
        exports.generateRandomNumber = generateRandomNumber;
      },
      {},
    ],
    73: [
      function (require, module, exports) {
        arguments[4][23][0].apply(exports, arguments);
      },
      { "./common": 74, _process: 76, dup: 23 },
    ],
    74: [
      function (require, module, exports) {
        arguments[4][24][0].apply(exports, arguments);
      },
      { dup: 24, ms: 75 },
    ],
    75: [
      function (require, module, exports) {
        arguments[4][25][0].apply(exports, arguments);
      },
      { dup: 25 },
    ],
    76: [
      function (require, module, exports) {
        // shim for using process in browser
        var process = (module.exports = {});

        // cached from whatever global is present so that test runners that stub it
        // don't break things.  But we need to wrap it in a try catch in case it is
        // wrapped in strict mode code which doesn't define any globals.  It's inside a
        // function because try/catches deoptimize in certain engines.

        var cachedSetTimeout;
        var cachedClearTimeout;

        function defaultSetTimout() {
          throw new Error("setTimeout has not been defined");
        }
        function defaultClearTimeout() {
          throw new Error("clearTimeout has not been defined");
        }
        (function () {
          try {
            if (typeof setTimeout === "function") {
              cachedSetTimeout = setTimeout;
            } else {
              cachedSetTimeout = defaultSetTimout;
            }
          } catch (e) {
            cachedSetTimeout = defaultSetTimout;
          }
          try {
            if (typeof clearTimeout === "function") {
              cachedClearTimeout = clearTimeout;
            } else {
              cachedClearTimeout = defaultClearTimeout;
            }
          } catch (e) {
            cachedClearTimeout = defaultClearTimeout;
          }
        })();
        function runTimeout(fun) {
          if (cachedSetTimeout === setTimeout) {
            //normal enviroments in sane situations
            return setTimeout(fun, 0);
          }
          // if setTimeout wasn't available but was latter defined
          if (
            (cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) &&
            setTimeout
          ) {
            cachedSetTimeout = setTimeout;
            return setTimeout(fun, 0);
          }
          try {
            // when when somebody has screwed with setTimeout but no I.E. maddness
            return cachedSetTimeout(fun, 0);
          } catch (e) {
            try {
              // When we are in I.E. but the script has been evaled so I.E. doesn't trust the global object when called normally
              return cachedSetTimeout.call(null, fun, 0);
            } catch (e) {
              // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error
              return cachedSetTimeout.call(this, fun, 0);
            }
          }
        }
        function runClearTimeout(marker) {
          if (cachedClearTimeout === clearTimeout) {
            //normal enviroments in sane situations
            return clearTimeout(marker);
          }
          // if clearTimeout wasn't available but was latter defined
          if (
            (cachedClearTimeout === defaultClearTimeout ||
              !cachedClearTimeout) &&
            clearTimeout
          ) {
            cachedClearTimeout = clearTimeout;
            return clearTimeout(marker);
          }
          try {
            // when when somebody has screwed with setTimeout but no I.E. maddness
            return cachedClearTimeout(marker);
          } catch (e) {
            try {
              // When we are in I.E. but the script has been evaled so I.E. doesn't  trust the global object when called normally
              return cachedClearTimeout.call(null, marker);
            } catch (e) {
              // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error.
              // Some versions of I.E. have different rules for clearTimeout vs setTimeout
              return cachedClearTimeout.call(this, marker);
            }
          }
        }
        var queue = [];
        var draining = false;
        var currentQueue;
        var queueIndex = -1;

        function cleanUpNextTick() {
          if (!draining || !currentQueue) {
            return;
          }
          draining = false;
          if (currentQueue.length) {
            queue = currentQueue.concat(queue);
          } else {
            queueIndex = -1;
          }
          if (queue.length) {
            drainQueue();
          }
        }

        function drainQueue() {
          if (draining) {
            return;
          }
          var timeout = runTimeout(cleanUpNextTick);
          draining = true;

          var len = queue.length;
          while (len) {
            currentQueue = queue;
            queue = [];
            while (++queueIndex < len) {
              if (currentQueue) {
                currentQueue[queueIndex].run();
              }
            }
            queueIndex = -1;
            len = queue.length;
          }
          currentQueue = null;
          draining = false;
          runClearTimeout(timeout);
        }

        process.nextTick = function (fun) {
          var args = new Array(arguments.length - 1);
          if (arguments.length > 1) {
            for (var i = 1; i < arguments.length; i++) {
              args[i - 1] = arguments[i];
            }
          }
          queue.push(new Item(fun, args));
          if (queue.length === 1 && !draining) {
            runTimeout(drainQueue);
          }
        };

        // v8 likes predictible objects
        function Item(fun, array) {
          this.fun = fun;
          this.array = array;
        }
        Item.prototype.run = function () {
          this.fun.apply(null, this.array);
        };
        process.title = "browser";
        process.browser = true;
        process.env = {};
        process.argv = [];
        process.version = ""; // empty string to avoid regexp issues
        process.versions = {};

        function noop() {}

        process.on = noop;
        process.addListener = noop;
        process.once = noop;
        process.off = noop;
        process.removeListener = noop;
        process.removeAllListeners = noop;
        process.emit = noop;
        process.prependListener = noop;
        process.prependOnceListener = noop;

        process.listeners = function (name) {
          return [];
        };

        process.binding = function (name) {
          throw new Error("process.binding is not supported");
        };

        process.cwd = function () {
          return "/";
        };
        process.chdir = function (dir) {
          throw new Error("process.chdir is not supported");
        };
        process.umask = function () {
          return 0;
        };
      },
      {},
    ],
    77: [
      function (require, module, exports) {
        (function (global) {
          (function () {
            /*! queue-microtask. MIT License. Feross Aboukhadijeh <https://feross.org/opensource> */
            let promise;

            module.exports =
              typeof queueMicrotask === "function"
                ? queueMicrotask.bind(
                    typeof window !== "undefined" ? window : global
                  )
                : // reuse resolved promise, and allocate it lazily
                  (cb) =>
                    (promise || (promise = Promise.resolve()))
                      .then(cb)
                      .catch((err) =>
                        setTimeout(() => {
                          throw err;
                        }, 0)
                      );
          }).call(this);
        }).call(
          this,
          typeof global !== "undefined"
            ? global
            : typeof self !== "undefined"
            ? self
            : typeof window !== "undefined"
            ? window
            : {}
        );
      },
      {},
    ],
    78: [
      function (require, module, exports) {
        var grammar = (module.exports = {
          v: [
            {
              name: "version",
              reg: /^(\d*)$/,
            },
          ],
          o: [
            {
              // o=- 20518 0 IN IP4 203.0.113.1
              // NB: sessionId will be a String in most cases because it is huge
              name: "origin",
              reg: /^(\S*) (\d*) (\d*) (\S*) IP(\d) (\S*)/,
              names: [
                "username",
                "sessionId",
                "sessionVersion",
                "netType",
                "ipVer",
                "address",
              ],
              format: "%s %s %d %s IP%d %s",
            },
          ],
          // default parsing of these only (though some of these feel outdated)
          s: [{ name: "name" }],
          i: [{ name: "description" }],
          u: [{ name: "uri" }],
          e: [{ name: "email" }],
          p: [{ name: "phone" }],
          z: [{ name: "timezones" }], // TODO: this one can actually be parsed properly...
          r: [{ name: "repeats" }], // TODO: this one can also be parsed properly
          // k: [{}], // outdated thing ignored
          t: [
            {
              // t=0 0
              name: "timing",
              reg: /^(\d*) (\d*)/,
              names: ["start", "stop"],
              format: "%d %d",
            },
          ],
          c: [
            {
              // c=IN IP4 10.47.197.26
              name: "connection",
              reg: /^IN IP(\d) (\S*)/,
              names: ["version", "ip"],
              format: "IN IP%d %s",
            },
          ],
          b: [
            {
              // b=AS:4000
              push: "bandwidth",
              reg: /^(TIAS|AS|CT|RR|RS):(\d*)/,
              names: ["type", "limit"],
              format: "%s:%s",
            },
          ],
          m: [
            {
              // m=video 51744 RTP/AVP 126 97 98 34 31
              // NB: special - pushes to session
              // TODO: rtp/fmtp should be filtered by the payloads found here?
              reg: /^(\w*) (\d*) ([\w/]*)(?: (.*))?/,
              names: ["type", "port", "protocol", "payloads"],
              format: "%s %d %s %s",
            },
          ],
          a: [
            {
              // a=rtpmap:110 opus/48000/2
              push: "rtp",
              reg: /^rtpmap:(\d*) ([\w\-.]*)(?:\s*\/(\d*)(?:\s*\/(\S*))?)?/,
              names: ["payload", "codec", "rate", "encoding"],
              format: function (o) {
                return o.encoding
                  ? "rtpmap:%d %s/%s/%s"
                  : o.rate
                  ? "rtpmap:%d %s/%s"
                  : "rtpmap:%d %s";
              },
            },
            {
              // a=fmtp:108 profile-level-id=24;object=23;bitrate=64000
              // a=fmtp:111 minptime=10; useinbandfec=1
              push: "fmtp",
              reg: /^fmtp:(\d*) ([\S| ]*)/,
              names: ["payload", "config"],
              format: "fmtp:%d %s",
            },
            {
              // a=control:streamid=0
              name: "control",
              reg: /^control:(.*)/,
              format: "control:%s",
            },
            {
              // a=rtcp:65179 IN IP4 193.84.77.194
              name: "rtcp",
              reg: /^rtcp:(\d*)(?: (\S*) IP(\d) (\S*))?/,
              names: ["port", "netType", "ipVer", "address"],
              format: function (o) {
                return o.address != null ? "rtcp:%d %s IP%d %s" : "rtcp:%d";
              },
            },
            {
              // a=rtcp-fb:98 trr-int 100
              push: "rtcpFbTrrInt",
              reg: /^rtcp-fb:(\*|\d*) trr-int (\d*)/,
              names: ["payload", "value"],
              format: "rtcp-fb:%s trr-int %d",
            },
            {
              // a=rtcp-fb:98 nack rpsi
              push: "rtcpFb",
              reg: /^rtcp-fb:(\*|\d*) ([\w-_]*)(?: ([\w-_]*))?/,
              names: ["payload", "type", "subtype"],
              format: function (o) {
                return o.subtype != null ? "rtcp-fb:%s %s %s" : "rtcp-fb:%s %s";
              },
            },
            {
              // a=extmap:2 urn:ietf:params:rtp-hdrext:toffset
              // a=extmap:1/recvonly URI-gps-string
              // a=extmap:3 urn:ietf:params:rtp-hdrext:encrypt urn:ietf:params:rtp-hdrext:smpte-tc 25@600/24
              push: "ext",
              reg: /^extmap:(\d+)(?:\/(\w+))?(?: (urn:ietf:params:rtp-hdrext:encrypt))? (\S*)(?: (\S*))?/,
              names: ["value", "direction", "encrypt-uri", "uri", "config"],
              format: function (o) {
                return (
                  "extmap:%d" +
                  (o.direction ? "/%s" : "%v") +
                  (o["encrypt-uri"] ? " %s" : "%v") +
                  " %s" +
                  (o.config ? " %s" : "")
                );
              },
            },
            {
              // a=extmap-allow-mixed
              name: "extmapAllowMixed",
              reg: /^(extmap-allow-mixed)/,
            },
            {
              // a=crypto:1 AES_CM_128_HMAC_SHA1_80 inline:PS1uQCVeeCFCanVmcjkpPywjNWhcYD0mXXtxaVBR|2^20|1:32
              push: "crypto",
              reg: /^crypto:(\d*) ([\w_]*) (\S*)(?: (\S*))?/,
              names: ["id", "suite", "config", "sessionConfig"],
              format: function (o) {
                return o.sessionConfig != null
                  ? "crypto:%d %s %s %s"
                  : "crypto:%d %s %s";
              },
            },
            {
              // a=setup:actpass
              name: "setup",
              reg: /^setup:(\w*)/,
              format: "setup:%s",
            },
            {
              // a=connection:new
              name: "connectionType",
              reg: /^connection:(new|existing)/,
              format: "connection:%s",
            },
            {
              // a=mid:1
              name: "mid",
              reg: /^mid:([^\s]*)/,
              format: "mid:%s",
            },
            {
              // a=msid:0c8b064d-d807-43b4-b434-f92a889d8587 98178685-d409-46e0-8e16-7ef0db0db64a
              name: "msid",
              reg: /^msid:(.*)/,
              format: "msid:%s",
            },
            {
              // a=ptime:20
              name: "ptime",
              reg: /^ptime:(\d*(?:\.\d*)*)/,
              format: "ptime:%d",
            },
            {
              // a=maxptime:60
              name: "maxptime",
              reg: /^maxptime:(\d*(?:\.\d*)*)/,
              format: "maxptime:%d",
            },
            {
              // a=sendrecv
              name: "direction",
              reg: /^(sendrecv|recvonly|sendonly|inactive)/,
            },
            {
              // a=ice-lite
              name: "icelite",
              reg: /^(ice-lite)/,
            },
            {
              // a=ice-ufrag:F7gI
              name: "iceUfrag",
              reg: /^ice-ufrag:(\S*)/,
              format: "ice-ufrag:%s",
            },
            {
              // a=ice-pwd:x9cml/YzichV2+XlhiMu8g
              name: "icePwd",
              reg: /^ice-pwd:(\S*)/,
              format: "ice-pwd:%s",
            },
            {
              // a=fingerprint:SHA-1 00:11:22:33:44:55:66:77:88:99:AA:BB:CC:DD:EE:FF:00:11:22:33
              name: "fingerprint",
              reg: /^fingerprint:(\S*) (\S*)/,
              names: ["type", "hash"],
              format: "fingerprint:%s %s",
            },
            {
              // a=candidate:0 1 UDP 2113667327 203.0.113.1 54400 typ host
              // a=candidate:1162875081 1 udp 2113937151 192.168.34.75 60017 typ host generation 0 network-id 3 network-cost 10
              // a=candidate:3289912957 2 udp 1845501695 193.84.77.194 60017 typ srflx raddr 192.168.34.75 rport 60017 generation 0 network-id 3 network-cost 10
              // a=candidate:229815620 1 tcp 1518280447 192.168.150.19 60017 typ host tcptype active generation 0 network-id 3 network-cost 10
              // a=candidate:3289912957 2 tcp 1845501695 193.84.77.194 60017 typ srflx raddr 192.168.34.75 rport 60017 tcptype passive generation 0 network-id 3 network-cost 10
              push: "candidates",
              reg: /^candidate:(\S*) (\d*) (\S*) (\d*) (\S*) (\d*) typ (\S*)(?: raddr (\S*) rport (\d*))?(?: tcptype (\S*))?(?: generation (\d*))?(?: network-id (\d*))?(?: network-cost (\d*))?/,
              names: [
                "foundation",
                "component",
                "transport",
                "priority",
                "ip",
                "port",
                "type",
                "raddr",
                "rport",
                "tcptype",
                "generation",
                "network-id",
                "network-cost",
              ],
              format: function (o) {
                var str = "candidate:%s %d %s %d %s %d typ %s";

                str += o.raddr != null ? " raddr %s rport %d" : "%v%v";

                // NB: candidate has three optional chunks, so %void middles one if it's missing
                str += o.tcptype != null ? " tcptype %s" : "%v";

                if (o.generation != null) {
                  str += " generation %d";
                }

                str += o["network-id"] != null ? " network-id %d" : "%v";
                str += o["network-cost"] != null ? " network-cost %d" : "%v";
                return str;
              },
            },
            {
              // a=end-of-candidates (keep after the candidates line for readability)
              name: "endOfCandidates",
              reg: /^(end-of-candidates)/,
            },
            {
              // a=remote-candidates:1 203.0.113.1 54400 2 203.0.113.1 54401 ...
              name: "remoteCandidates",
              reg: /^remote-candidates:(.*)/,
              format: "remote-candidates:%s",
            },
            {
              // a=ice-options:google-ice
              name: "iceOptions",
              reg: /^ice-options:(\S*)/,
              format: "ice-options:%s",
            },
            {
              // a=ssrc:2566107569 cname:t9YU8M1UxTF8Y1A1
              push: "ssrcs",
              reg: /^ssrc:(\d*) ([\w_-]*)(?::(.*))?/,
              names: ["id", "attribute", "value"],
              format: function (o) {
                var str = "ssrc:%d";
                if (o.attribute != null) {
                  str += " %s";
                  if (o.value != null) {
                    str += ":%s";
                  }
                }
                return str;
              },
            },
            {
              // a=ssrc-group:FEC 1 2
              // a=ssrc-group:FEC-FR 3004364195 1080772241
              push: "ssrcGroups",
              // token-char = %x21 / %x23-27 / %x2A-2B / %x2D-2E / %x30-39 / %x41-5A / %x5E-7E
              reg: /^ssrc-group:([\x21\x23\x24\x25\x26\x27\x2A\x2B\x2D\x2E\w]*) (.*)/,
              names: ["semantics", "ssrcs"],
              format: "ssrc-group:%s %s",
            },
            {
              // a=msid-semantic: WMS Jvlam5X3SX1OP6pn20zWogvaKJz5Hjf9OnlV
              name: "msidSemantic",
              reg: /^msid-semantic:\s?(\w*) (\S*)/,
              names: ["semantic", "token"],
              format: "msid-semantic: %s %s", // space after ':' is not accidental
            },
            {
              // a=group:BUNDLE audio video
              push: "groups",
              reg: /^group:(\w*) (.*)/,
              names: ["type", "mids"],
              format: "group:%s %s",
            },
            {
              // a=rtcp-mux
              name: "rtcpMux",
              reg: /^(rtcp-mux)/,
            },
            {
              // a=rtcp-rsize
              name: "rtcpRsize",
              reg: /^(rtcp-rsize)/,
            },
            {
              // a=sctpmap:5000 webrtc-datachannel 1024
              name: "sctpmap",
              reg: /^sctpmap:([\w_/]*) (\S*)(?: (\S*))?/,
              names: ["sctpmapNumber", "app", "maxMessageSize"],
              format: function (o) {
                return o.maxMessageSize != null
                  ? "sctpmap:%s %s %s"
                  : "sctpmap:%s %s";
              },
            },
            {
              // a=x-google-flag:conference
              name: "xGoogleFlag",
              reg: /^x-google-flag:([^\s]*)/,
              format: "x-google-flag:%s",
            },
            {
              // a=rid:1 send max-width=1280;max-height=720;max-fps=30;depend=0
              push: "rids",
              reg: /^rid:([\d\w]+) (\w+)(?: ([\S| ]*))?/,
              names: ["id", "direction", "params"],
              format: function (o) {
                return o.params ? "rid:%s %s %s" : "rid:%s %s";
              },
            },
            {
              // a=imageattr:97 send [x=800,y=640,sar=1.1,q=0.6] [x=480,y=320] recv [x=330,y=250]
              // a=imageattr:* send [x=800,y=640] recv *
              // a=imageattr:100 recv [x=320,y=240]
              push: "imageattrs",
              reg: new RegExp(
                // a=imageattr:97
                "^imageattr:(\\d+|\\*)" +
                  // send [x=800,y=640,sar=1.1,q=0.6] [x=480,y=320]
                  "[\\s\\t]+(send|recv)[\\s\\t]+(\\*|\\[\\S+\\](?:[\\s\\t]+\\[\\S+\\])*)" +
                  // recv [x=330,y=250]
                  "(?:[\\s\\t]+(recv|send)[\\s\\t]+(\\*|\\[\\S+\\](?:[\\s\\t]+\\[\\S+\\])*))?"
              ),
              names: ["pt", "dir1", "attrs1", "dir2", "attrs2"],
              format: function (o) {
                return "imageattr:%s %s %s" + (o.dir2 ? " %s %s" : "");
              },
            },
            {
              // a=simulcast:send 1,2,3;~4,~5 recv 6;~7,~8
              // a=simulcast:recv 1;4,5 send 6;7
              name: "simulcast",
              reg: new RegExp(
                // a=simulcast:
                "^simulcast:" +
                  // send 1,2,3;~4,~5
                  "(send|recv) ([a-zA-Z0-9\\-_~;,]+)" +
                  // space + recv 6;~7,~8
                  "(?:\\s?(send|recv) ([a-zA-Z0-9\\-_~;,]+))?" +
                  // end
                  "$"
              ),
              names: ["dir1", "list1", "dir2", "list2"],
              format: function (o) {
                return "simulcast:%s %s" + (o.dir2 ? " %s %s" : "");
              },
            },
            {
              // old simulcast draft 03 (implemented by Firefox)
              //   https://tools.ietf.org/html/draft-ietf-mmusic-sdp-simulcast-03
              // a=simulcast: recv pt=97;98 send pt=97
              // a=simulcast: send rid=5;6;7 paused=6,7
              name: "simulcast_03",
              reg: /^simulcast:[\s\t]+([\S+\s\t]+)$/,
              names: ["value"],
              format: "simulcast: %s",
            },
            {
              // a=framerate:25
              // a=framerate:29.97
              name: "framerate",
              reg: /^framerate:(\d+(?:$|\.\d+))/,
              format: "framerate:%s",
            },
            {
              // RFC4570
              // a=source-filter: incl IN IP4 239.5.2.31 10.1.15.5
              name: "sourceFilter",
              reg: /^source-filter: *(excl|incl) (\S*) (IP4|IP6|\*) (\S*) (.*)/,
              names: [
                "filterMode",
                "netType",
                "addressTypes",
                "destAddress",
                "srcList",
              ],
              format: "source-filter: %s %s %s %s %s",
            },
            {
              // a=bundle-only
              name: "bundleOnly",
              reg: /^(bundle-only)/,
            },
            {
              // a=label:1
              name: "label",
              reg: /^label:(.+)/,
              format: "label:%s",
            },
            {
              // RFC version 26 for SCTP over DTLS
              // https://tools.ietf.org/html/draft-ietf-mmusic-sctp-sdp-26#section-5
              name: "sctpPort",
              reg: /^sctp-port:(\d+)$/,
              format: "sctp-port:%s",
            },
            {
              // RFC version 26 for SCTP over DTLS
              // https://tools.ietf.org/html/draft-ietf-mmusic-sctp-sdp-26#section-6
              name: "maxMessageSize",
              reg: /^max-message-size:(\d+)$/,
              format: "max-message-size:%s",
            },
            {
              // RFC7273
              // a=ts-refclk:ptp=IEEE1588-2008:39-A7-94-FF-FE-07-CB-D0:37
              push: "tsRefClocks",
              reg: /^ts-refclk:([^\s=]*)(?:=(\S*))?/,
              names: ["clksrc", "clksrcExt"],
              format: function (o) {
                return "ts-refclk:%s" + (o.clksrcExt != null ? "=%s" : "");
              },
            },
            {
              // RFC7273
              // a=mediaclk:direct=963214424
              name: "mediaClk",
              reg: /^mediaclk:(?:id=(\S*))? *([^\s=]*)(?:=(\S*))?(?: *rate=(\d+)\/(\d+))?/,
              names: [
                "id",
                "mediaClockName",
                "mediaClockValue",
                "rateNumerator",
                "rateDenominator",
              ],
              format: function (o) {
                var str = "mediaclk:";
                str += o.id != null ? "id=%s %s" : "%v%s";
                str += o.mediaClockValue != null ? "=%s" : "";
                str += o.rateNumerator != null ? " rate=%s" : "";
                str += o.rateDenominator != null ? "/%s" : "";
                return str;
              },
            },
            {
              // a=keywds:keywords
              name: "keywords",
              reg: /^keywds:(.+)$/,
              format: "keywds:%s",
            },
            {
              // a=content:main
              name: "content",
              reg: /^content:(.+)/,
              format: "content:%s",
            },
            // BFCP https://tools.ietf.org/html/rfc4583
            {
              // a=floorctrl:c-s
              name: "bfcpFloorCtrl",
              reg: /^floorctrl:(c-only|s-only|c-s)/,
              format: "floorctrl:%s",
            },
            {
              // a=confid:1
              name: "bfcpConfId",
              reg: /^confid:(\d+)/,
              format: "confid:%s",
            },
            {
              // a=userid:1
              name: "bfcpUserId",
              reg: /^userid:(\d+)/,
              format: "userid:%s",
            },
            {
              // a=floorid:1
              name: "bfcpFloorId",
              reg: /^floorid:(.+) (?:m-stream|mstrm):(.+)/,
              names: ["id", "mStream"],
              format: "floorid:%s mstrm:%s",
            },
            {
              // any a= that we don't understand is kept verbatim on media.invalid
              push: "invalid",
              names: ["value"],
            },
          ],
        });

        // set sensible defaults to avoid polluting the grammar with boring details
        Object.keys(grammar).forEach(function (key) {
          var objs = grammar[key];
          objs.forEach(function (obj) {
            if (!obj.reg) {
              obj.reg = /(.*)/;
            }
            if (!obj.format) {
              obj.format = "%s";
            }
          });
        });
      },
      {},
    ],
    79: [
      function (require, module, exports) {
        var parser = require("./parser");
        var writer = require("./writer");

        exports.write = writer;
        exports.parse = parser.parse;
        exports.parseParams = parser.parseParams;
        exports.parseFmtpConfig = parser.parseFmtpConfig; // Alias of parseParams().
        exports.parsePayloads = parser.parsePayloads;
        exports.parseRemoteCandidates = parser.parseRemoteCandidates;
        exports.parseImageAttributes = parser.parseImageAttributes;
        exports.parseSimulcastStreamList = parser.parseSimulcastStreamList;
      },
      { "./parser": 80, "./writer": 81 },
    ],
    80: [
      function (require, module, exports) {
        var toIntIfInt = function (v) {
          return String(Number(v)) === v ? Number(v) : v;
        };

        var attachProperties = function (match, location, names, rawName) {
          if (rawName && !names) {
            location[rawName] = toIntIfInt(match[1]);
          } else {
            for (var i = 0; i < names.length; i += 1) {
              if (match[i + 1] != null) {
                location[names[i]] = toIntIfInt(match[i + 1]);
              }
            }
          }
        };

        var parseReg = function (obj, location, content) {
          var needsBlank = obj.name && obj.names;
          if (obj.push && !location[obj.push]) {
            location[obj.push] = [];
          } else if (needsBlank && !location[obj.name]) {
            location[obj.name] = {};
          }
          var keyLocation = obj.push
            ? {} // blank object that will be pushed
            : needsBlank
            ? location[obj.name]
            : location; // otherwise, named location or root

          attachProperties(
            content.match(obj.reg),
            keyLocation,
            obj.names,
            obj.name
          );

          if (obj.push) {
            location[obj.push].push(keyLocation);
          }
        };

        var grammar = require("./grammar");
        var validLine = RegExp.prototype.test.bind(/^([a-z])=(.*)/);

        exports.parse = function (sdp) {
          var session = {},
            media = [],
            location = session; // points at where properties go under (one of the above)

          // parse lines we understand
          sdp
            .split(/(\r\n|\r|\n)/)
            .filter(validLine)
            .forEach(function (l) {
              var type = l[0];
              var content = l.slice(2);
              if (type === "m") {
                media.push({ rtp: [], fmtp: [] });
                location = media[media.length - 1]; // point at latest media line
              }

              for (var j = 0; j < (grammar[type] || []).length; j += 1) {
                var obj = grammar[type][j];
                if (obj.reg.test(content)) {
                  return parseReg(obj, location, content);
                }
              }
            });

          session.media = media; // link it up
          return session;
        };

        var paramReducer = function (acc, expr) {
          var s = expr.split(/=(.+)/, 2);
          if (s.length === 2) {
            acc[s[0]] = toIntIfInt(s[1]);
          } else if (s.length === 1 && expr.length > 1) {
            acc[s[0]] = undefined;
          }
          return acc;
        };

        exports.parseParams = function (str) {
          return str.split(/;\s?/).reduce(paramReducer, {});
        };

        // For backward compatibility - alias will be removed in 3.0.0
        exports.parseFmtpConfig = exports.parseParams;

        exports.parsePayloads = function (str) {
          return str.toString().split(" ").map(Number);
        };

        exports.parseRemoteCandidates = function (str) {
          var candidates = [];
          var parts = str.split(" ").map(toIntIfInt);
          for (var i = 0; i < parts.length; i += 3) {
            candidates.push({
              component: parts[i],
              ip: parts[i + 1],
              port: parts[i + 2],
            });
          }
          return candidates;
        };

        exports.parseImageAttributes = function (str) {
          return str.split(" ").map(function (item) {
            return item
              .substring(1, item.length - 1)
              .split(",")
              .reduce(paramReducer, {});
          });
        };

        exports.parseSimulcastStreamList = function (str) {
          return str.split(";").map(function (stream) {
            return stream.split(",").map(function (format) {
              var scid,
                paused = false;

              if (format[0] !== "~") {
                scid = toIntIfInt(format);
              } else {
                scid = toIntIfInt(format.substring(1, format.length));
                paused = true;
              }

              return {
                scid: scid,
                paused: paused,
              };
            });
          });
        };
      },
      { "./grammar": 78 },
    ],
    81: [
      function (require, module, exports) {
        var grammar = require("./grammar");

        // customized util.format - discards excess arguments and can void middle ones
        var formatRegExp = /%[sdv%]/g;
        var format = function (formatStr) {
          var i = 1;
          var args = arguments;
          var len = args.length;
          return formatStr.replace(formatRegExp, function (x) {
            if (i >= len) {
              return x; // missing argument
            }
            var arg = args[i];
            i += 1;
            switch (x) {
              case "%%":
                return "%";
              case "%s":
                return String(arg);
              case "%d":
                return Number(arg);
              case "%v":
                return "";
            }
          });
          // NB: we discard excess arguments - they are typically undefined from makeLine
        };

        var makeLine = function (type, obj, location) {
          var str =
            obj.format instanceof Function
              ? obj.format(obj.push ? location : location[obj.name])
              : obj.format;

          var args = [type + "=" + str];
          if (obj.names) {
            for (var i = 0; i < obj.names.length; i += 1) {
              var n = obj.names[i];
              if (obj.name) {
                args.push(location[obj.name][n]);
              } else {
                // for mLine and push attributes
                args.push(location[obj.names[i]]);
              }
            }
          } else {
            args.push(location[obj.name]);
          }
          return format.apply(null, args);
        };

        // RFC specified order
        // TODO: extend this with all the rest
        var defaultOuterOrder = [
          "v",
          "o",
          "s",
          "i",
          "u",
          "e",
          "p",
          "c",
          "b",
          "t",
          "r",
          "z",
          "a",
        ];
        var defaultInnerOrder = ["i", "c", "b", "a"];

        module.exports = function (session, opts) {
          opts = opts || {};
          // ensure certain properties exist
          if (session.version == null) {
            session.version = 0; // 'v=0' must be there (only defined version atm)
          }
          if (session.name == null) {
            session.name = " "; // 's= ' must be there if no meaningful name set
          }
          session.media.forEach(function (mLine) {
            if (mLine.payloads == null) {
              mLine.payloads = "";
            }
          });

          var outerOrder = opts.outerOrder || defaultOuterOrder;
          var innerOrder = opts.innerOrder || defaultInnerOrder;
          var sdp = [];

          // loop through outerOrder for matching properties on session
          outerOrder.forEach(function (type) {
            grammar[type].forEach(function (obj) {
              if (obj.name in session && session[obj.name] != null) {
                sdp.push(makeLine(type, obj, session));
              } else if (obj.push in session && session[obj.push] != null) {
                session[obj.push].forEach(function (el) {
                  sdp.push(makeLine(type, obj, el));
                });
              }
            });
          });

          // then for each media line, follow the innerOrder
          session.media.forEach(function (mLine) {
            sdp.push(makeLine("m", grammar.m[0], mLine));

            innerOrder.forEach(function (type) {
              grammar[type].forEach(function (obj) {
                if (obj.name in mLine && mLine[obj.name] != null) {
                  sdp.push(makeLine(type, obj, mLine));
                } else if (obj.push in mLine && mLine[obj.push] != null) {
                  mLine[obj.push].forEach(function (el) {
                    sdp.push(makeLine(type, obj, el));
                  });
                }
              });
            });
          });

          return sdp.join("\r\n") + "\r\n";
        };
      },
      { "./grammar": 78 },
    ],
    82: [
      function (require, module, exports) {
        "use strict";
        /**
         * Initialize backoff timer with `opts`.
         *
         * - `min` initial timeout in milliseconds [100]
         * - `max` max timeout [10000]
         * - `jitter` [0]
         * - `factor` [2]
         *
         * @param {Object} opts
         * @api public
         */
        Object.defineProperty(exports, "__esModule", { value: true });
        exports.Backoff = void 0;
        function Backoff(opts) {
          opts = opts || {};
          this.ms = opts.min || 100;
          this.max = opts.max || 10000;
          this.factor = opts.factor || 2;
          this.jitter = opts.jitter > 0 && opts.jitter <= 1 ? opts.jitter : 0;
          this.attempts = 0;
        }
        exports.Backoff = Backoff;
        /**
         * Return the backoff duration.
         *
         * @return {Number}
         * @api public
         */
        Backoff.prototype.duration = function () {
          var ms = this.ms * Math.pow(this.factor, this.attempts++);
          if (this.jitter) {
            var rand = Math.random();
            var deviation = Math.floor(rand * this.jitter * ms);
            ms =
              (Math.floor(rand * 10) & 1) == 0
                ? ms - deviation
                : ms + deviation;
          }
          return Math.min(ms, this.max) | 0;
        };
        /**
         * Reset the number of attempts.
         *
         * @api public
         */
        Backoff.prototype.reset = function () {
          this.attempts = 0;
        };
        /**
         * Set the minimum duration
         *
         * @api public
         */
        Backoff.prototype.setMin = function (min) {
          this.ms = min;
        };
        /**
         * Set the maximum duration
         *
         * @api public
         */
        Backoff.prototype.setMax = function (max) {
          this.max = max;
        };
        /**
         * Set the jitter
         *
         * @api public
         */
        Backoff.prototype.setJitter = function (jitter) {
          this.jitter = jitter;
        };
      },
      {},
    ],
    83: [
      function (require, module, exports) {
        "use strict";
        var __importDefault =
          (this && this.__importDefault) ||
          function (mod) {
            return mod && mod.__esModule ? mod : { default: mod };
          };
        Object.defineProperty(exports, "__esModule", { value: true });
        exports.default =
          exports.connect =
          exports.io =
          exports.Socket =
          exports.Manager =
          exports.protocol =
            void 0;
        const url_js_1 = require("./url.js");
        const manager_js_1 = require("./manager.js");
        Object.defineProperty(exports, "Manager", {
          enumerable: true,
          get: function () {
            return manager_js_1.Manager;
          },
        });
        const socket_js_1 = require("./socket.js");
        Object.defineProperty(exports, "Socket", {
          enumerable: true,
          get: function () {
            return socket_js_1.Socket;
          },
        });
        const debug_1 = __importDefault(require("debug")); // debug()
        const debug = debug_1.default("socket.io-client"); // debug()
        /**
         * Managers cache.
         */
        const cache = {};
        function lookup(uri, opts) {
          if (typeof uri === "object") {
            opts = uri;
            uri = undefined;
          }
          opts = opts || {};
          const parsed = url_js_1.url(uri, opts.path || "/socket.io");
          const source = parsed.source;
          const id = parsed.id;
          const path = parsed.path;
          const sameNamespace = cache[id] && path in cache[id]["nsps"];
          const newConnection =
            opts.forceNew ||
            opts["force new connection"] ||
            false === opts.multiplex ||
            sameNamespace;
          let io;
          if (newConnection) {
            debug("ignoring socket cache for %s", source);
            io = new manager_js_1.Manager(source, opts);
          } else {
            if (!cache[id]) {
              debug("new io instance for %s", source);
              cache[id] = new manager_js_1.Manager(source, opts);
            }
            io = cache[id];
          }
          if (parsed.query && !opts.query) {
            opts.query = parsed.queryKey;
          }
          return io.socket(parsed.path, opts);
        }
        exports.io = lookup;
        exports.connect = lookup;
        exports.default = lookup;
        // so that "lookup" can be used both as a function (e.g. `io(...)`) and as a
        // namespace (e.g. `io.connect(...)`), for backward compatibility
        Object.assign(lookup, {
          Manager: manager_js_1.Manager,
          Socket: socket_js_1.Socket,
          io: lookup,
          connect: lookup,
        });
        /**
         * Protocol version.
         *
         * @public
         */
        var socket_io_parser_1 = require("socket.io-parser");
        Object.defineProperty(exports, "protocol", {
          enumerable: true,
          get: function () {
            return socket_io_parser_1.protocol;
          },
        });

        module.exports = lookup;
      },
      {
        "./manager.js": 84,
        "./socket.js": 86,
        "./url.js": 87,
        debug: 88,
        "socket.io-parser": 92,
      },
    ],
    84: [
      function (require, module, exports) {
        "use strict";
        var __createBinding =
          (this && this.__createBinding) ||
          (Object.create
            ? function (o, m, k, k2) {
                if (k2 === undefined) k2 = k;
                Object.defineProperty(o, k2, {
                  enumerable: true,
                  get: function () {
                    return m[k];
                  },
                });
              }
            : function (o, m, k, k2) {
                if (k2 === undefined) k2 = k;
                o[k2] = m[k];
              });
        var __setModuleDefault =
          (this && this.__setModuleDefault) ||
          (Object.create
            ? function (o, v) {
                Object.defineProperty(o, "default", {
                  enumerable: true,
                  value: v,
                });
              }
            : function (o, v) {
                o["default"] = v;
              });
        var __importStar =
          (this && this.__importStar) ||
          function (mod) {
            if (mod && mod.__esModule) return mod;
            var result = {};
            if (mod != null)
              for (var k in mod)
                if (
                  k !== "default" &&
                  Object.prototype.hasOwnProperty.call(mod, k)
                )
                  __createBinding(result, mod, k);
            __setModuleDefault(result, mod);
            return result;
          };
        var __importDefault =
          (this && this.__importDefault) ||
          function (mod) {
            return mod && mod.__esModule ? mod : { default: mod };
          };
        Object.defineProperty(exports, "__esModule", { value: true });
        exports.Manager = void 0;
        const engine_io_client_1 = require("engine.io-client");
        const socket_js_1 = require("./socket.js");
        const parser = __importStar(require("socket.io-parser"));
        const on_js_1 = require("./on.js");
        const backo2_js_1 = require("./contrib/backo2.js");
        const component_emitter_1 = require("@socket.io/component-emitter");
        const debug_1 = __importDefault(require("debug")); // debug()
        const debug = debug_1.default("socket.io-client:manager"); // debug()
        class Manager extends component_emitter_1.Emitter {
          constructor(uri, opts) {
            var _a;
            super();
            this.nsps = {};
            this.subs = [];
            if (uri && "object" === typeof uri) {
              opts = uri;
              uri = undefined;
            }
            opts = opts || {};
            opts.path = opts.path || "/socket.io";
            this.opts = opts;
            engine_io_client_1.installTimerFunctions(this, opts);
            this.reconnection(opts.reconnection !== false);
            this.reconnectionAttempts(opts.reconnectionAttempts || Infinity);
            this.reconnectionDelay(opts.reconnectionDelay || 1000);
            this.reconnectionDelayMax(opts.reconnectionDelayMax || 5000);
            this.randomizationFactor(
              (_a = opts.randomizationFactor) !== null && _a !== void 0
                ? _a
                : 0.5
            );
            this.backoff = new backo2_js_1.Backoff({
              min: this.reconnectionDelay(),
              max: this.reconnectionDelayMax(),
              jitter: this.randomizationFactor(),
            });
            this.timeout(null == opts.timeout ? 20000 : opts.timeout);
            this._readyState = "closed";
            this.uri = uri;
            const _parser = opts.parser || parser;
            this.encoder = new _parser.Encoder();
            this.decoder = new _parser.Decoder();
            this._autoConnect = opts.autoConnect !== false;
            if (this._autoConnect) this.open();
          }
          reconnection(v) {
            if (!arguments.length) return this._reconnection;
            this._reconnection = !!v;
            return this;
          }
          reconnectionAttempts(v) {
            if (v === undefined) return this._reconnectionAttempts;
            this._reconnectionAttempts = v;
            return this;
          }
          reconnectionDelay(v) {
            var _a;
            if (v === undefined) return this._reconnectionDelay;
            this._reconnectionDelay = v;
            (_a = this.backoff) === null || _a === void 0
              ? void 0
              : _a.setMin(v);
            return this;
          }
          randomizationFactor(v) {
            var _a;
            if (v === undefined) return this._randomizationFactor;
            this._randomizationFactor = v;
            (_a = this.backoff) === null || _a === void 0
              ? void 0
              : _a.setJitter(v);
            return this;
          }
          reconnectionDelayMax(v) {
            var _a;
            if (v === undefined) return this._reconnectionDelayMax;
            this._reconnectionDelayMax = v;
            (_a = this.backoff) === null || _a === void 0
              ? void 0
              : _a.setMax(v);
            return this;
          }
          timeout(v) {
            if (!arguments.length) return this._timeout;
            this._timeout = v;
            return this;
          }
          /**
           * Starts trying to reconnect if reconnection is enabled and we have not
           * started reconnecting yet
           *
           * @private
           */
          maybeReconnectOnOpen() {
            // Only try to reconnect if it's the first time we're connecting
            if (
              !this._reconnecting &&
              this._reconnection &&
              this.backoff.attempts === 0
            ) {
              // keeps reconnection from firing twice for the same reconnection loop
              this.reconnect();
            }
          }
          /**
           * Sets the current transport `socket`.
           *
           * @param {Function} fn - optional, callback
           * @return self
           * @public
           */
          open(fn) {
            debug("readyState %s", this._readyState);
            if (~this._readyState.indexOf("open")) return this;
            debug("opening %s", this.uri);
            this.engine = new engine_io_client_1.Socket(this.uri, this.opts);
            const socket = this.engine;
            const self = this;
            this._readyState = "opening";
            this.skipReconnect = false;
            // emit `open`
            const openSubDestroy = on_js_1.on(socket, "open", function () {
              self.onopen();
              fn && fn();
            });
            // emit `error`
            const errorSub = on_js_1.on(socket, "error", (err) => {
              debug("error");
              self.cleanup();
              self._readyState = "closed";
              this.emitReserved("error", err);
              if (fn) {
                fn(err);
              } else {
                // Only do this if there is no fn to handle the error
                self.maybeReconnectOnOpen();
              }
            });
            if (false !== this._timeout) {
              const timeout = this._timeout;
              debug("connect attempt will timeout after %d", timeout);
              if (timeout === 0) {
                openSubDestroy(); // prevents a race condition with the 'open' event
              }
              // set timer
              const timer = this.setTimeoutFn(() => {
                debug("connect attempt timed out after %d", timeout);
                openSubDestroy();
                socket.close();
                // @ts-ignore
                socket.emit("error", new Error("timeout"));
              }, timeout);
              if (this.opts.autoUnref) {
                timer.unref();
              }
              this.subs.push(function subDestroy() {
                clearTimeout(timer);
              });
            }
            this.subs.push(openSubDestroy);
            this.subs.push(errorSub);
            return this;
          }
          /**
           * Alias for open()
           *
           * @return self
           * @public
           */
          connect(fn) {
            return this.open(fn);
          }
          /**
           * Called upon transport open.
           *
           * @private
           */
          onopen() {
            debug("open");
            // clear old subs
            this.cleanup();
            // mark as open
            this._readyState = "open";
            this.emitReserved("open");
            // add new subs
            const socket = this.engine;
            this.subs.push(
              on_js_1.on(socket, "ping", this.onping.bind(this)),
              on_js_1.on(socket, "data", this.ondata.bind(this)),
              on_js_1.on(socket, "error", this.onerror.bind(this)),
              on_js_1.on(socket, "close", this.onclose.bind(this)),
              on_js_1.on(this.decoder, "decoded", this.ondecoded.bind(this))
            );
          }
          /**
           * Called upon a ping.
           *
           * @private
           */
          onping() {
            this.emitReserved("ping");
          }
          /**
           * Called with data.
           *
           * @private
           */
          ondata(data) {
            try {
              this.decoder.add(data);
            } catch (e) {
              this.onclose("parse error", e);
            }
          }
          /**
           * Called when parser fully decodes a packet.
           *
           * @private
           */
          ondecoded(packet) {
            // the nextTick call prevents an exception in a user-provided event listener from triggering a disconnection due to a "parse error"
            engine_io_client_1.nextTick(() => {
              this.emitReserved("packet", packet);
            }, this.setTimeoutFn);
          }
          /**
           * Called upon socket error.
           *
           * @private
           */
          onerror(err) {
            debug("error", err);
            this.emitReserved("error", err);
          }
          /**
           * Creates a new socket for the given `nsp`.
           *
           * @return {Socket}
           * @public
           */
          socket(nsp, opts) {
            let socket = this.nsps[nsp];
            if (!socket) {
              socket = new socket_js_1.Socket(this, nsp, opts);
              this.nsps[nsp] = socket;
            }
            return socket;
          }
          /**
           * Called upon a socket close.
           *
           * @param socket
           * @private
           */
          _destroy(socket) {
            const nsps = Object.keys(this.nsps);
            for (const nsp of nsps) {
              const socket = this.nsps[nsp];
              if (socket.active) {
                debug("socket %s is still active, skipping close", nsp);
                return;
              }
            }
            this._close();
          }
          /**
           * Writes a packet.
           *
           * @param packet
           * @private
           */
          _packet(packet) {
            debug("writing packet %j", packet);
            const encodedPackets = this.encoder.encode(packet);
            for (let i = 0; i < encodedPackets.length; i++) {
              this.engine.write(encodedPackets[i], packet.options);
            }
          }
          /**
           * Clean up transport subscriptions and packet buffer.
           *
           * @private
           */
          cleanup() {
            debug("cleanup");
            this.subs.forEach((subDestroy) => subDestroy());
            this.subs.length = 0;
            this.decoder.destroy();
          }
          /**
           * Close the current socket.
           *
           * @private
           */
          _close() {
            debug("disconnect");
            this.skipReconnect = true;
            this._reconnecting = false;
            this.onclose("forced close");
            if (this.engine) this.engine.close();
          }
          /**
           * Alias for close()
           *
           * @private
           */
          disconnect() {
            return this._close();
          }
          /**
           * Called upon engine close.
           *
           * @private
           */
          onclose(reason, description) {
            debug("closed due to %s", reason);
            this.cleanup();
            this.backoff.reset();
            this._readyState = "closed";
            this.emitReserved("close", reason, description);
            if (this._reconnection && !this.skipReconnect) {
              this.reconnect();
            }
          }
          /**
           * Attempt a reconnection.
           *
           * @private
           */
          reconnect() {
            if (this._reconnecting || this.skipReconnect) return this;
            const self = this;
            if (this.backoff.attempts >= this._reconnectionAttempts) {
              debug("reconnect failed");
              this.backoff.reset();
              this.emitReserved("reconnect_failed");
              this._reconnecting = false;
            } else {
              const delay = this.backoff.duration();
              debug("will wait %dms before reconnect attempt", delay);
              this._reconnecting = true;
              const timer = this.setTimeoutFn(() => {
                if (self.skipReconnect) return;
                debug("attempting reconnect");
                this.emitReserved("reconnect_attempt", self.backoff.attempts);
                // check again for the case socket closed in above events
                if (self.skipReconnect) return;
                self.open((err) => {
                  if (err) {
                    debug("reconnect attempt error");
                    self._reconnecting = false;
                    self.reconnect();
                    this.emitReserved("reconnect_error", err);
                  } else {
                    debug("reconnect success");
                    self.onreconnect();
                  }
                });
              }, delay);
              if (this.opts.autoUnref) {
                timer.unref();
              }
              this.subs.push(function subDestroy() {
                clearTimeout(timer);
              });
            }
          }
          /**
           * Called upon successful reconnect.
           *
           * @private
           */
          onreconnect() {
            const attempt = this.backoff.attempts;
            this._reconnecting = false;
            this.backoff.reset();
            this.emitReserved("reconnect", attempt);
          }
        }
        exports.Manager = Manager;
      },
      {
        "./contrib/backo2.js": 82,
        "./on.js": 85,
        "./socket.js": 86,
        "@socket.io/component-emitter": 1,
        debug: 88,
        "engine.io-client": 14,
        "socket.io-parser": 92,
      },
    ],
    85: [
      function (require, module, exports) {
        "use strict";
        Object.defineProperty(exports, "__esModule", { value: true });
        exports.on = void 0;
        function on(obj, ev, fn) {
          obj.on(ev, fn);
          return function subDestroy() {
            obj.off(ev, fn);
          };
        }
        exports.on = on;
      },
      {},
    ],
    86: [
      function (require, module, exports) {
        "use strict";
        var __importDefault =
          (this && this.__importDefault) ||
          function (mod) {
            return mod && mod.__esModule ? mod : { default: mod };
          };
        Object.defineProperty(exports, "__esModule", { value: true });
        exports.Socket = void 0;
        const socket_io_parser_1 = require("socket.io-parser");
        const on_js_1 = require("./on.js");
        const component_emitter_1 = require("@socket.io/component-emitter");
        const debug_1 = __importDefault(require("debug")); // debug()
        const debug = debug_1.default("socket.io-client:socket"); // debug()
        /**
         * Internal events.
         * These events can't be emitted by the user.
         */
        const RESERVED_EVENTS = Object.freeze({
          connect: 1,
          connect_error: 1,
          disconnect: 1,
          disconnecting: 1,
          // EventEmitter reserved events: https://nodejs.org/api/events.html#events_event_newlistener
          newListener: 1,
          removeListener: 1,
        });
        /**
         * A Socket is the fundamental class for interacting with the server.
         *
         * A Socket belongs to a certain Namespace (by default /) and uses an underlying {@link Manager} to communicate.
         *
         * @example
         * const socket = io();
         *
         * socket.on("connect", () => {
         *   console.log("connected");
         * });
         *
         * // send an event to the server
         * socket.emit("foo", "bar");
         *
         * socket.on("foobar", () => {
         *   // an event was received from the server
         * });
         *
         * // upon disconnection
         * socket.on("disconnect", (reason) => {
         *   console.log(`disconnected due to ${reason}`);
         * });
         */
        class Socket extends component_emitter_1.Emitter {
          /**
           * `Socket` constructor.
           */
          constructor(io, nsp, opts) {
            super();
            /**
             * Whether the socket is currently connected to the server.
             *
             * @example
             * const socket = io();
             *
             * socket.on("connect", () => {
             *   console.log(socket.connected); // true
             * });
             *
             * socket.on("disconnect", () => {
             *   console.log(socket.connected); // false
             * });
             */
            this.connected = false;
            /**
             * Buffer for packets received before the CONNECT packet
             */
            this.receiveBuffer = [];
            /**
             * Buffer for packets that will be sent once the socket is connected
             */
            this.sendBuffer = [];
            this.ids = 0;
            this.acks = {};
            this.flags = {};
            this.io = io;
            this.nsp = nsp;
            if (opts && opts.auth) {
              this.auth = opts.auth;
            }
            if (this.io._autoConnect) this.open();
          }
          /**
           * Whether the socket is currently disconnected
           *
           * @example
           * const socket = io();
           *
           * socket.on("connect", () => {
           *   console.log(socket.disconnected); // false
           * });
           *
           * socket.on("disconnect", () => {
           *   console.log(socket.disconnected); // true
           * });
           */
          get disconnected() {
            return !this.connected;
          }
          /**
           * Subscribe to open, close and packet events
           *
           * @private
           */
          subEvents() {
            if (this.subs) return;
            const io = this.io;
            this.subs = [
              on_js_1.on(io, "open", this.onopen.bind(this)),
              on_js_1.on(io, "packet", this.onpacket.bind(this)),
              on_js_1.on(io, "error", this.onerror.bind(this)),
              on_js_1.on(io, "close", this.onclose.bind(this)),
            ];
          }
          /**
           * Whether the Socket will try to reconnect when its Manager connects or reconnects.
           *
           * @example
           * const socket = io();
           *
           * console.log(socket.active); // true
           *
           * socket.on("disconnect", (reason) => {
           *   if (reason === "io server disconnect") {
           *     // the disconnection was initiated by the server, you need to manually reconnect
           *     console.log(socket.active); // false
           *   }
           *   // else the socket will automatically try to reconnect
           *   console.log(socket.active); // true
           * });
           */
          get active() {
            return !!this.subs;
          }
          /**
           * "Opens" the socket.
           *
           * @example
           * const socket = io({
           *   autoConnect: false
           * });
           *
           * socket.connect();
           */
          connect() {
            if (this.connected) return this;
            this.subEvents();
            if (!this.io["_reconnecting"]) this.io.open(); // ensure open
            if ("open" === this.io._readyState) this.onopen();
            return this;
          }
          /**
           * Alias for {@link connect()}.
           */
          open() {
            return this.connect();
          }
          /**
           * Sends a `message` event.
           *
           * This method mimics the WebSocket.send() method.
           *
           * @see https://developer.mozilla.org/en-US/docs/Web/API/WebSocket/send
           *
           * @example
           * socket.send("hello");
           *
           * // this is equivalent to
           * socket.emit("message", "hello");
           *
           * @return self
           */
          send(...args) {
            args.unshift("message");
            this.emit.apply(this, args);
            return this;
          }
          /**
           * Override `emit`.
           * If the event is in `events`, it's emitted normally.
           *
           * @example
           * socket.emit("hello", "world");
           *
           * // all serializable datastructures are supported (no need to call JSON.stringify)
           * socket.emit("hello", 1, "2", { 3: ["4"], 5: Uint8Array.from([6]) });
           *
           * // with an acknowledgement from the server
           * socket.emit("hello", "world", (val) => {
           *   // ...
           * });
           *
           * @return self
           */
          emit(ev, ...args) {
            if (RESERVED_EVENTS.hasOwnProperty(ev)) {
              throw new Error(
                '"' + ev.toString() + '" is a reserved event name'
              );
            }
            args.unshift(ev);
            const packet = {
              type: socket_io_parser_1.PacketType.EVENT,
              data: args,
            };
            packet.options = {};
            packet.options.compress = this.flags.compress !== false;
            // event ack callback
            if ("function" === typeof args[args.length - 1]) {
              const id = this.ids++;
              debug("emitting packet with ack id %d", id);
              const ack = args.pop();
              this._registerAckCallback(id, ack);
              packet.id = id;
            }
            const isTransportWritable =
              this.io.engine &&
              this.io.engine.transport &&
              this.io.engine.transport.writable;
            const discardPacket =
              this.flags.volatile && (!isTransportWritable || !this.connected);
            if (discardPacket) {
              debug(
                "discard packet as the transport is not currently writable"
              );
            } else if (this.connected) {
              this.notifyOutgoingListeners(packet);
              this.packet(packet);
            } else {
              this.sendBuffer.push(packet);
            }
            this.flags = {};
            return this;
          }
          /**
           * @private
           */
          _registerAckCallback(id, ack) {
            const timeout = this.flags.timeout;
            if (timeout === undefined) {
              this.acks[id] = ack;
              return;
            }
            // @ts-ignore
            const timer = this.io.setTimeoutFn(() => {
              delete this.acks[id];
              for (let i = 0; i < this.sendBuffer.length; i++) {
                if (this.sendBuffer[i].id === id) {
                  debug("removing packet with ack id %d from the buffer", id);
                  this.sendBuffer.splice(i, 1);
                }
              }
              debug(
                "event with ack id %d has timed out after %d ms",
                id,
                timeout
              );
              ack.call(this, new Error("operation has timed out"));
            }, timeout);
            this.acks[id] = (...args) => {
              // @ts-ignore
              this.io.clearTimeoutFn(timer);
              ack.apply(this, [null, ...args]);
            };
          }
          /**
           * Sends a packet.
           *
           * @param packet
           * @private
           */
          packet(packet) {
            packet.nsp = this.nsp;
            this.io._packet(packet);
          }
          /**
           * Called upon engine `open`.
           *
           * @private
           */
          onopen() {
            debug("transport is open - connecting");
            if (typeof this.auth == "function") {
              this.auth((data) => {
                this.packet({
                  type: socket_io_parser_1.PacketType.CONNECT,
                  data,
                });
              });
            } else {
              this.packet({
                type: socket_io_parser_1.PacketType.CONNECT,
                data: this.auth,
              });
            }
          }
          /**
           * Called upon engine or manager `error`.
           *
           * @param err
           * @private
           */
          onerror(err) {
            if (!this.connected) {
              this.emitReserved("connect_error", err);
            }
          }
          /**
           * Called upon engine `close`.
           *
           * @param reason
           * @param description
           * @private
           */
          onclose(reason, description) {
            debug("close (%s)", reason);
            this.connected = false;
            delete this.id;
            this.emitReserved("disconnect", reason, description);
          }
          /**
           * Called with socket packet.
           *
           * @param packet
           * @private
           */
          onpacket(packet) {
            const sameNamespace = packet.nsp === this.nsp;
            if (!sameNamespace) return;
            switch (packet.type) {
              case socket_io_parser_1.PacketType.CONNECT:
                if (packet.data && packet.data.sid) {
                  const id = packet.data.sid;
                  this.onconnect(id);
                } else {
                  this.emitReserved(
                    "connect_error",
                    new Error(
                      "It seems you are trying to reach a Socket.IO server in v2.x with a v3.x client, but they are not compatible (more information here: https://socket.io/docs/v3/migrating-from-2-x-to-3-0/)"
                    )
                  );
                }
                break;
              case socket_io_parser_1.PacketType.EVENT:
              case socket_io_parser_1.PacketType.BINARY_EVENT:
                this.onevent(packet);
                break;
              case socket_io_parser_1.PacketType.ACK:
              case socket_io_parser_1.PacketType.BINARY_ACK:
                this.onack(packet);
                break;
              case socket_io_parser_1.PacketType.DISCONNECT:
                this.ondisconnect();
                break;
              case socket_io_parser_1.PacketType.CONNECT_ERROR:
                this.destroy();
                const err = new Error(packet.data.message);
                // @ts-ignore
                err.data = packet.data.data;
                this.emitReserved("connect_error", err);
                break;
            }
          }
          /**
           * Called upon a server event.
           *
           * @param packet
           * @private
           */
          onevent(packet) {
            const args = packet.data || [];
            debug("emitting event %j", args);
            if (null != packet.id) {
              debug("attaching ack callback to event");
              args.push(this.ack(packet.id));
            }
            if (this.connected) {
              this.emitEvent(args);
            } else {
              this.receiveBuffer.push(Object.freeze(args));
            }
          }
          emitEvent(args) {
            if (this._anyListeners && this._anyListeners.length) {
              const listeners = this._anyListeners.slice();
              for (const listener of listeners) {
                listener.apply(this, args);
              }
            }
            super.emit.apply(this, args);
          }
          /**
           * Produces an ack callback to emit with an event.
           *
           * @private
           */
          ack(id) {
            const self = this;
            let sent = false;
            return function (...args) {
              // prevent double callbacks
              if (sent) return;
              sent = true;
              debug("sending ack %j", args);
              self.packet({
                type: socket_io_parser_1.PacketType.ACK,
                id: id,
                data: args,
              });
            };
          }
          /**
           * Called upon a server acknowlegement.
           *
           * @param packet
           * @private
           */
          onack(packet) {
            const ack = this.acks[packet.id];
            if ("function" === typeof ack) {
              debug("calling ack %s with %j", packet.id, packet.data);
              ack.apply(this, packet.data);
              delete this.acks[packet.id];
            } else {
              debug("bad ack %s", packet.id);
            }
          }
          /**
           * Called upon server connect.
           *
           * @private
           */
          onconnect(id) {
            debug("socket connected with id %s", id);
            this.id = id;
            this.connected = true;
            this.emitBuffered();
            this.emitReserved("connect");
          }
          /**
           * Emit buffered events (received and emitted).
           *
           * @private
           */
          emitBuffered() {
            this.receiveBuffer.forEach((args) => this.emitEvent(args));
            this.receiveBuffer = [];
            this.sendBuffer.forEach((packet) => {
              this.notifyOutgoingListeners(packet);
              this.packet(packet);
            });
            this.sendBuffer = [];
          }
          /**
           * Called upon server disconnect.
           *
           * @private
           */
          ondisconnect() {
            debug("server disconnect (%s)", this.nsp);
            this.destroy();
            this.onclose("io server disconnect");
          }
          /**
           * Called upon forced client/server side disconnections,
           * this method ensures the manager stops tracking us and
           * that reconnections don't get triggered for this.
           *
           * @private
           */
          destroy() {
            if (this.subs) {
              // clean subscriptions to avoid reconnections
              this.subs.forEach((subDestroy) => subDestroy());
              this.subs = undefined;
            }
            this.io["_destroy"](this);
          }
          /**
           * Disconnects the socket manually. In that case, the socket will not try to reconnect.
           *
           * If this is the last active Socket instance of the {@link Manager}, the low-level connection will be closed.
           *
           * @example
           * const socket = io();
           *
           * socket.on("disconnect", (reason) => {
           *   // console.log(reason); prints "io client disconnect"
           * });
           *
           * socket.disconnect();
           *
           * @return self
           */
          disconnect() {
            if (this.connected) {
              debug("performing disconnect (%s)", this.nsp);
              this.packet({ type: socket_io_parser_1.PacketType.DISCONNECT });
            }
            // remove socket from pool
            this.destroy();
            if (this.connected) {
              // fire events
              this.onclose("io client disconnect");
            }
            return this;
          }
          /**
           * Alias for {@link disconnect()}.
           *
           * @return self
           */
          close() {
            return this.disconnect();
          }
          /**
           * Sets the compress flag.
           *
           * @example
           * socket.compress(false).emit("hello");
           *
           * @param compress - if `true`, compresses the sending data
           * @return self
           */
          compress(compress) {
            this.flags.compress = compress;
            return this;
          }
          /**
           * Sets a modifier for a subsequent event emission that the event message will be dropped when this socket is not
           * ready to send messages.
           *
           * @example
           * socket.volatile.emit("hello"); // the server may or may not receive it
           *
           * @returns self
           */
          get volatile() {
            this.flags.volatile = true;
            return this;
          }
          /**
           * Sets a modifier for a subsequent event emission that the callback will be called with an error when the
           * given number of milliseconds have elapsed without an acknowledgement from the server:
           *
           * @example
           * socket.timeout(5000).emit("my-event", (err) => {
           *   if (err) {
           *     // the server did not acknowledge the event in the given delay
           *   }
           * });
           *
           * @returns self
           */
          timeout(timeout) {
            this.flags.timeout = timeout;
            return this;
          }
          /**
           * Adds a listener that will be fired when any event is emitted. The event name is passed as the first argument to the
           * callback.
           *
           * @example
           * socket.onAny((event, ...args) => {
           *   console.log(`got ${event}`);
           * });
           *
           * @param listener
           */
          onAny(listener) {
            this._anyListeners = this._anyListeners || [];
            this._anyListeners.push(listener);
            return this;
          }
          /**
           * Adds a listener that will be fired when any event is emitted. The event name is passed as the first argument to the
           * callback. The listener is added to the beginning of the listeners array.
           *
           * @example
           * socket.prependAny((event, ...args) => {
           *   console.log(`got event ${event}`);
           * });
           *
           * @param listener
           */
          prependAny(listener) {
            this._anyListeners = this._anyListeners || [];
            this._anyListeners.unshift(listener);
            return this;
          }
          /**
           * Removes the listener that will be fired when any event is emitted.
           *
           * @example
           * const catchAllListener = (event, ...args) => {
           *   console.log(`got event ${event}`);
           * }
           *
           * socket.onAny(catchAllListener);
           *
           * // remove a specific listener
           * socket.offAny(catchAllListener);
           *
           * // or remove all listeners
           * socket.offAny();
           *
           * @param listener
           */
          offAny(listener) {
            if (!this._anyListeners) {
              return this;
            }
            if (listener) {
              const listeners = this._anyListeners;
              for (let i = 0; i < listeners.length; i++) {
                if (listener === listeners[i]) {
                  listeners.splice(i, 1);
                  return this;
                }
              }
            } else {
              this._anyListeners = [];
            }
            return this;
          }
          /**
           * Returns an array of listeners that are listening for any event that is specified. This array can be manipulated,
           * e.g. to remove listeners.
           */
          listenersAny() {
            return this._anyListeners || [];
          }
          /**
           * Adds a listener that will be fired when any event is emitted. The event name is passed as the first argument to the
           * callback.
           *
           * Note: acknowledgements sent to the server are not included.
           *
           * @example
           * socket.onAnyOutgoing((event, ...args) => {
           *   console.log(`sent event ${event}`);
           * });
           *
           * @param listener
           */
          onAnyOutgoing(listener) {
            this._anyOutgoingListeners = this._anyOutgoingListeners || [];
            this._anyOutgoingListeners.push(listener);
            return this;
          }
          /**
           * Adds a listener that will be fired when any event is emitted. The event name is passed as the first argument to the
           * callback. The listener is added to the beginning of the listeners array.
           *
           * Note: acknowledgements sent to the server are not included.
           *
           * @example
           * socket.prependAnyOutgoing((event, ...args) => {
           *   console.log(`sent event ${event}`);
           * });
           *
           * @param listener
           */
          prependAnyOutgoing(listener) {
            this._anyOutgoingListeners = this._anyOutgoingListeners || [];
            this._anyOutgoingListeners.unshift(listener);
            return this;
          }
          /**
           * Removes the listener that will be fired when any event is emitted.
           *
           * @example
           * const catchAllListener = (event, ...args) => {
           *   console.log(`sent event ${event}`);
           * }
           *
           * socket.onAnyOutgoing(catchAllListener);
           *
           * // remove a specific listener
           * socket.offAnyOutgoing(catchAllListener);
           *
           * // or remove all listeners
           * socket.offAnyOutgoing();
           *
           * @param [listener] - the catch-all listener (optional)
           */
          offAnyOutgoing(listener) {
            if (!this._anyOutgoingListeners) {
              return this;
            }
            if (listener) {
              const listeners = this._anyOutgoingListeners;
              for (let i = 0; i < listeners.length; i++) {
                if (listener === listeners[i]) {
                  listeners.splice(i, 1);
                  return this;
                }
              }
            } else {
              this._anyOutgoingListeners = [];
            }
            return this;
          }
          /**
           * Returns an array of listeners that are listening for any event that is specified. This array can be manipulated,
           * e.g. to remove listeners.
           */
          listenersAnyOutgoing() {
            return this._anyOutgoingListeners || [];
          }
          /**
           * Notify the listeners for each packet sent
           *
           * @param packet
           *
           * @private
           */
          notifyOutgoingListeners(packet) {
            if (
              this._anyOutgoingListeners &&
              this._anyOutgoingListeners.length
            ) {
              const listeners = this._anyOutgoingListeners.slice();
              for (const listener of listeners) {
                listener.apply(this, packet.data);
              }
            }
          }
        }
        exports.Socket = Socket;
      },
      {
        "./on.js": 85,
        "@socket.io/component-emitter": 1,
        debug: 88,
        "socket.io-parser": 92,
      },
    ],
    87: [
      function (require, module, exports) {
        "use strict";
        var __importDefault =
          (this && this.__importDefault) ||
          function (mod) {
            return mod && mod.__esModule ? mod : { default: mod };
          };
        Object.defineProperty(exports, "__esModule", { value: true });
        exports.url = void 0;
        const engine_io_client_1 = require("engine.io-client");
        const debug_1 = __importDefault(require("debug")); // debug()
        const debug = debug_1.default("socket.io-client:url"); // debug()
        /**
         * URL parser.
         *
         * @param uri - url
         * @param path - the request path of the connection
         * @param loc - An object meant to mimic window.location.
         *        Defaults to window.location.
         * @public
         */
        function url(uri, path = "", loc) {
          let obj = uri;
          // default to window.location
          loc = loc || (typeof location !== "undefined" && location);
          if (null == uri) uri = loc.protocol + "//" + loc.host;
          // relative path support
          if (typeof uri === "string") {
            if ("/" === uri.charAt(0)) {
              if ("/" === uri.charAt(1)) {
                uri = loc.protocol + uri;
              } else {
                uri = loc.host + uri;
              }
            }
            if (!/^(https?|wss?):\/\//.test(uri)) {
              debug("protocol-less url %s", uri);
              if ("undefined" !== typeof loc) {
                uri = loc.protocol + "//" + uri;
              } else {
                uri = "https://" + uri;
              }
            }
            // parse
            debug("parse %s", uri);
            obj = engine_io_client_1.parse(uri);
          }
          // make sure we treat `localhost:80` and `localhost` equally
          if (!obj.port) {
            if (/^(http|ws)$/.test(obj.protocol)) {
              obj.port = "80";
            } else if (/^(http|ws)s$/.test(obj.protocol)) {
              obj.port = "443";
            }
          }
          obj.path = obj.path || "/";
          const ipv6 = obj.host.indexOf(":") !== -1;
          const host = ipv6 ? "[" + obj.host + "]" : obj.host;
          // define unique id
          obj.id = obj.protocol + "://" + host + ":" + obj.port + path;
          // define href
          obj.href =
            obj.protocol +
            "://" +
            host +
            (loc && loc.port === obj.port ? "" : ":" + obj.port);
          return obj;
        }
        exports.url = url;
      },
      { debug: 88, "engine.io-client": 14 },
    ],
    88: [
      function (require, module, exports) {
        arguments[4][23][0].apply(exports, arguments);
      },
      { "./common": 89, _process: 76, dup: 23 },
    ],
    89: [
      function (require, module, exports) {
        arguments[4][24][0].apply(exports, arguments);
      },
      { dup: 24, ms: 90 },
    ],
    90: [
      function (require, module, exports) {
        arguments[4][25][0].apply(exports, arguments);
      },
      { dup: 25 },
    ],
    91: [
      function (require, module, exports) {
        "use strict";
        Object.defineProperty(exports, "__esModule", { value: true });
        exports.reconstructPacket = exports.deconstructPacket = void 0;
        const is_binary_js_1 = require("./is-binary.js");
        /**
         * Replaces every Buffer | ArrayBuffer | Blob | File in packet with a numbered placeholder.
         *
         * @param {Object} packet - socket.io event packet
         * @return {Object} with deconstructed packet and list of buffers
         * @public
         */
        function deconstructPacket(packet) {
          const buffers = [];
          const packetData = packet.data;
          const pack = packet;
          pack.data = _deconstructPacket(packetData, buffers);
          pack.attachments = buffers.length; // number of binary 'attachments'
          return { packet: pack, buffers: buffers };
        }
        exports.deconstructPacket = deconstructPacket;
        function _deconstructPacket(data, buffers) {
          if (!data) return data;
          if (is_binary_js_1.isBinary(data)) {
            const placeholder = { _placeholder: true, num: buffers.length };
            buffers.push(data);
            return placeholder;
          } else if (Array.isArray(data)) {
            const newData = new Array(data.length);
            for (let i = 0; i < data.length; i++) {
              newData[i] = _deconstructPacket(data[i], buffers);
            }
            return newData;
          } else if (typeof data === "object" && !(data instanceof Date)) {
            const newData = {};
            for (const key in data) {
              if (Object.prototype.hasOwnProperty.call(data, key)) {
                newData[key] = _deconstructPacket(data[key], buffers);
              }
            }
            return newData;
          }
          return data;
        }
        /**
         * Reconstructs a binary packet from its placeholder packet and buffers
         *
         * @param {Object} packet - event packet with placeholders
         * @param {Array} buffers - binary buffers to put in placeholder positions
         * @return {Object} reconstructed packet
         * @public
         */
        function reconstructPacket(packet, buffers) {
          packet.data = _reconstructPacket(packet.data, buffers);
          packet.attachments = undefined; // no longer useful
          return packet;
        }
        exports.reconstructPacket = reconstructPacket;
        function _reconstructPacket(data, buffers) {
          if (!data) return data;
          if (data && data._placeholder === true) {
            const isIndexValid =
              typeof data.num === "number" &&
              data.num >= 0 &&
              data.num < buffers.length;
            if (isIndexValid) {
              return buffers[data.num]; // appropriate buffer (should be natural order anyway)
            } else {
              throw new Error("illegal attachments");
            }
          } else if (Array.isArray(data)) {
            for (let i = 0; i < data.length; i++) {
              data[i] = _reconstructPacket(data[i], buffers);
            }
          } else if (typeof data === "object") {
            for (const key in data) {
              if (Object.prototype.hasOwnProperty.call(data, key)) {
                data[key] = _reconstructPacket(data[key], buffers);
              }
            }
          }
          return data;
        }
      },
      { "./is-binary.js": 93 },
    ],
    92: [
      function (require, module, exports) {
        "use strict";
        Object.defineProperty(exports, "__esModule", { value: true });
        exports.Decoder =
          exports.Encoder =
          exports.PacketType =
          exports.protocol =
            void 0;
        const component_emitter_1 = require("@socket.io/component-emitter");
        const binary_js_1 = require("./binary.js");
        const is_binary_js_1 = require("./is-binary.js");
        const debug_1 = require("debug"); // debug()
        const debug = debug_1.default("socket.io-parser"); // debug()
        /**
         * Protocol version.
         *
         * @public
         */
        exports.protocol = 5;
        var PacketType;
        (function (PacketType) {
          PacketType[(PacketType["CONNECT"] = 0)] = "CONNECT";
          PacketType[(PacketType["DISCONNECT"] = 1)] = "DISCONNECT";
          PacketType[(PacketType["EVENT"] = 2)] = "EVENT";
          PacketType[(PacketType["ACK"] = 3)] = "ACK";
          PacketType[(PacketType["CONNECT_ERROR"] = 4)] = "CONNECT_ERROR";
          PacketType[(PacketType["BINARY_EVENT"] = 5)] = "BINARY_EVENT";
          PacketType[(PacketType["BINARY_ACK"] = 6)] = "BINARY_ACK";
        })((PacketType = exports.PacketType || (exports.PacketType = {})));
        /**
         * A socket.io Encoder instance
         */
        class Encoder {
          /**
           * Encoder constructor
           *
           * @param {function} replacer - custom replacer to pass down to JSON.parse
           */
          constructor(replacer) {
            this.replacer = replacer;
          }
          /**
           * Encode a packet as a single string if non-binary, or as a
           * buffer sequence, depending on packet type.
           *
           * @param {Object} obj - packet object
           */
          encode(obj) {
            debug("encoding packet %j", obj);
            if (obj.type === PacketType.EVENT || obj.type === PacketType.ACK) {
              if (is_binary_js_1.hasBinary(obj)) {
                obj.type =
                  obj.type === PacketType.EVENT
                    ? PacketType.BINARY_EVENT
                    : PacketType.BINARY_ACK;
                return this.encodeAsBinary(obj);
              }
            }
            return [this.encodeAsString(obj)];
          }
          /**
           * Encode packet as string.
           */
          encodeAsString(obj) {
            // first is type
            let str = "" + obj.type;
            // attachments if we have them
            if (
              obj.type === PacketType.BINARY_EVENT ||
              obj.type === PacketType.BINARY_ACK
            ) {
              str += obj.attachments + "-";
            }
            // if we have a namespace other than `/`
            // we append it followed by a comma `,`
            if (obj.nsp && "/" !== obj.nsp) {
              str += obj.nsp + ",";
            }
            // immediately followed by the id
            if (null != obj.id) {
              str += obj.id;
            }
            // json data
            if (null != obj.data) {
              str += JSON.stringify(obj.data, this.replacer);
            }
            debug("encoded %j as %s", obj, str);
            return str;
          }
          /**
           * Encode packet as 'buffer sequence' by removing blobs, and
           * deconstructing packet into object with placeholders and
           * a list of buffers.
           */
          encodeAsBinary(obj) {
            const deconstruction = binary_js_1.deconstructPacket(obj);
            const pack = this.encodeAsString(deconstruction.packet);
            const buffers = deconstruction.buffers;
            buffers.unshift(pack); // add packet info to beginning of data list
            return buffers; // write all the buffers
          }
        }
        exports.Encoder = Encoder;
        /**
         * A socket.io Decoder instance
         *
         * @return {Object} decoder
         */
        class Decoder extends component_emitter_1.Emitter {
          /**
           * Decoder constructor
           *
           * @param {function} reviver - custom reviver to pass down to JSON.stringify
           */
          constructor(reviver) {
            super();
            this.reviver = reviver;
          }
          /**
           * Decodes an encoded packet string into packet JSON.
           *
           * @param {String} obj - encoded packet
           */
          add(obj) {
            let packet;
            if (typeof obj === "string") {
              if (this.reconstructor) {
                throw new Error(
                  "got plaintext data when reconstructing a packet"
                );
              }
              packet = this.decodeString(obj);
              if (
                packet.type === PacketType.BINARY_EVENT ||
                packet.type === PacketType.BINARY_ACK
              ) {
                // binary packet's json
                this.reconstructor = new BinaryReconstructor(packet);
                // no attachments, labeled binary but no binary data to follow
                if (packet.attachments === 0) {
                  super.emitReserved("decoded", packet);
                }
              } else {
                // non-binary full packet
                super.emitReserved("decoded", packet);
              }
            } else if (is_binary_js_1.isBinary(obj) || obj.base64) {
              // raw binary data
              if (!this.reconstructor) {
                throw new Error(
                  "got binary data when not reconstructing a packet"
                );
              } else {
                packet = this.reconstructor.takeBinaryData(obj);
                if (packet) {
                  // received final buffer
                  this.reconstructor = null;
                  super.emitReserved("decoded", packet);
                }
              }
            } else {
              throw new Error("Unknown type: " + obj);
            }
          }
          /**
           * Decode a packet String (JSON data)
           *
           * @param {String} str
           * @return {Object} packet
           */
          decodeString(str) {
            let i = 0;
            // look up type
            const p = {
              type: Number(str.charAt(0)),
            };
            if (PacketType[p.type] === undefined) {
              throw new Error("unknown packet type " + p.type);
            }
            // look up attachments if type binary
            if (
              p.type === PacketType.BINARY_EVENT ||
              p.type === PacketType.BINARY_ACK
            ) {
              const start = i + 1;
              while (str.charAt(++i) !== "-" && i != str.length) {}
              const buf = str.substring(start, i);
              if (buf != Number(buf) || str.charAt(i) !== "-") {
                throw new Error("Illegal attachments");
              }
              p.attachments = Number(buf);
            }
            // look up namespace (if any)
            if ("/" === str.charAt(i + 1)) {
              const start = i + 1;
              while (++i) {
                const c = str.charAt(i);
                if ("," === c) break;
                if (i === str.length) break;
              }
              p.nsp = str.substring(start, i);
            } else {
              p.nsp = "/";
            }
            // look up id
            const next = str.charAt(i + 1);
            if ("" !== next && Number(next) == next) {
              const start = i + 1;
              while (++i) {
                const c = str.charAt(i);
                if (null == c || Number(c) != c) {
                  --i;
                  break;
                }
                if (i === str.length) break;
              }
              p.id = Number(str.substring(start, i + 1));
            }
            // look up json data
            if (str.charAt(++i)) {
              const payload = this.tryParse(str.substr(i));
              if (Decoder.isPayloadValid(p.type, payload)) {
                p.data = payload;
              } else {
                throw new Error("invalid payload");
              }
            }
            debug("decoded %s as %j", str, p);
            return p;
          }
          tryParse(str) {
            try {
              return JSON.parse(str, this.reviver);
            } catch (e) {
              return false;
            }
          }
          static isPayloadValid(type, payload) {
            switch (type) {
              case PacketType.CONNECT:
                return typeof payload === "object";
              case PacketType.DISCONNECT:
                return payload === undefined;
              case PacketType.CONNECT_ERROR:
                return (
                  typeof payload === "string" || typeof payload === "object"
                );
              case PacketType.EVENT:
              case PacketType.BINARY_EVENT:
                return Array.isArray(payload) && payload.length > 0;
              case PacketType.ACK:
              case PacketType.BINARY_ACK:
                return Array.isArray(payload);
            }
          }
          /**
           * Deallocates a parser's resources
           */
          destroy() {
            if (this.reconstructor) {
              this.reconstructor.finishedReconstruction();
            }
          }
        }
        exports.Decoder = Decoder;
        /**
         * A manager of a binary event's 'buffer sequence'. Should
         * be constructed whenever a packet of type BINARY_EVENT is
         * decoded.
         *
         * @param {Object} packet
         * @return {BinaryReconstructor} initialized reconstructor
         */
        class BinaryReconstructor {
          constructor(packet) {
            this.packet = packet;
            this.buffers = [];
            this.reconPack = packet;
          }
          /**
           * Method to be called when binary data received from connection
           * after a BINARY_EVENT packet.
           *
           * @param {Buffer | ArrayBuffer} binData - the raw binary data received
           * @return {null | Object} returns null if more binary data is expected or
           *   a reconstructed packet object if all buffers have been received.
           */
          takeBinaryData(binData) {
            this.buffers.push(binData);
            if (this.buffers.length === this.reconPack.attachments) {
              // done with buffer list
              const packet = binary_js_1.reconstructPacket(
                this.reconPack,
                this.buffers
              );
              this.finishedReconstruction();
              return packet;
            }
            return null;
          }
          /**
           * Cleans up binary packet reconstruction variables.
           */
          finishedReconstruction() {
            this.reconPack = null;
            this.buffers = [];
          }
        }
      },
      {
        "./binary.js": 91,
        "./is-binary.js": 93,
        "@socket.io/component-emitter": 1,
        debug: 94,
      },
    ],
    93: [
      function (require, module, exports) {
        "use strict";
        Object.defineProperty(exports, "__esModule", { value: true });
        exports.hasBinary = exports.isBinary = void 0;
        const withNativeArrayBuffer = typeof ArrayBuffer === "function";
        const isView = (obj) => {
          return typeof ArrayBuffer.isView === "function"
            ? ArrayBuffer.isView(obj)
            : obj.buffer instanceof ArrayBuffer;
        };
        const toString = Object.prototype.toString;
        const withNativeBlob =
          typeof Blob === "function" ||
          (typeof Blob !== "undefined" &&
            toString.call(Blob) === "[object BlobConstructor]");
        const withNativeFile =
          typeof File === "function" ||
          (typeof File !== "undefined" &&
            toString.call(File) === "[object FileConstructor]");
        /**
         * Returns true if obj is a Buffer, an ArrayBuffer, a Blob or a File.
         *
         * @private
         */
        function isBinary(obj) {
          return (
            (withNativeArrayBuffer &&
              (obj instanceof ArrayBuffer || isView(obj))) ||
            (withNativeBlob && obj instanceof Blob) ||
            (withNativeFile && obj instanceof File)
          );
        }
        exports.isBinary = isBinary;
        function hasBinary(obj, toJSON) {
          if (!obj || typeof obj !== "object") {
            return false;
          }
          if (Array.isArray(obj)) {
            for (let i = 0, l = obj.length; i < l; i++) {
              if (hasBinary(obj[i])) {
                return true;
              }
            }
            return false;
          }
          if (isBinary(obj)) {
            return true;
          }
          if (
            obj.toJSON &&
            typeof obj.toJSON === "function" &&
            arguments.length === 1
          ) {
            return hasBinary(obj.toJSON(), true);
          }
          for (const key in obj) {
            if (
              Object.prototype.hasOwnProperty.call(obj, key) &&
              hasBinary(obj[key])
            ) {
              return true;
            }
          }
          return false;
        }
        exports.hasBinary = hasBinary;
      },
      {},
    ],
    94: [
      function (require, module, exports) {
        arguments[4][23][0].apply(exports, arguments);
      },
      { "./common": 95, _process: 76, dup: 23 },
    ],
    95: [
      function (require, module, exports) {
        arguments[4][24][0].apply(exports, arguments);
      },
      { dup: 24, ms: 96 },
    ],
    96: [
      function (require, module, exports) {
        arguments[4][25][0].apply(exports, arguments);
      },
      { dup: 25 },
    ],
    97: [
      function (require, module, exports) {
        /////////////////////////////////////////////////////////////////////////////////
        /* UAParser.js v1.0.37
     Copyright © 2012-2021 Faisal Salman <f@faisalman.com>
     MIT License */ /*
     Detect Browser, Engine, OS, CPU, and Device type/model from User-Agent data.
     Supports browser & node.js environment. 
     Demo   : https://faisalman.github.io/ua-parser-js
     Source : https://github.com/faisalman/ua-parser-js */
        /////////////////////////////////////////////////////////////////////////////////

        (function (window, undefined) {
          "use strict";

          //////////////
          // Constants
          /////////////

          var LIBVERSION = "1.0.37",
            EMPTY = "",
            UNKNOWN = "?",
            FUNC_TYPE = "function",
            UNDEF_TYPE = "undefined",
            OBJ_TYPE = "object",
            STR_TYPE = "string",
            MAJOR = "major",
            MODEL = "model",
            NAME = "name",
            TYPE = "type",
            VENDOR = "vendor",
            VERSION = "version",
            ARCHITECTURE = "architecture",
            CONSOLE = "console",
            MOBILE = "mobile",
            TABLET = "tablet",
            SMARTTV = "smarttv",
            WEARABLE = "wearable",
            EMBEDDED = "embedded",
            UA_MAX_LENGTH = 500;

          var AMAZON = "Amazon",
            APPLE = "Apple",
            ASUS = "ASUS",
            BLACKBERRY = "BlackBerry",
            BROWSER = "Browser",
            CHROME = "Chrome",
            EDGE = "Edge",
            FIREFOX = "Firefox",
            GOOGLE = "Google",
            HUAWEI = "Huawei",
            LG = "LG",
            MICROSOFT = "Microsoft",
            MOTOROLA = "Motorola",
            OPERA = "Opera",
            SAMSUNG = "Samsung",
            SHARP = "Sharp",
            SONY = "Sony",
            XIAOMI = "Xiaomi",
            ZEBRA = "Zebra",
            FACEBOOK = "Facebook",
            CHROMIUM_OS = "Chromium OS",
            MAC_OS = "Mac OS";

          ///////////
          // Helper
          //////////

          var extend = function (regexes, extensions) {
              var mergedRegexes = {};
              for (var i in regexes) {
                if (extensions[i] && extensions[i].length % 2 === 0) {
                  mergedRegexes[i] = extensions[i].concat(regexes[i]);
                } else {
                  mergedRegexes[i] = regexes[i];
                }
              }
              return mergedRegexes;
            },
            enumerize = function (arr) {
              var enums = {};
              for (var i = 0; i < arr.length; i++) {
                enums[arr[i].toUpperCase()] = arr[i];
              }
              return enums;
            },
            has = function (str1, str2) {
              return typeof str1 === STR_TYPE
                ? lowerize(str2).indexOf(lowerize(str1)) !== -1
                : false;
            },
            lowerize = function (str) {
              return str.toLowerCase();
            },
            majorize = function (version) {
              return typeof version === STR_TYPE
                ? version.replace(/[^\d\.]/g, EMPTY).split(".")[0]
                : undefined;
            },
            trim = function (str, len) {
              if (typeof str === STR_TYPE) {
                str = str.replace(/^\s\s*/, EMPTY);
                return typeof len === UNDEF_TYPE
                  ? str
                  : str.substring(0, UA_MAX_LENGTH);
              }
            };

          ///////////////
          // Map helper
          //////////////

          var rgxMapper = function (ua, arrays) {
              var i = 0,
                j,
                k,
                p,
                q,
                matches,
                match;

              // loop through all regexes maps
              while (i < arrays.length && !matches) {
                var regex = arrays[i], // even sequence (0,2,4,..)
                  props = arrays[i + 1]; // odd sequence (1,3,5,..)
                j = k = 0;

                // try matching uastring with regexes
                while (j < regex.length && !matches) {
                  if (!regex[j]) {
                    break;
                  }
                  matches = regex[j++].exec(ua);

                  if (!!matches) {
                    for (p = 0; p < props.length; p++) {
                      match = matches[++k];
                      q = props[p];
                      // check if given property is actually array
                      if (typeof q === OBJ_TYPE && q.length > 0) {
                        if (q.length === 2) {
                          if (typeof q[1] == FUNC_TYPE) {
                            // assign modified match
                            this[q[0]] = q[1].call(this, match);
                          } else {
                            // assign given value, ignore regex match
                            this[q[0]] = q[1];
                          }
                        } else if (q.length === 3) {
                          // check whether function or regex
                          if (
                            typeof q[1] === FUNC_TYPE &&
                            !(q[1].exec && q[1].test)
                          ) {
                            // call function (usually string mapper)
                            this[q[0]] = match
                              ? q[1].call(this, match, q[2])
                              : undefined;
                          } else {
                            // sanitize match using given regex
                            this[q[0]] = match
                              ? match.replace(q[1], q[2])
                              : undefined;
                          }
                        } else if (q.length === 4) {
                          this[q[0]] = match
                            ? q[3].call(this, match.replace(q[1], q[2]))
                            : undefined;
                        }
                      } else {
                        this[q] = match ? match : undefined;
                      }
                    }
                  }
                }
                i += 2;
              }
            },
            strMapper = function (str, map) {
              for (var i in map) {
                // check if current value is array
                if (typeof map[i] === OBJ_TYPE && map[i].length > 0) {
                  for (var j = 0; j < map[i].length; j++) {
                    if (has(map[i][j], str)) {
                      return i === UNKNOWN ? undefined : i;
                    }
                  }
                } else if (has(map[i], str)) {
                  return i === UNKNOWN ? undefined : i;
                }
              }
              return str;
            };

          ///////////////
          // String map
          //////////////

          // Safari < 3.0
          var oldSafariMap = {
              "1.0": "/8",
              1.2: "/1",
              1.3: "/3",
              "2.0": "/412",
              "2.0.2": "/416",
              "2.0.3": "/417",
              "2.0.4": "/419",
              "?": "/",
            },
            windowsVersionMap = {
              ME: "4.90",
              "NT 3.11": "NT3.51",
              "NT 4.0": "NT4.0",
              2000: "NT 5.0",
              XP: ["NT 5.1", "NT 5.2"],
              Vista: "NT 6.0",
              7: "NT 6.1",
              8: "NT 6.2",
              8.1: "NT 6.3",
              10: ["NT 6.4", "NT 10.0"],
              RT: "ARM",
            };

          //////////////
          // Regex map
          /////////////

          var regexes = {
            browser: [
              [
                /\b(?:crmo|crios)\/([\w\.]+)/i, // Chrome for Android/iOS
              ],
              [VERSION, [NAME, "Chrome"]],
              [
                /edg(?:e|ios|a)?\/([\w\.]+)/i, // Microsoft Edge
              ],
              [VERSION, [NAME, "Edge"]],
              [
                // Presto based
                /(opera mini)\/([-\w\.]+)/i, // Opera Mini
                /(opera [mobiletab]{3,6})\b.+version\/([-\w\.]+)/i, // Opera Mobi/Tablet
                /(opera)(?:.+version\/|[\/ ]+)([\w\.]+)/i, // Opera
              ],
              [NAME, VERSION],
              [
                /opios[\/ ]+([\w\.]+)/i, // Opera mini on iphone >= 8.0
              ],
              [VERSION, [NAME, OPERA + " Mini"]],
              [
                /\bopr\/([\w\.]+)/i, // Opera Webkit
              ],
              [VERSION, [NAME, OPERA]],
              [
                // Mixed
                /\bb[ai]*d(?:uhd|[ub]*[aekoprswx]{5,6})[\/ ]?([\w\.]+)/i, // Baidu
              ],
              [VERSION, [NAME, "Baidu"]],
              [
                /(kindle)\/([\w\.]+)/i, // Kindle
                /(lunascape|maxthon|netfront|jasmine|blazer)[\/ ]?([\w\.]*)/i, // Lunascape/Maxthon/Netfront/Jasmine/Blazer
                // Trident based
                /(avant|iemobile|slim)\s?(?:browser)?[\/ ]?([\w\.]*)/i, // Avant/IEMobile/SlimBrowser
                /(?:ms|\()(ie) ([\w\.]+)/i, // Internet Explorer

                // Webkit/KHTML based                                               // Flock/RockMelt/Midori/Epiphany/Silk/Skyfire/Bolt/Iron/Iridium/PhantomJS/Bowser/QupZilla/Falkon
                /(flock|rockmelt|midori|epiphany|silk|skyfire|bolt|iron|vivaldi|iridium|phantomjs|bowser|quark|qupzilla|falkon|rekonq|puffin|brave|whale(?!.+naver)|qqbrowserlite|qq|duckduckgo)\/([-\w\.]+)/i,
                // Rekonq/Puffin/Brave/Whale/QQBrowserLite/QQ, aka ShouQ
                /(heytap|ovi)browser\/([\d\.]+)/i, // Heytap/Ovi
                /(weibo)__([\d\.]+)/i, // Weibo
              ],
              [NAME, VERSION],
              [
                /(?:\buc? ?browser|(?:juc.+)ucweb)[\/ ]?([\w\.]+)/i, // UCBrowser
              ],
              [VERSION, [NAME, "UC" + BROWSER]],
              [
                /microm.+\bqbcore\/([\w\.]+)/i, // WeChat Desktop for Windows Built-in Browser
                /\bqbcore\/([\w\.]+).+microm/i,
                /micromessenger\/([\w\.]+)/i, // WeChat
              ],
              [VERSION, [NAME, "WeChat"]],
              [
                /konqueror\/([\w\.]+)/i, // Konqueror
              ],
              [VERSION, [NAME, "Konqueror"]],
              [
                /trident.+rv[: ]([\w\.]{1,9})\b.+like gecko/i, // IE11
              ],
              [VERSION, [NAME, "IE"]],
              [
                /ya(?:search)?browser\/([\w\.]+)/i, // Yandex
              ],
              [VERSION, [NAME, "Yandex"]],
              [
                /slbrowser\/([\w\.]+)/i, // Smart Lenovo Browser
              ],
              [VERSION, [NAME, "Smart Lenovo " + BROWSER]],
              [
                /(avast|avg)\/([\w\.]+)/i, // Avast/AVG Secure Browser
              ],
              [[NAME, /(.+)/, "$1 Secure " + BROWSER], VERSION],
              [
                /\bfocus\/([\w\.]+)/i, // Firefox Focus
              ],
              [VERSION, [NAME, FIREFOX + " Focus"]],
              [
                /\bopt\/([\w\.]+)/i, // Opera Touch
              ],
              [VERSION, [NAME, OPERA + " Touch"]],
              [
                /coc_coc\w+\/([\w\.]+)/i, // Coc Coc Browser
              ],
              [VERSION, [NAME, "Coc Coc"]],
              [
                /dolfin\/([\w\.]+)/i, // Dolphin
              ],
              [VERSION, [NAME, "Dolphin"]],
              [
                /coast\/([\w\.]+)/i, // Opera Coast
              ],
              [VERSION, [NAME, OPERA + " Coast"]],
              [
                /miuibrowser\/([\w\.]+)/i, // MIUI Browser
              ],
              [VERSION, [NAME, "MIUI " + BROWSER]],
              [
                /fxios\/([-\w\.]+)/i, // Firefox for iOS
              ],
              [VERSION, [NAME, FIREFOX]],
              [
                /\bqihu|(qi?ho?o?|360)browser/i, // 360
              ],
              [[NAME, "360 " + BROWSER]],
              [/(oculus|sailfish|huawei|vivo)browser\/([\w\.]+)/i],
              [[NAME, /(.+)/, "$1 " + BROWSER], VERSION],
              [
                // Oculus/Sailfish/HuaweiBrowser/VivoBrowser
                /samsungbrowser\/([\w\.]+)/i, // Samsung Internet
              ],
              [VERSION, [NAME, SAMSUNG + " Internet"]],
              [
                /(comodo_dragon)\/([\w\.]+)/i, // Comodo Dragon
              ],
              [[NAME, /_/g, " "], VERSION],
              [
                /metasr[\/ ]?([\d\.]+)/i, // Sogou Explorer
              ],
              [VERSION, [NAME, "Sogou Explorer"]],
              [
                /(sogou)mo\w+\/([\d\.]+)/i, // Sogou Mobile
              ],
              [[NAME, "Sogou Mobile"], VERSION],
              [
                /(electron)\/([\w\.]+) safari/i, // Electron-based App
                /(tesla)(?: qtcarbrowser|\/(20\d\d\.[-\w\.]+))/i, // Tesla
                /m?(qqbrowser|2345Explorer)[\/ ]?([\w\.]+)/i, // QQBrowser/2345 Browser
              ],
              [NAME, VERSION],
              [
                /(lbbrowser)/i, // LieBao Browser
                /\[(linkedin)app\]/i, // LinkedIn App for iOS & Android
              ],
              [NAME],
              [
                // WebView
                /((?:fban\/fbios|fb_iab\/fb4a)(?!.+fbav)|;fbav\/([\w\.]+);)/i, // Facebook App for iOS & Android
              ],
              [[NAME, FACEBOOK], VERSION],
              [
                /(Klarna)\/([\w\.]+)/i, // Klarna Shopping Browser for iOS & Android
                /(kakao(?:talk|story))[\/ ]([\w\.]+)/i, // Kakao App
                /(naver)\(.*?(\d+\.[\w\.]+).*\)/i, // Naver InApp
                /safari (line)\/([\w\.]+)/i, // Line App for iOS
                /\b(line)\/([\w\.]+)\/iab/i, // Line App for Android
                /(alipay)client\/([\w\.]+)/i, // Alipay
                /(chromium|instagram|snapchat)[\/ ]([-\w\.]+)/i, // Chromium/Instagram/Snapchat
              ],
              [NAME, VERSION],
              [
                /\bgsa\/([\w\.]+) .*safari\//i, // Google Search Appliance on iOS
              ],
              [VERSION, [NAME, "GSA"]],
              [
                /musical_ly(?:.+app_?version\/|_)([\w\.]+)/i, // TikTok
              ],
              [VERSION, [NAME, "TikTok"]],
              [
                /headlesschrome(?:\/([\w\.]+)| )/i, // Chrome Headless
              ],
              [VERSION, [NAME, CHROME + " Headless"]],
              [
                / wv\).+(chrome)\/([\w\.]+)/i, // Chrome WebView
              ],
              [[NAME, CHROME + " WebView"], VERSION],
              [
                /droid.+ version\/([\w\.]+)\b.+(?:mobile safari|safari)/i, // Android Browser
              ],
              [VERSION, [NAME, "Android " + BROWSER]],
              [
                /(chrome|omniweb|arora|[tizenoka]{5} ?browser)\/v?([\w\.]+)/i, // Chrome/OmniWeb/Arora/Tizen/Nokia
              ],
              [NAME, VERSION],
              [
                /version\/([\w\.\,]+) .*mobile\/\w+ (safari)/i, // Mobile Safari
              ],
              [VERSION, [NAME, "Mobile Safari"]],
              [
                /version\/([\w(\.|\,)]+) .*(mobile ?safari|safari)/i, // Safari & Safari Mobile
              ],
              [VERSION, NAME],
              [
                /webkit.+?(mobile ?safari|safari)(\/[\w\.]+)/i, // Safari < 3.0
              ],
              [NAME, [VERSION, strMapper, oldSafariMap]],
              [/(webkit|khtml)\/([\w\.]+)/i],
              [NAME, VERSION],
              [
                // Gecko based
                /(navigator|netscape\d?)\/([-\w\.]+)/i, // Netscape
              ],
              [[NAME, "Netscape"], VERSION],
              [
                /mobile vr; rv:([\w\.]+)\).+firefox/i, // Firefox Reality
              ],
              [VERSION, [NAME, FIREFOX + " Reality"]],
              [
                /ekiohf.+(flow)\/([\w\.]+)/i, // Flow
                /(swiftfox)/i, // Swiftfox
                /(icedragon|iceweasel|camino|chimera|fennec|maemo browser|minimo|conkeror|klar)[\/ ]?([\w\.\+]+)/i,
                // IceDragon/Iceweasel/Camino/Chimera/Fennec/Maemo/Minimo/Conkeror/Klar
                /(seamonkey|k-meleon|icecat|iceape|firebird|phoenix|palemoon|basilisk|waterfox)\/([-\w\.]+)$/i,
                // Firefox/SeaMonkey/K-Meleon/IceCat/IceApe/Firebird/Phoenix
                /(firefox)\/([\w\.]+)/i, // Other Firefox-based
                /(mozilla)\/([\w\.]+) .+rv\:.+gecko\/\d+/i, // Mozilla

                // Other
                /(polaris|lynx|dillo|icab|doris|amaya|w3m|netsurf|sleipnir|obigo|mosaic|(?:go|ice|up)[\. ]?browser)[-\/ ]?v?([\w\.]+)/i,
                // Polaris/Lynx/Dillo/iCab/Doris/Amaya/w3m/NetSurf/Sleipnir/Obigo/Mosaic/Go/ICE/UP.Browser
                /(links) \(([\w\.]+)/i, // Links
                /panasonic;(viera)/i, // Panasonic Viera
              ],
              [NAME, VERSION],
              [
                /(cobalt)\/([\w\.]+)/i, // Cobalt
              ],
              [NAME, [VERSION, /master.|lts./, ""]],
            ],

            cpu: [
              [
                /(?:(amd|x(?:(?:86|64)[-_])?|wow|win)64)[;\)]/i, // AMD64 (x64)
              ],
              [[ARCHITECTURE, "amd64"]],
              [
                /(ia32(?=;))/i, // IA32 (quicktime)
              ],
              [[ARCHITECTURE, lowerize]],
              [
                /((?:i[346]|x)86)[;\)]/i, // IA32 (x86)
              ],
              [[ARCHITECTURE, "ia32"]],
              [
                /\b(aarch64|arm(v?8e?l?|_?64))\b/i, // ARM64
              ],
              [[ARCHITECTURE, "arm64"]],
              [
                /\b(arm(?:v[67])?ht?n?[fl]p?)\b/i, // ARMHF
              ],
              [[ARCHITECTURE, "armhf"]],
              [
                // PocketPC mistakenly identified as PowerPC
                /windows (ce|mobile); ppc;/i,
              ],
              [[ARCHITECTURE, "arm"]],
              [
                /((?:ppc|powerpc)(?:64)?)(?: mac|;|\))/i, // PowerPC
              ],
              [[ARCHITECTURE, /ower/, EMPTY, lowerize]],
              [
                /(sun4\w)[;\)]/i, // SPARC
              ],
              [[ARCHITECTURE, "sparc"]],
              [
                /((?:avr32|ia64(?=;))|68k(?=\))|\barm(?=v(?:[1-7]|[5-7]1)l?|;|eabi)|(?=atmel )avr|(?:irix|mips|sparc)(?:64)?\b|pa-risc)/i,
                // IA64, 68K, ARM/64, AVR/32, IRIX/64, MIPS/64, SPARC/64, PA-RISC
              ],
              [[ARCHITECTURE, lowerize]],
            ],

            device: [
              [
                //////////////////////////
                // MOBILES & TABLETS
                /////////////////////////

                // Samsung
                /\b(sch-i[89]0\d|shw-m380s|sm-[ptx]\w{2,4}|gt-[pn]\d{2,4}|sgh-t8[56]9|nexus 10)/i,
              ],
              [MODEL, [VENDOR, SAMSUNG], [TYPE, TABLET]],
              [
                /\b((?:s[cgp]h|gt|sm)-\w+|sc[g-]?[\d]+a?|galaxy nexus)/i,
                /samsung[- ]([-\w]+)/i,
                /sec-(sgh\w+)/i,
              ],
              [MODEL, [VENDOR, SAMSUNG], [TYPE, MOBILE]],
              [
                // Apple
                /(?:\/|\()(ip(?:hone|od)[\w, ]*)(?:\/|;)/i, // iPod/iPhone
              ],
              [MODEL, [VENDOR, APPLE], [TYPE, MOBILE]],
              [
                /\((ipad);[-\w\),; ]+apple/i, // iPad
                /applecoremedia\/[\w\.]+ \((ipad)/i,
                /\b(ipad)\d\d?,\d\d?[;\]].+ios/i,
              ],
              [MODEL, [VENDOR, APPLE], [TYPE, TABLET]],
              [/(macintosh);/i],
              [MODEL, [VENDOR, APPLE]],
              [
                // Sharp
                /\b(sh-?[altvz]?\d\d[a-ekm]?)/i,
              ],
              [MODEL, [VENDOR, SHARP], [TYPE, MOBILE]],
              [
                // Huawei
                /\b((?:ag[rs][23]?|bah2?|sht?|btv)-a?[lw]\d{2})\b(?!.+d\/s)/i,
              ],
              [MODEL, [VENDOR, HUAWEI], [TYPE, TABLET]],
              [
                /(?:huawei|honor)([-\w ]+)[;\)]/i,
                /\b(nexus 6p|\w{2,4}e?-[atu]?[ln][\dx][012359c][adn]?)\b(?!.+d\/s)/i,
              ],
              [MODEL, [VENDOR, HUAWEI], [TYPE, MOBILE]],
              [
                // Xiaomi
                /\b(poco[\w ]+|m2\d{3}j\d\d[a-z]{2})(?: bui|\))/i, // Xiaomi POCO
                /\b; (\w+) build\/hm\1/i, // Xiaomi Hongmi 'numeric' models
                /\b(hm[-_ ]?note?[_ ]?(?:\d\w)?) bui/i, // Xiaomi Hongmi
                /\b(redmi[\-_ ]?(?:note|k)?[\w_ ]+)(?: bui|\))/i, // Xiaomi Redmi
                /oid[^\)]+; (m?[12][0-389][01]\w{3,6}[c-y])( bui|; wv|\))/i, // Xiaomi Redmi 'numeric' models
                /\b(mi[-_ ]?(?:a\d|one|one[_ ]plus|note lte|max|cc)?[_ ]?(?:\d?\w?)[_ ]?(?:plus|se|lite)?)(?: bui|\))/i, // Xiaomi Mi
              ],
              [
                [MODEL, /_/g, " "],
                [VENDOR, XIAOMI],
                [TYPE, MOBILE],
              ],
              [
                /oid[^\)]+; (2\d{4}(283|rpbf)[cgl])( bui|\))/i, // Redmi Pad
                /\b(mi[-_ ]?(?:pad)(?:[\w_ ]+))(?: bui|\))/i, // Mi Pad tablets
              ],
              [
                [MODEL, /_/g, " "],
                [VENDOR, XIAOMI],
                [TYPE, TABLET],
              ],
              [
                // OPPO
                /; (\w+) bui.+ oppo/i,
                /\b(cph[12]\d{3}|p(?:af|c[al]|d\w|e[ar])[mt]\d0|x9007|a101op)\b/i,
              ],
              [MODEL, [VENDOR, "OPPO"], [TYPE, MOBILE]],
              [
                // Vivo
                /vivo (\w+)(?: bui|\))/i,
                /\b(v[12]\d{3}\w?[at])(?: bui|;)/i,
              ],
              [MODEL, [VENDOR, "Vivo"], [TYPE, MOBILE]],
              [
                // Realme
                /\b(rmx[1-3]\d{3})(?: bui|;|\))/i,
              ],
              [MODEL, [VENDOR, "Realme"], [TYPE, MOBILE]],
              [
                // Motorola
                /\b(milestone|droid(?:[2-4x]| (?:bionic|x2|pro|razr))?:?( 4g)?)\b[\w ]+build\//i,
                /\bmot(?:orola)?[- ](\w*)/i,
                /((?:moto[\w\(\) ]+|xt\d{3,4}|nexus 6)(?= bui|\)))/i,
              ],
              [MODEL, [VENDOR, MOTOROLA], [TYPE, MOBILE]],
              [/\b(mz60\d|xoom[2 ]{0,2}) build\//i],
              [MODEL, [VENDOR, MOTOROLA], [TYPE, TABLET]],
              [
                // LG
                /((?=lg)?[vl]k\-?\d{3}) bui| 3\.[-\w; ]{10}lg?-([06cv9]{3,4})/i,
              ],
              [MODEL, [VENDOR, LG], [TYPE, TABLET]],
              [
                /(lm(?:-?f100[nv]?|-[\w\.]+)(?= bui|\))|nexus [45])/i,
                /\blg[-e;\/ ]+((?!browser|netcast|android tv)\w+)/i,
                /\blg-?([\d\w]+) bui/i,
              ],
              [MODEL, [VENDOR, LG], [TYPE, MOBILE]],
              [
                // Lenovo
                /(ideatab[-\w ]+)/i,
                /lenovo ?(s[56]000[-\w]+|tab(?:[\w ]+)|yt[-\d\w]{6}|tb[-\d\w]{6})/i,
              ],
              [MODEL, [VENDOR, "Lenovo"], [TYPE, TABLET]],
              [
                // Nokia
                /(?:maemo|nokia).*(n900|lumia \d+)/i,
                /nokia[-_ ]?([-\w\.]*)/i,
              ],
              [
                [MODEL, /_/g, " "],
                [VENDOR, "Nokia"],
                [TYPE, MOBILE],
              ],
              [
                // Google
                /(pixel c)\b/i, // Google Pixel C
              ],
              [MODEL, [VENDOR, GOOGLE], [TYPE, TABLET]],
              [
                /droid.+; (pixel[\daxl ]{0,6})(?: bui|\))/i, // Google Pixel
              ],
              [MODEL, [VENDOR, GOOGLE], [TYPE, MOBILE]],
              [
                // Sony
                /droid.+ (a?\d[0-2]{2}so|[c-g]\d{4}|so[-gl]\w+|xq-a\w[4-7][12])(?= bui|\).+chrome\/(?![1-6]{0,1}\d\.))/i,
              ],
              [MODEL, [VENDOR, SONY], [TYPE, MOBILE]],
              [/sony tablet [ps]/i, /\b(?:sony)?sgp\w+(?: bui|\))/i],
              [
                [MODEL, "Xperia Tablet"],
                [VENDOR, SONY],
                [TYPE, TABLET],
              ],
              [
                // OnePlus
                / (kb2005|in20[12]5|be20[12][59])\b/i,
                /(?:one)?(?:plus)? (a\d0\d\d)(?: b|\))/i,
              ],
              [MODEL, [VENDOR, "OnePlus"], [TYPE, MOBILE]],
              [
                // Amazon
                /(alexa)webm/i,
                /(kf[a-z]{2}wi|aeo[c-r]{2})( bui|\))/i, // Kindle Fire without Silk / Echo Show
                /(kf[a-z]+)( bui|\)).+silk\//i, // Kindle Fire HD
              ],
              [MODEL, [VENDOR, AMAZON], [TYPE, TABLET]],
              [
                /((?:sd|kf)[0349hijorstuw]+)( bui|\)).+silk\//i, // Fire Phone
              ],
              [
                [MODEL, /(.+)/g, "Fire Phone $1"],
                [VENDOR, AMAZON],
                [TYPE, MOBILE],
              ],
              [
                // BlackBerry
                /(playbook);[-\w\),; ]+(rim)/i, // BlackBerry PlayBook
              ],
              [MODEL, VENDOR, [TYPE, TABLET]],
              [
                /\b((?:bb[a-f]|st[hv])100-\d)/i,
                /\(bb10; (\w+)/i, // BlackBerry 10
              ],
              [MODEL, [VENDOR, BLACKBERRY], [TYPE, MOBILE]],
              [
                // Asus
                /(?:\b|asus_)(transfo[prime ]{4,10} \w+|eeepc|slider \w+|nexus 7|padfone|p00[cj])/i,
              ],
              [MODEL, [VENDOR, ASUS], [TYPE, TABLET]],
              [/ (z[bes]6[027][012][km][ls]|zenfone \d\w?)\b/i],
              [MODEL, [VENDOR, ASUS], [TYPE, MOBILE]],
              [
                // HTC
                /(nexus 9)/i, // HTC Nexus 9
              ],
              [MODEL, [VENDOR, "HTC"], [TYPE, TABLET]],
              [
                /(htc)[-;_ ]{1,2}([\w ]+(?=\)| bui)|\w+)/i, // HTC

                // ZTE
                /(zte)[- ]([\w ]+?)(?: bui|\/|\))/i,
                /(alcatel|geeksphone|nexian|panasonic(?!(?:;|\.))|sony(?!-bra))[-_ ]?([-\w]*)/i, // Alcatel/GeeksPhone/Nexian/Panasonic/Sony
              ],
              [VENDOR, [MODEL, /_/g, " "], [TYPE, MOBILE]],
              [
                // Acer
                /droid.+; ([ab][1-7]-?[0178a]\d\d?)/i,
              ],
              [MODEL, [VENDOR, "Acer"], [TYPE, TABLET]],
              [
                // Meizu
                /droid.+; (m[1-5] note) bui/i,
                /\bmz-([-\w]{2,})/i,
              ],
              [MODEL, [VENDOR, "Meizu"], [TYPE, MOBILE]],
              [
                // Ulefone
                /; ((?:power )?armor(?:[\w ]{0,8}))(?: bui|\))/i,
              ],
              [MODEL, [VENDOR, "Ulefone"], [TYPE, MOBILE]],
              [
                // MIXED
                /(blackberry|benq|palm(?=\-)|sonyericsson|acer|asus|dell|meizu|motorola|polytron|infinix|tecno)[-_ ]?([-\w]*)/i,
                // BlackBerry/BenQ/Palm/Sony-Ericsson/Acer/Asus/Dell/Meizu/Motorola/Polytron
                /(hp) ([\w ]+\w)/i, // HP iPAQ
                /(asus)-?(\w+)/i, // Asus
                /(microsoft); (lumia[\w ]+)/i, // Microsoft Lumia
                /(lenovo)[-_ ]?([-\w]+)/i, // Lenovo
                /(jolla)/i, // Jolla
                /(oppo) ?([\w ]+) bui/i, // OPPO
              ],
              [VENDOR, MODEL, [TYPE, MOBILE]],
              [
                /(kobo)\s(ereader|touch)/i, // Kobo
                /(archos) (gamepad2?)/i, // Archos
                /(hp).+(touchpad(?!.+tablet)|tablet)/i, // HP TouchPad
                /(kindle)\/([\w\.]+)/i, // Kindle
                /(nook)[\w ]+build\/(\w+)/i, // Nook
                /(dell) (strea[kpr\d ]*[\dko])/i, // Dell Streak
                /(le[- ]+pan)[- ]+(\w{1,9}) bui/i, // Le Pan Tablets
                /(trinity)[- ]*(t\d{3}) bui/i, // Trinity Tablets
                /(gigaset)[- ]+(q\w{1,9}) bui/i, // Gigaset Tablets
                /(vodafone) ([\w ]+)(?:\)| bui)/i, // Vodafone
              ],
              [VENDOR, MODEL, [TYPE, TABLET]],
              [
                /(surface duo)/i, // Surface Duo
              ],
              [MODEL, [VENDOR, MICROSOFT], [TYPE, TABLET]],
              [
                /droid [\d\.]+; (fp\du?)(?: b|\))/i, // Fairphone
              ],
              [MODEL, [VENDOR, "Fairphone"], [TYPE, MOBILE]],
              [
                /(u304aa)/i, // AT&T
              ],
              [MODEL, [VENDOR, "AT&T"], [TYPE, MOBILE]],
              [
                /\bsie-(\w*)/i, // Siemens
              ],
              [MODEL, [VENDOR, "Siemens"], [TYPE, MOBILE]],
              [
                /\b(rct\w+) b/i, // RCA Tablets
              ],
              [MODEL, [VENDOR, "RCA"], [TYPE, TABLET]],
              [
                /\b(venue[\d ]{2,7}) b/i, // Dell Venue Tablets
              ],
              [MODEL, [VENDOR, "Dell"], [TYPE, TABLET]],
              [
                /\b(q(?:mv|ta)\w+) b/i, // Verizon Tablet
              ],
              [MODEL, [VENDOR, "Verizon"], [TYPE, TABLET]],
              [
                /\b(?:barnes[& ]+noble |bn[rt])([\w\+ ]*) b/i, // Barnes & Noble Tablet
              ],
              [MODEL, [VENDOR, "Barnes & Noble"], [TYPE, TABLET]],
              [/\b(tm\d{3}\w+) b/i],
              [MODEL, [VENDOR, "NuVision"], [TYPE, TABLET]],
              [
                /\b(k88) b/i, // ZTE K Series Tablet
              ],
              [MODEL, [VENDOR, "ZTE"], [TYPE, TABLET]],
              [
                /\b(nx\d{3}j) b/i, // ZTE Nubia
              ],
              [MODEL, [VENDOR, "ZTE"], [TYPE, MOBILE]],
              [
                /\b(gen\d{3}) b.+49h/i, // Swiss GEN Mobile
              ],
              [MODEL, [VENDOR, "Swiss"], [TYPE, MOBILE]],
              [
                /\b(zur\d{3}) b/i, // Swiss ZUR Tablet
              ],
              [MODEL, [VENDOR, "Swiss"], [TYPE, TABLET]],
              [
                /\b((zeki)?tb.*\b) b/i, // Zeki Tablets
              ],
              [MODEL, [VENDOR, "Zeki"], [TYPE, TABLET]],
              [
                /\b([yr]\d{2}) b/i,
                /\b(dragon[- ]+touch |dt)(\w{5}) b/i, // Dragon Touch Tablet
              ],
              [[VENDOR, "Dragon Touch"], MODEL, [TYPE, TABLET]],
              [
                /\b(ns-?\w{0,9}) b/i, // Insignia Tablets
              ],
              [MODEL, [VENDOR, "Insignia"], [TYPE, TABLET]],
              [
                /\b((nxa|next)-?\w{0,9}) b/i, // NextBook Tablets
              ],
              [MODEL, [VENDOR, "NextBook"], [TYPE, TABLET]],
              [
                /\b(xtreme\_)?(v(1[045]|2[015]|[3469]0|7[05])) b/i, // Voice Xtreme Phones
              ],
              [[VENDOR, "Voice"], MODEL, [TYPE, MOBILE]],
              [
                /\b(lvtel\-)?(v1[12]) b/i, // LvTel Phones
              ],
              [[VENDOR, "LvTel"], MODEL, [TYPE, MOBILE]],
              [
                /\b(ph-1) /i, // Essential PH-1
              ],
              [MODEL, [VENDOR, "Essential"], [TYPE, MOBILE]],
              [
                /\b(v(100md|700na|7011|917g).*\b) b/i, // Envizen Tablets
              ],
              [MODEL, [VENDOR, "Envizen"], [TYPE, TABLET]],
              [
                /\b(trio[-\w\. ]+) b/i, // MachSpeed Tablets
              ],
              [MODEL, [VENDOR, "MachSpeed"], [TYPE, TABLET]],
              [
                /\btu_(1491) b/i, // Rotor Tablets
              ],
              [MODEL, [VENDOR, "Rotor"], [TYPE, TABLET]],
              [
                /(shield[\w ]+) b/i, // Nvidia Shield Tablets
              ],
              [MODEL, [VENDOR, "Nvidia"], [TYPE, TABLET]],
              [
                /(sprint) (\w+)/i, // Sprint Phones
              ],
              [VENDOR, MODEL, [TYPE, MOBILE]],
              [
                /(kin\.[onetw]{3})/i, // Microsoft Kin
              ],
              [
                [MODEL, /\./g, " "],
                [VENDOR, MICROSOFT],
                [TYPE, MOBILE],
              ],
              [
                /droid.+; (cc6666?|et5[16]|mc[239][23]x?|vc8[03]x?)\)/i, // Zebra
              ],
              [MODEL, [VENDOR, ZEBRA], [TYPE, TABLET]],
              [/droid.+; (ec30|ps20|tc[2-8]\d[kx])\)/i],
              [MODEL, [VENDOR, ZEBRA], [TYPE, MOBILE]],
              [
                ///////////////////
                // SMARTTVS
                ///////////////////

                /smart-tv.+(samsung)/i, // Samsung
              ],
              [VENDOR, [TYPE, SMARTTV]],
              [/hbbtv.+maple;(\d+)/i],
              [
                [MODEL, /^/, "SmartTV"],
                [VENDOR, SAMSUNG],
                [TYPE, SMARTTV],
              ],
              [
                /(nux; netcast.+smarttv|lg (netcast\.tv-201\d|android tv))/i, // LG SmartTV
              ],
              [
                [VENDOR, LG],
                [TYPE, SMARTTV],
              ],
              [
                /(apple) ?tv/i, // Apple TV
              ],
              [VENDOR, [MODEL, APPLE + " TV"], [TYPE, SMARTTV]],
              [
                /crkey/i, // Google Chromecast
              ],
              [
                [MODEL, CHROME + "cast"],
                [VENDOR, GOOGLE],
                [TYPE, SMARTTV],
              ],
              [
                /droid.+aft(\w+)( bui|\))/i, // Fire TV
              ],
              [MODEL, [VENDOR, AMAZON], [TYPE, SMARTTV]],
              [
                /\(dtv[\);].+(aquos)/i,
                /(aquos-tv[\w ]+)\)/i, // Sharp
              ],
              [MODEL, [VENDOR, SHARP], [TYPE, SMARTTV]],
              [
                /(bravia[\w ]+)( bui|\))/i, // Sony
              ],
              [MODEL, [VENDOR, SONY], [TYPE, SMARTTV]],
              [
                /(mitv-\w{5}) bui/i, // Xiaomi
              ],
              [MODEL, [VENDOR, XIAOMI], [TYPE, SMARTTV]],
              [
                /Hbbtv.*(technisat) (.*);/i, // TechniSAT
              ],
              [VENDOR, MODEL, [TYPE, SMARTTV]],
              [
                /\b(roku)[\dx]*[\)\/]((?:dvp-)?[\d\.]*)/i, // Roku
                /hbbtv\/\d+\.\d+\.\d+ +\([\w\+ ]*; *([\w\d][^;]*);([^;]*)/i, // HbbTV devices
              ],
              [
                [VENDOR, trim],
                [MODEL, trim],
                [TYPE, SMARTTV],
              ],
              [
                /\b(android tv|smart[- ]?tv|opera tv|tv; rv:)\b/i, // SmartTV from Unidentified Vendors
              ],
              [[TYPE, SMARTTV]],
              [
                ///////////////////
                // CONSOLES
                ///////////////////

                /(ouya)/i, // Ouya
                /(nintendo) ([wids3utch]+)/i, // Nintendo
              ],
              [VENDOR, MODEL, [TYPE, CONSOLE]],
              [
                /droid.+; (shield) bui/i, // Nvidia
              ],
              [MODEL, [VENDOR, "Nvidia"], [TYPE, CONSOLE]],
              [
                /(playstation [345portablevi]+)/i, // Playstation
              ],
              [MODEL, [VENDOR, SONY], [TYPE, CONSOLE]],
              [
                /\b(xbox(?: one)?(?!; xbox))[\); ]/i, // Microsoft Xbox
              ],
              [MODEL, [VENDOR, MICROSOFT], [TYPE, CONSOLE]],
              [
                ///////////////////
                // WEARABLES
                ///////////////////

                /((pebble))app/i, // Pebble
              ],
              [VENDOR, MODEL, [TYPE, WEARABLE]],
              [
                /(watch)(?: ?os[,\/]|\d,\d\/)[\d\.]+/i, // Apple Watch
              ],
              [MODEL, [VENDOR, APPLE], [TYPE, WEARABLE]],
              [
                /droid.+; (glass) \d/i, // Google Glass
              ],
              [MODEL, [VENDOR, GOOGLE], [TYPE, WEARABLE]],
              [/droid.+; (wt63?0{2,3})\)/i],
              [MODEL, [VENDOR, ZEBRA], [TYPE, WEARABLE]],
              [
                /(quest( 2| pro)?)/i, // Oculus Quest
              ],
              [MODEL, [VENDOR, FACEBOOK], [TYPE, WEARABLE]],
              [
                ///////////////////
                // EMBEDDED
                ///////////////////

                /(tesla)(?: qtcarbrowser|\/[-\w\.]+)/i, // Tesla
              ],
              [VENDOR, [TYPE, EMBEDDED]],
              [
                /(aeobc)\b/i, // Echo Dot
              ],
              [MODEL, [VENDOR, AMAZON], [TYPE, EMBEDDED]],
              [
                ////////////////////
                // MIXED (GENERIC)
                ///////////////////

                /droid .+?; ([^;]+?)(?: bui|; wv\)|\) applew).+? mobile safari/i, // Android Phones from Unidentified Vendors
              ],
              [MODEL, [TYPE, MOBILE]],
              [
                /droid .+?; ([^;]+?)(?: bui|\) applew).+?(?! mobile) safari/i, // Android Tablets from Unidentified Vendors
              ],
              [MODEL, [TYPE, TABLET]],
              [
                /\b((tablet|tab)[;\/]|focus\/\d(?!.+mobile))/i, // Unidentifiable Tablet
              ],
              [[TYPE, TABLET]],
              [
                /(phone|mobile(?:[;\/]| [ \w\/\.]*safari)|pda(?=.+windows ce))/i, // Unidentifiable Mobile
              ],
              [[TYPE, MOBILE]],
              [
                /(android[-\w\. ]{0,9});.+buil/i, // Generic Android Device
              ],
              [MODEL, [VENDOR, "Generic"]],
            ],

            engine: [
              [
                /windows.+ edge\/([\w\.]+)/i, // EdgeHTML
              ],
              [VERSION, [NAME, EDGE + "HTML"]],
              [
                /webkit\/537\.36.+chrome\/(?!27)([\w\.]+)/i, // Blink
              ],
              [VERSION, [NAME, "Blink"]],
              [
                /(presto)\/([\w\.]+)/i, // Presto
                /(webkit|trident|netfront|netsurf|amaya|lynx|w3m|goanna)\/([\w\.]+)/i, // WebKit/Trident/NetFront/NetSurf/Amaya/Lynx/w3m/Goanna
                /ekioh(flow)\/([\w\.]+)/i, // Flow
                /(khtml|tasman|links)[\/ ]\(?([\w\.]+)/i, // KHTML/Tasman/Links
                /(icab)[\/ ]([23]\.[\d\.]+)/i, // iCab
                /\b(libweb)/i,
              ],
              [NAME, VERSION],
              [
                /rv\:([\w\.]{1,9})\b.+(gecko)/i, // Gecko
              ],
              [VERSION, NAME],
            ],

            os: [
              [
                // Windows
                /microsoft (windows) (vista|xp)/i, // Windows (iTunes)
              ],
              [NAME, VERSION],
              [
                /(windows (?:phone(?: os)?|mobile))[\/ ]?([\d\.\w ]*)/i, // Windows Phone
              ],
              [NAME, [VERSION, strMapper, windowsVersionMap]],
              [
                /windows nt 6\.2; (arm)/i, // Windows RT
                /windows[\/ ]?([ntce\d\. ]+\w)(?!.+xbox)/i,
                /(?:win(?=3|9|n)|win 9x )([nt\d\.]+)/i,
              ],
              [
                [VERSION, strMapper, windowsVersionMap],
                [NAME, "Windows"],
              ],
              [
                // iOS/macOS
                /ip[honead]{2,4}\b(?:.*os ([\w]+) like mac|; opera)/i, // iOS
                /(?:ios;fbsv\/|iphone.+ios[\/ ])([\d\.]+)/i,
                /cfnetwork\/.+darwin/i,
              ],
              [
                [VERSION, /_/g, "."],
                [NAME, "iOS"],
              ],
              [
                /(mac os x) ?([\w\. ]*)/i,
                /(macintosh|mac_powerpc\b)(?!.+haiku)/i, // Mac OS
              ],
              [
                [NAME, MAC_OS],
                [VERSION, /_/g, "."],
              ],
              [
                // Mobile OSes
                /droid ([\w\.]+)\b.+(android[- ]x86|harmonyos)/i, // Android-x86/HarmonyOS
              ],
              [VERSION, NAME],
              [
                // Android/WebOS/QNX/Bada/RIM/Maemo/MeeGo/Sailfish OS
                /(android|webos|qnx|bada|rim tablet os|maemo|meego|sailfish)[-\/ ]?([\w\.]*)/i,
                /(blackberry)\w*\/([\w\.]*)/i, // Blackberry
                /(tizen|kaios)[\/ ]([\w\.]+)/i, // Tizen/KaiOS
                /\((series40);/i, // Series 40
              ],
              [NAME, VERSION],
              [
                /\(bb(10);/i, // BlackBerry 10
              ],
              [VERSION, [NAME, BLACKBERRY]],
              [
                /(?:symbian ?os|symbos|s60(?=;)|series60)[-\/ ]?([\w\.]*)/i, // Symbian
              ],
              [VERSION, [NAME, "Symbian"]],
              [
                /mozilla\/[\d\.]+ \((?:mobile|tablet|tv|mobile; [\w ]+); rv:.+ gecko\/([\w\.]+)/i, // Firefox OS
              ],
              [VERSION, [NAME, FIREFOX + " OS"]],
              [
                /web0s;.+rt(tv)/i,
                /\b(?:hp)?wos(?:browser)?\/([\w\.]+)/i, // WebOS
              ],
              [VERSION, [NAME, "webOS"]],
              [
                /watch(?: ?os[,\/]|\d,\d\/)([\d\.]+)/i, // watchOS
              ],
              [VERSION, [NAME, "watchOS"]],
              [
                // Google Chromecast
                /crkey\/([\d\.]+)/i, // Google Chromecast
              ],
              [VERSION, [NAME, CHROME + "cast"]],
              [
                /(cros) [\w]+(?:\)| ([\w\.]+)\b)/i, // Chromium OS
              ],
              [[NAME, CHROMIUM_OS], VERSION],
              [
                // Smart TVs
                /panasonic;(viera)/i, // Panasonic Viera
                /(netrange)mmh/i, // Netrange
                /(nettv)\/(\d+\.[\w\.]+)/i, // NetTV

                // Console
                /(nintendo|playstation) ([wids345portablevuch]+)/i, // Nintendo/Playstation
                /(xbox); +xbox ([^\);]+)/i, // Microsoft Xbox (360, One, X, S, Series X, Series S)

                // Other
                /\b(joli|palm)\b ?(?:os)?\/?([\w\.]*)/i, // Joli/Palm
                /(mint)[\/\(\) ]?(\w*)/i, // Mint
                /(mageia|vectorlinux)[; ]/i, // Mageia/VectorLinux
                /([kxln]?ubuntu|debian|suse|opensuse|gentoo|arch(?= linux)|slackware|fedora|mandriva|centos|pclinuxos|red ?hat|zenwalk|linpus|raspbian|plan 9|minix|risc os|contiki|deepin|manjaro|elementary os|sabayon|linspire)(?: gnu\/linux)?(?: enterprise)?(?:[- ]linux)?(?:-gnu)?[-\/ ]?(?!chrom|package)([-\w\.]*)/i,
                // Ubuntu/Debian/SUSE/Gentoo/Arch/Slackware/Fedora/Mandriva/CentOS/PCLinuxOS/RedHat/Zenwalk/Linpus/Raspbian/Plan9/Minix/RISCOS/Contiki/Deepin/Manjaro/elementary/Sabayon/Linspire
                /(hurd|linux) ?([\w\.]*)/i, // Hurd/Linux
                /(gnu) ?([\w\.]*)/i, // GNU
                /\b([-frentopcghs]{0,5}bsd|dragonfly)[\/ ]?(?!amd|[ix346]{1,2}86)([\w\.]*)/i, // FreeBSD/NetBSD/OpenBSD/PC-BSD/GhostBSD/DragonFly
                /(haiku) (\w+)/i, // Haiku
              ],
              [NAME, VERSION],
              [
                /(sunos) ?([\w\.\d]*)/i, // Solaris
              ],
              [[NAME, "Solaris"], VERSION],
              [
                /((?:open)?solaris)[-\/ ]?([\w\.]*)/i, // Solaris
                /(aix) ((\d)(?=\.|\)| )[\w\.])*/i, // AIX
                /\b(beos|os\/2|amigaos|morphos|openvms|fuchsia|hp-ux|serenityos)/i, // BeOS/OS2/AmigaOS/MorphOS/OpenVMS/Fuchsia/HP-UX/SerenityOS
                /(unix) ?([\w\.]*)/i, // UNIX
              ],
              [NAME, VERSION],
            ],
          };

          /////////////////
          // Constructor
          ////////////////

          var UAParser = function (ua, extensions) {
            if (typeof ua === OBJ_TYPE) {
              extensions = ua;
              ua = undefined;
            }

            if (!(this instanceof UAParser)) {
              return new UAParser(ua, extensions).getResult();
            }

            var _navigator =
              typeof window !== UNDEF_TYPE && window.navigator
                ? window.navigator
                : undefined;
            var _ua =
              ua ||
              (_navigator && _navigator.userAgent
                ? _navigator.userAgent
                : EMPTY);
            var _uach =
              _navigator && _navigator.userAgentData
                ? _navigator.userAgentData
                : undefined;
            var _rgxmap = extensions ? extend(regexes, extensions) : regexes;
            var _isSelfNav = _navigator && _navigator.userAgent == _ua;

            this.getBrowser = function () {
              var _browser = {};
              _browser[NAME] = undefined;
              _browser[VERSION] = undefined;
              rgxMapper.call(_browser, _ua, _rgxmap.browser);
              _browser[MAJOR] = majorize(_browser[VERSION]);
              // Brave-specific detection
              if (
                _isSelfNav &&
                _navigator &&
                _navigator.brave &&
                typeof _navigator.brave.isBrave == FUNC_TYPE
              ) {
                _browser[NAME] = "Brave";
              }
              return _browser;
            };
            this.getCPU = function () {
              var _cpu = {};
              _cpu[ARCHITECTURE] = undefined;
              rgxMapper.call(_cpu, _ua, _rgxmap.cpu);
              return _cpu;
            };
            this.getDevice = function () {
              var _device = {};
              _device[VENDOR] = undefined;
              _device[MODEL] = undefined;
              _device[TYPE] = undefined;
              rgxMapper.call(_device, _ua, _rgxmap.device);
              if (_isSelfNav && !_device[TYPE] && _uach && _uach.mobile) {
                _device[TYPE] = MOBILE;
              }
              // iPadOS-specific detection: identified as Mac, but has some iOS-only properties
              if (
                _isSelfNav &&
                _device[MODEL] == "Macintosh" &&
                _navigator &&
                typeof _navigator.standalone !== UNDEF_TYPE &&
                _navigator.maxTouchPoints &&
                _navigator.maxTouchPoints > 2
              ) {
                _device[MODEL] = "iPad";
                _device[TYPE] = TABLET;
              }
              return _device;
            };
            this.getEngine = function () {
              var _engine = {};
              _engine[NAME] = undefined;
              _engine[VERSION] = undefined;
              rgxMapper.call(_engine, _ua, _rgxmap.engine);
              return _engine;
            };
            this.getOS = function () {
              var _os = {};
              _os[NAME] = undefined;
              _os[VERSION] = undefined;
              rgxMapper.call(_os, _ua, _rgxmap.os);
              if (
                _isSelfNav &&
                !_os[NAME] &&
                _uach &&
                _uach.platform != "Unknown"
              ) {
                _os[NAME] = _uach.platform
                  .replace(/chrome os/i, CHROMIUM_OS)
                  .replace(/macos/i, MAC_OS); // backward compatibility
              }
              return _os;
            };
            this.getResult = function () {
              return {
                ua: this.getUA(),
                browser: this.getBrowser(),
                engine: this.getEngine(),
                os: this.getOS(),
                device: this.getDevice(),
                cpu: this.getCPU(),
              };
            };
            this.getUA = function () {
              return _ua;
            };
            this.setUA = function (ua) {
              _ua =
                typeof ua === STR_TYPE && ua.length > UA_MAX_LENGTH
                  ? trim(ua, UA_MAX_LENGTH)
                  : ua;
              return this;
            };
            this.setUA(_ua);
            return this;
          };

          UAParser.VERSION = LIBVERSION;
          UAParser.BROWSER = enumerize([NAME, VERSION, MAJOR]);
          UAParser.CPU = enumerize([ARCHITECTURE]);
          UAParser.DEVICE = enumerize([
            MODEL,
            VENDOR,
            TYPE,
            CONSOLE,
            MOBILE,
            SMARTTV,
            TABLET,
            WEARABLE,
            EMBEDDED,
          ]);
          UAParser.ENGINE = UAParser.OS = enumerize([NAME, VERSION]);

          ///////////
          // Export
          //////////

          // check js environment
          if (typeof exports !== UNDEF_TYPE) {
            // nodejs env
            if (typeof module !== UNDEF_TYPE && module.exports) {
              exports = module.exports = UAParser;
            }
            exports.UAParser = UAParser;
          } else {
            // requirejs env (optional)
            if (typeof define === FUNC_TYPE && define.amd) {
              define(function () {
                return UAParser;
              });
            } else if (typeof window !== UNDEF_TYPE) {
              // browser env
              window.UAParser = UAParser;
            }
          }

          // jQuery/Zepto specific (optional)
          // Note:
          //   In AMD env the global scope should be kept clean, but jQuery is an exception.
          //   jQuery always exports to global scope, unless jQuery.noConflict(true) is used,
          //   and we should catch that.
          var $ =
            typeof window !== UNDEF_TYPE && (window.jQuery || window.Zepto);
          if ($ && !$.ua) {
            var parser = new UAParser();
            $.ua = parser.getResult();
            $.ua.get = function () {
              return parser.getUA();
            };
            $.ua.set = function (ua) {
              parser.setUA(ua);
              var result = parser.getResult();
              for (var prop in result) {
                $.ua[prop] = result[prop];
              }
            };
          }
        })(typeof window === "object" ? window : this);
      },
      {},
    ],
    98: [
      function (require, module, exports) {
        //imports
        const io = require("socket.io-client");
        const mediasoupClient = require("mediasoup-client");

        //default meeting room settings by host
        let audioSetting = "approval";
        let videoSetting = "approval";
        let screenshareSetting = "approval";
        let chatSetting = "allow";
        let audioOnlyRoom = false;

        //default room requests
        let totalRequests = 0;
        let requests = [];
        let micRequests = [];
        let screenshareRequests = [];
        let videoRequests = [];
        let chatRequests = [];

        //Restriction by admin for user
        let adminRestrictSetting = false;
        let forceFullDisplay = true;
        let screenForceFullDisplay = false;
        let prevForceFullDisplay = true;

        //disp
        let prevMainHeightWidth = 0;
        let mainHeightWidth = 0;
        let eventRoomParams;
        let targetOrientation = "landscape";
        let targetResolution = "sd";
        let vidCons;

        let eventType = "webinar";
        let hostLabel = "Host";
        let buttonsAddedForChat = false;
        let isReactionModalShown = false;
        let isReactionParticipantModalShown = false;
        let isShareEventModalShown = false;
        let chatRefStreams = [];
        let confHide = false;
        let deferHide = false;

        let adminPasscode = null;

        //recording
        let recordStarted = false;
        let recordPaused = false;
        let recordStopped = false;
        let recordResumed = false;

        const sec = window.location.pathname.split("/")[3];
        const roomName = window.location.pathname.split("/")[2];
        const directEventType = window.location.pathname.split("/")[1];

        let redirectURL = `${window.location.origin}/meeting/start`;

        let isl = "video";
        let member;
        let pem;
        let islevel;
        let sendGroup = false;
        let messageReceiver;
        let messages = [];
        let waitingParticipants = [];
        let coHost;
        let coHostResponsibility = [];
        let youAreCoHost = false;

        //polls
        let polls = [];
        let poll = null;

        let recordTimerInterval; // Variable to hold the timer interval
        let recordStartTime; // Variable to store the start time
        let recordElapsedTime = 0; // Variable to store the elapsed time
        let isTimerRunning = false; // Flag to track the timer state
        let canPauseResume = false; // Flag to indicate if pause/resume actions are allowed

        //display sizes
        let QnHDCons = { width: { ideal: 320 }, height: { ideal: 180 } };
        let sdCons = { width: { ideal: 640 }, height: { ideal: 360 } };
        let hdCons = { width: { ideal: 1280 }, height: { ideal: 720 } };
        let fhdCons = { width: { ideal: 1920 }, height: { ideal: 1080 } };
        let qhdCons = { width: { ideal: 2560 }, height: { ideal: 1440 } };

        let QnHDConsPort = { width: { ideal: 180 }, height: { ideal: 320 } };
        let sdConsPort = { width: { ideal: 360 }, height: { ideal: 640 } };
        let hdConsPort = { width: { ideal: 720 }, height: { ideal: 1280 } };
        let fhdConsPort = { width: { ideal: 1080 }, height: { ideal: 1920 } };
        let qhdConsPort = { width: { ideal: 1440 }, height: { ideal: 2560 } };

        let QnHDConsNeu = { width: { ideal: 240 }, height: { ideal: 240 } };
        let sdConsNeu = { width: { ideal: 480 }, height: { ideal: 480 } };
        let hdConsNeu = { width: { ideal: 960 }, height: { ideal: 960 } };
        let fhdConsNeu = { width: { ideal: 1440 }, height: { ideal: 1440 } };
        let qhdConsNeu = { width: { ideal: 1920 }, height: { ideal: 1920 } };

        let oldSound;
        let oldSoundIds = [];
        let gotAllVids = false;

        let adminIDStream;
        let screenShareIDStream;

        let screenShareNameStream;
        let adminNameStream;

        //main constants for sfu
        let device;
        let rtpCapabilities;
        let producerTransport;
        let producerTransportMediaSFU;
        let AudioProducerTransport;
        let consumerTransports = [];
        let consumingTransports = []; //ids of all consuming transports
        let audioProducer;
        let videoProducer;
        let screenProducer;
        let consumer;

        let audioProducerMediaSFU;
        let videoProducerMediaSFU;
        let screenProducerMediaSFU;

        //all streams for audio and video
        let lastReorderTime = 0;
        let reorderInterval = 30000;
        let fastOrderInterval = 10000;
        let mixed_alVideoStreams = [];
        let non_alVideoStreams_muted = [];
        let non_alVideoStreams_unmuted = [];
        let paginatedStreams = [];
        let doPaginate = false;
        let prevDoPaginate = false;
        let shareEnded = false;
        let autoWave = true; // !autoWave=all displayed; fix this for primary display where only video is shown
        let updateMainWindow = true;
        let audioChanged = false;
        let itemPageLimit = 4;
        let screenPageLimit = 4;
        screenPageLimit = Math.min(screenPageLimit, itemPageLimit);
        let fixedPageLimit = 4;
        let currentUserPage = 0;
        let forcePageRender = false;
        let sortAudioLoudness = false;

        let audioDecibels = [];
        let allAudioStreams = [];
        let allVideoStreams = [];
        let oldAllStreams = [];
        let remoteScreenStream = [];
        let newLimitedStreams = [];
        let newLimitedStreamsIDs = [];
        let localStream;
        let activeSounds = [];
        let dispActiveNames = [];
        let p_dispActiveNames = [];
        let prevDispActiveNames = [];
        let optActiveNames = [];
        let prevOptActiveNames = [];
        let activeNames = [];
        let p_activeNames = [];
        let prevActiveNames = [];
        let screenStates = [
          {
            mainScreenPerson: null,
            mainScreenProducerId: null,
            mainScreenFilled: false,
            adminOnMainScreen: false,
          },
        ];
        let prevScreenStates = [
          {
            mainScreenPerson: null,
            mainScreenProducerId: null,
            mainScreenFilled: false,
            adminOnMainScreen: false,
          },
        ];
        let streamNames = [];
        let audStreamNames = [];
        let firstAll = false;
        let nForReadjust = 0;
        let nForReadjustRecord = 0;
        let lowToHighState = true;
        let updateDateState = null;

        let mainAlertedTime = null;
        let startReport = false;
        let endReport = true;
        let lastUpdate = null;
        let camQuality = true;
        let hostFirstSwitch = false;
        //mainScreen props
        let mainScreenProducerId;
        let mainScreenFilled = false;
        let adminOnMainScreen = false;
        let mainScreenPerson;
        let lock_screen = false;
        let defer_receive = false;
        let first_round = false;

        let landScaped = false;
        let loadingModal = true;
        let membersReceived = false;
        let deferScreenReceived = false;
        let deferReceiveAllTransports = false;

        //Display type
        let meetingDisplayType = "media"; //video, media, all
        let prevMeetingDisplayType = "media"; //video, media, all
        let meetingVideoOptimized = false; // valid for option of video only recording; will push audio person or graph

        let requestIntervalSeconds = 30000;
        let updateRequestIntervalSeconds = 240; // *1000

        //Recording
        let userRecordingParams;
        let recordChangeSeconds = 15000;

        let recordingVideoType = "fullDisplay"; //fullDisplay
        let recordingDisplayType = "media";
        let recordingVideoOptimized = true; // valid for option of video only recording; will push audio person or graph
        let recordingNameTags = true;
        let recordingBackgroundColor;
        let recordingNameTagsColor;
        let recordingOrientationVideo = "landscape";
        let recordingMediaOptions;
        let prevRecordingMediaOptions;
        let recordingAudioOptions;
        let recordingVideoOptions;
        let clearedToRecord = true;
        let clearedToResume = true;
        let confirmedToRecord = false;
        let pauseLimit = 0;
        let pauseRecordCount = 0;
        let recordDuration = 0;
        let launchRecording = true;
        let stopLaunchRecording = false;
        let recordingAddHLS = false;
        let recordingAddText = false;
        let recordingCustomText = "Add Custom Text";
        let recordingCustomTextPosition = "top";
        let recordingCustomTextColor = "white";

        let recordingAudioPausesLimit;
        let recordingAudioPausesCount;
        let recordingAudioSupport;
        let recordingAudioPeopleLimit;
        let recordingAudioParticipantsTimeLimit;

        let recordingVideoPausesLimit;
        let recordingVideoPausesCount;
        let recordingVideoSupport;
        let recordingVideoPeopleLimit;
        let recordingVideoParticipantsTimeLimit;

        let recordingAllParticipantsSupport;
        let recordingVideoParticipantsSupport;
        let recordingAllParticipantsFullRoomSupport;
        let recordingVideoParticipantsFullRoomSupport;

        let recordingPreferredOrientation;
        let recordingSupportForOtherOrientation;
        let recordingMultiFormatsSupport;

        //mediaTypes
        let userDefaultAudioOutputDevice = null;
        let userDefaultVideoInputDevice = null;
        let userDefaultAudioInputDevice = null;
        let prevAudioInputDevice = null;
        let prevVideoInputDevice = null;
        let currentFacingMode = "user";
        let prevFacingMode = "user";

        let defVideoID = null;
        let defAudioID = null;

        //{producerId:remoteProducerId,stream:nStream,id:remoteProducerId,name:remoteName}
        allVideoStreams = [
          ...allVideoStreams,
          { producerId: "youyou", stream: null, id: "youyou", name: "youyou" },
        ];
        streamNames = [...streamNames, { id: "youyou", name: "youyou" }];

        //consuming streams

        //control for minor grid of videos
        let removeAltGrid;

        let frameRate = 10;
        let maxFrameRate = 15;

        //screen share parameters
        let screen_params = {
          encodings: [
            {
              rid: "r7",
              maxBitrate: 3000000,
              initialAvailableBitrate: 1500000,
            },
          ],
          codecOptions: {
            videoGoogleStartBitrate: 1000,
          },
        };

        let v_params = {
          encodings: [
            {
              rid: "r3",
              maxBitrate: 200000,
              initialAvailableBitrate: 80000,
              minBitrate: 40000,
              scalabilityMode: "L1T3",
              scaleResolutionDownBy: 4.0,
            },
            {
              rid: "r4",
              maxBitrate: 400000,
              initialAvailableBitrate: 160000,
              minBitrate: 80000,
              scalabilityMode: "L1T3",
              scaleResolutionDownBy: 2.0,
            },
            {
              rid: "r5",
              maxBitrate: 800000,
              initialAvailableBitrate: 320000,
              minBitrate: 160000,
              scalabilityMode: "L1T3",
            },
          ],

          codecOptions: {
            videoGoogleStartBitrate: 320,
          },
        };

        //host parameters
        let h_params = {
          encodings: [
            {
              rid: "r8",
              maxBitrate: 240000,
              initialAvailableBitrate: 96000,
              minBitrate: 48000,
              scalabilityMode: "L1T3",
              scaleResolutionDownBy: 4.0,
            },
            {
              rid: "r9",
              maxBitrate: 480000,
              initialAvailableBitrate: 192000,
              minBitrate: 96000,
              scalabilityMode: "L1T3",
              scaleResolutionDownBy: 2.0,
            },
            {
              rid: "r10",
              maxBitrate: 960000,
              initialAvailableBitrate: 384000,
              minBitrate: 192000,
              scalabilityMode: "L1T3",
            },
          ],

          codecOptions: {
            videoGoogleStartBitrate: 384,
          },
        };

        //audio parameters

        let a_params = {
          encodings: [
            {
              rid: "r0",
              maxBitrate: 64000,
            },
          ],
        };

        let audioParams;
        let videoParams;
        let audioParamse;
        let videoParamse;
        let params;

        //constants for romm
        let shareScreen = false; //if screen is shared to others globally
        let shareScreenStarted = false; //if screen is shared globally
        let screenId; //screen id of the screen being shared

        let shared = false; //if screen is shared

        let allowed = false; //if video is allowed
        let canRecord = true; //if recording is allowed
        let canDownload = false; //if download is allowed
        let transportCreated = false; //if transport is created
        let transportCreatedAudio = false; //if transport is created
        let transportCreatedVideo = false; //if transport is created
        let transportCreatedScreen = false; //if transport is created

        let participants = []; //list of participants
        let participantsAll = []; //list of participants
        let ref_participants = []; //list of participants
        let audioRequestState; //pending, accepted, rejected
        let videoRequestState; //pending, accepted, rejected
        let screenRequestState; //pending, accepted, rejected
        let chatRequestState; //pending, accepted, rejected

        //awaiting action from user after permission request
        micAction = false;
        videoAction = false;
        screenAction = false;
        chatAction = false;

        // default streams initialized
        let localStreamVideo;
        let localStreamScreen;
        let localStreamAudio;
        let localStreamAudioVideo;
        // let stream

        //state of streams
        let audioAlreadyOn = false;
        let videoAlreadyOn = false;
        let screenAlreadyOn = false;
        let chatAlreadyOn = false;
        let audioPaused = false;

        //connect to socket
        let socket;
        let p_sockets = [];

        function initializeSocket() {
          //connect to socket
          socket = io("/media");

          socket.on("connection-success", async ({ socketId }) => {
            //get the room detail for the secretCode (sec)
            await socket.emit(
              "fetchRoom",
              { sec },
              async ({
                success,
                roomName,
                capacity,
                duration,
                pem,
                name,
                audioPreference,
                videoPreference,
                audioOutputPreference,
              }) => {
                if (success) {
                  //found details; set them

                  member = await name;
                  userDefaultAudioOutputDevice = await audioOutputPreference;
                  userDefaultAudioInputDevice = await audioPreference;
                  userDefaultVideoInputDevice = await videoPreference;

                  //set options for media
                  if (pem == "2") {
                    //host is 'pem' '2' before joining room
                    //set the islevel to '2' for host and '1' for others
                    islevel = "2";
                    youAreHost = true;
                  } else {
                    islevel = "1";
                    youAreHost = false;
                  }

                  //hide the loading modal
                  await hideSpanned(islevel);

                  //call the join room function
                  await joinRoom();
                } else {
                  // redirect to home page if room not found or secretCode has expired or invalid
                  await showAlert(
                    "Sorry, you must enter an event ID. Redirecting to home page in 2 seconds."
                  );

                  setTimeout(async function () {
                    window.location.href = await redirectURL;
                  }, 2000);
                }
              }
            );
          });

          //checks screen share permission
          async function checkScreenShare() {
            // stop screen share if already shared or request screen share if not shared
            if (shared) {
              if (whiteboardStarted && !whiteboardEnded) {
                showAlert(
                  "Screen share is not allowed when whiteboard is active",
                  "danger"
                );
                return;
              }

              await stopShareScreen();
            } else {
              // can't share if breakout room is active
              if (breakOutRoomStarted && !breakOutRoomEnded) {
                showAlert(
                  "Screen share is not allowed when breakout room is active",
                  "danger"
                );
                return;
              }

              if (whiteboardStarted && !whiteboardEnded) {
                showAlert(
                  "Screen share is not allowed when whiteboard is active",
                  "danger"
                );
                return;
              }

              await requestScreenShare();
            }
          }

          const addListeners = (mediasfu_socket) => {
            mediasfu_socket.on("startRecords", async () => {
              //update to initiate recording

              //send the start recording event to the server with the roomName and member
              await mediasfu_socket.emit(
                "startRecordIng",
                { roomName, member },
                ({ success }) => {
                  if (success) {
                  } else {
                  }
                }
              );
            });

            mediasfu_socket.on("reInitiateRecording", async () => {
              //function to reInitiate recording
              if (!adminRestrictSetting) {
                await mediasfu_socket.emit(
                  "startRecordIng",
                  { roomName, member },
                  ({ success }) => {
                    if (success) {
                    } else {
                    }
                  }
                );
              }
            });

            mediasfu_socket.on("roomRecordParams", async ({ recordParams }) => {
              //get record params
              //recordParams is the record params for the event

              await getRecordParams(recordParams);
            });

            mediasfu_socket.on(
              "RecordingNotice",
              async ({ state, userRecordingParam, pauseCount, timeDone }) => {
                //update for recording state/status
                //state can be recording, pause, stop
                //userRecordingParam is the recording parameters
                //pauseCount is the pause count
                //timeDone is the time elapsed

                if (islevel != 2) {
                  //if not host then update the recording state indicator
                  updateRecordingStateIndicatorMember(state);
                } else {
                  //if host then update the recording state indicator and add further functionalities
                  //this is mainly applicble for the host returning to the event room after leaving (leaving pauses the recording)
                  if (state == "pause") {
                    if (userRecordingParam) {
                      updateRecordingStateIndicatorMember(state);
                      userRecordingParams = userRecordingParam;
                      recordingMediaOptions =
                        userRecordingParams.mainSpecs.mediaOptions;
                      recordingAudioOptions =
                        userRecordingParams.mainSpecs.audioOptions;
                      recordingVideoOptions =
                        userRecordingParams.mainSpecs.videoOptions;
                      recordingVideoType =
                        userRecordingParams.mainSpecs.videoType;
                      recordingVideoOptimized =
                        userRecordingParams.mainSpecs.videoOptimized;
                      recordingDisplayType =
                        userRecordingParams.mainSpecs.recordingDisplayType;
                      recordingAddHLS = userRecordingParams.mainSpecs.addHLS;
                      recordingNameTags =
                        userRecordingParams.dispSpecs.nameTags;
                      recordingBackgroundColor =
                        userRecordingParams.dispSpecs.backgroundColor;
                      recordingNameTagsColor =
                        userRecordingParams.dispSpecs.nameTagsColor;
                      recordingOrientationVideo =
                        userRecordingParams.dispSpecs.orientationVideo;
                      recordingAddText = userRecordingParams.textSpecs.addText;
                      recordingCustomText =
                        userRecordingParams.textSpecs.customText;
                      recordingCustomTextPosition =
                        userRecordingParams.textSpecs.customTextPosition;
                      recordingCustomTextColor =
                        userRecordingParams.textSpecs.customTextColor;

                      pauseRecordCount = pauseCount;

                      recordElapsedTime = timeDone;

                      let rowHTML;

                      if (eventType != "broadcast") {
                        rowHTML = await `<div class="row">
    
            <div class="col-2">
              <button id="Rec_btnPause" class="btn-pause" style="background-color: transparent; border: 0; padding: 0;"><i class="fas fa-play-circle fa-lg"></i></button>
            </div>
            <div class="col-2">
              <button id="Rec_btnStop" class="btn-stop" style="background-color: transparent; border: 0; padding: 0;"><i class="fas fa-stop-circle fa-lg"></i></button>
            </div>
            <div class="col-3">
              <div id="Rec_progressTimer" class="progress-timer Rec_progressTimer" style="background-color: transparent; border: 0; padding: 0;">00:00:00</div>
            </div>
            <div class="col-2">
              <div id="Rec_statusIndicator" class="status-indicator Rec_statusIndicator"><i class="fas fa-dot-circle-o text-success fa-lg id="Rec_statusIcon"></i></div>
            </div>
            <div class="col-2">
            <div id="Rec_Settings" class="recsettings-indicator Rec_Settings"><i class="fas fa-gear fa-lg id="Rec_settingsIcon"></i></div>
            </div>
            <div class="col-1">
              
            </div>
        
          </div>`;
                      } else {
                        rowHTML =
                          await `<div class="row" style="white-space: nowrap; overflow-x: auto; flex-wrap: nowrap;margin: 0 10%;">
    
        <div class="col-2">
          <button id="Rec_btnPause" class="btn-pause" style="background-color: transparent; border: 0; padding: 0;"><i class="fas fa-play-circle fa-md"></i></button>
        </div>
        <div class="col-2">
          <button id="Rec_btnStop" class="btn-stop" style="background-color: transparent; border: 0; padding: 0;"><i class="fas fa-stop-circle fa-md"></i></button>
        </div>
        <div class="col-4">
          <div id="Rec_progressTimer" class="progress-timer Rec_progressTimer" style="background-color: transparent; border: 0; padding: 0;">00:00:00</div>
        </div>
        <div class="col-2">
          <div id="Rec_statusIndicator" class="status-indicator Rec_statusIndicator"><i class="fas fa-dot-circle-o text-success fa-sm id="Rec_statusIcon"></i></div>
        </div>
        <div class="col-2">
        <div id="Rec_Settings" class="recsettings-indicator Rec_Settings"><i class="fas fa-gear fa-md id="Rec_settingsIcon"></i></div>
        </div>
    
      </div>`;
                      }

                      recordStarted = true;
                      recordPaused = true;
                      launchRecording = false;
                      recordStopped = false;

                      let rowElement = await $(rowHTML); // Convert the HTML string to a jQuery object

                      // Append the rowElement to the desired container
                      $(".recordStated").empty().append(rowElement);

                      isTimerRunning = false;
                      canPauseResume = true;

                      recordElapsedTime = Math.floor(recordElapsedTime / 1000);
                      recordStartTime =
                        Math.floor(Date.now() / 1000) - recordElapsedTime;

                      // Format the time in HH:MM:SS format
                      const hours = Math.floor(recordElapsedTime / 3600);
                      const minutes = Math.floor(
                        (recordElapsedTime % 3600) / 60
                      );
                      const seconds = recordElapsedTime % 60;
                      const formattedTime =
                        padNumber(hours) +
                        ":" +
                        padNumber(minutes) +
                        ":" +
                        padNumber(seconds);

                      updateRecordingStateIndicator("pause", rowElement);

                      // Update the content of Rec_progressTimer
                      $("#Rec_progressTimer").text(formattedTime);

                      rowElement
                        .find("#Rec_Settings")
                        .on("click", async function () {
                          //check if recording is paused
                          if (recordPaused) {
                            //show the recording settings modal
                            $("#startRecButton").hide();
                            clearedToResume = false;
                            $("#recordingModal").modal("show");
                          } else {
                            showAlert(
                              "You can only change recording settings when recording is paused.",
                              "danger"
                            );
                          }
                        });

                      // Add event listeners to the buttons within the rowElement
                      rowElement
                        .find("#Rec_btnPause")
                        .on("click", async function () {
                          // handle the pause button click event
                          if (recordStopped) {
                            showAlert(
                              "Recording has been stopped. You cannot start it again.",
                              "danger"
                            );
                            return;
                          }

                          if (
                            recordStarted &&
                            !recordPaused &&
                            !recordStopped
                          ) {
                            let proceed = false;

                            proceed = await checkPauseState();

                            if (!proceed) {
                              return;
                            }

                            let record = recordPauseTimer();
                            if (record) {
                              let pause = await pauseRecording();

                              if (!pause) {
                                return;
                              }

                              recordPaused = true;
                              updateRecordingStateIndicator(
                                "pause",
                                rowElement
                              );
                              $(this)
                                .find("i")
                                .removeClass("fa-pause-circle")
                                .addClass("fa-play-circle");

                              setTimeout(() => {
                                canPauseResume = true; // Enable pause/resume actions after 30 seconds of elapsed time
                              }, recordChangeSeconds);
                            }
                          } else if (
                            recordStarted &&
                            recordPaused &&
                            !recordStopped
                          ) {
                            if (!confirmedToRecord) {
                              showAlert(
                                "You must confirm your recording settings before you can resume recording.",
                                "danger"
                              );
                              return;
                            }

                            let proceed = false;

                            proceed = await checkResumeState();

                            if (!proceed) {
                              return;
                            }

                            if (islevel == "2") {
                              if (
                                recordingMediaOptions == "video" &&
                                !videoAlreadyOn
                              ) {
                                showAlert(
                                  "You cannot resume with video recording while camera is off.",
                                  "danger"
                                );
                                return;
                              } else if (
                                recordingMediaOptions == "audio" &&
                                !audioAlreadyOn
                              ) {
                                showAlert(
                                  "You cannot resume with audio recording while microphone is off.",
                                  "danger"
                                );
                                return;
                              }
                            }

                            let resume = recordResumeTimer();
                            if (resume) {
                              let res = await startRecording();

                              if (!res) {
                                isTimerRunning = true;
                                canPauseResume = true;
                                await recordPauseTimer();
                                isTimerRunning = false;
                                canPauseResume = true;
                                return;
                              }

                              recordPaused = false;
                              recordResumed = true;
                              await rePort(true);
                              updateRecordingStateIndicator(
                                "recording",
                                rowElement
                              );
                              $(this)
                                .find("i")
                                .removeClass("fa-play-circle")
                                .addClass("fa-pause-circle");

                              setTimeout(() => {
                                canPauseResume = true; // Enable pause/resume actions after 30 seconds of elapsed time
                              }, recordChangeSeconds);
                            }
                          }
                        });

                      rowElement
                        .find("#Rec_btnStop")
                        .on("click", async function () {
                          // handle the stop button click event
                          if (recordStarted && !recordStopped) {
                            let stop = recordPauseTimer(true); // Pause the timer
                            let stopped = false;
                            if (stop) {
                              stopped = await stopRecording();
                            } else {
                              return;
                            }

                            if (stopped) {
                              recordStopped = true;
                              recordPaused = false;
                              recordResumed = false;
                              recordStarted = false;

                              updateRecordingStateIndicator("stop", rowElement);

                              rowElement
                                .find("#Rec_btnPause")
                                .find("i")
                                .removeClass("fa-pause-circle")
                                .addClass("fa-play-circle");
                            }
                          } else {
                            showAlert(
                              "Recording has not started yet or already stopped",
                              "warning"
                            );
                          }
                        });
                    } else {
                      SoundPlayer(
                        "https://www.mediasfu.com/sounds/record-paused.mp3"
                      );
                    }
                  } else if (state == "stop") {
                    //if recording has stopped then update the recording state indicator and stop attempt to resume recording

                    updateRecordingStateIndicatorMember(state);

                    $(".recordStated").html(
                      '<button class="list-group-item list-group-item-action" style="background-color: transparent;border: 0; font-size: medium; padding-left: 0; margin-left: 0;" id="recordState"> <i class="fas fa-record-vinyl fa-lg border-0 mr-2" > </i>Record</button>'
                    );

                    recordStarted = true;
                    recordStopped = true;
                    launchRecording = false;
                    stopLaunchRecording = true;
                  } else {
                    SoundPlayer(
                      "https://www.mediasfu.com/sounds/record-progress.mp3"
                    );
                  }
                }
              }
            );

            mediasfu_socket.on("timeLeftRecording", async ({ timeLeft }) => {
              //update for time left for recording
              //timeLeft is the time left in seconds

              //make timeleft absolute and make 0 decimal places
              timeLeft = Math.abs(timeLeft).toFixed(0);
              showAlert(
                "Recording will stop in less than " + timeLeft + " seconds",
                "danger"
              );
            });

            mediasfu_socket.on(
              "stoppedRecording",
              async ({ state, reason }) => {
                //update for recording ended
                //state can only be stop; mainly triggered due to time limit

                showAlert("Recording has stopped - " + reason, "danger");
                recordStopped = true;
              }
            );

            p_sockets = [mediasfu_socket];
          };

          async function joinRoomOnMediaSFU(payload, apiUserName, apiKey) {
            try {
              const response = await fetch("/joinRoom", {
                method: "POST",
                headers: {
                  "Content-Type": "application/json",
                  Authorization: "Bearer " + apiUserName + ":" + apiKey,
                },
                body: JSON.stringify(payload),
              });

              if (!response.ok) {
                throw new Error(`HTTP error! Status: ${response.status}`);
              }

              const data = await response.json();

              return { data, success: true };
            } catch (error) {
              return { data: null, success: false };
            }
          }

          async function joinMediasfu(mediasfulink) {
            if (
              mediasfulink == null ||
              mediasfulink == undefined ||
              mediasfulink == "" ||
              mediasfulink.length < 10
            ) {
              return;
            }

            let link;
            let secretCode;
            try {
              const splitTexts = ["/meet/", "/chat/", "/broadcast/"];

              // check the one that is present in the link
              let splitText = splitTexts.find((text) =>
                mediasfulink.includes(text)
              );
              if (!splitText) {
                splitText = "/meet/";
              }

              let urlParts = mediasfulink.split(splitText);
              link = urlParts[0];
              secretCode = urlParts[1].split("/")[1];
            } catch (error) {
              link = url;
              return;
            }

            let mediasfuSocket = await io(`${link}/media`, {
              transports: ["websocket"],
              query: `apiUserName=${roomName}&apiToken=${secretCode}`,
            });

            // Handle socket connection events
            await mediasfuSocket.on(
              "connection-success",
              async ({ socketId }) => {
                await mediasfuSocket.emit(
                  "joinRoom",
                  {
                    roomName,
                    islevel,
                    member,
                    sec: secretCode,
                    apiUserName: roomName,
                  },
                  async (data) => {
                    try {
                      // Check if rtpCapabilities is null
                      if (data.rtpCapabilities === null) {
                      } else {
                        await getRecordParams(data.recordingParams);
                        p_sockets = await [mediasfuSocket];
                        await addListeners(p_sockets[0]);
                      }
                    } catch (error) {
                      // Handle errors during the joinRoom process
                      console.error("Error joining room:", error);
                    }
                  }
                );
              }
            );
          }

          // define startRecording function
          async function startRecording() {
            //attempt to start recording and return true if successful
            let recAttempt;

            let action = "startRecord";
            if (
              recordStarted &&
              recordPaused &&
              !recordResumed &&
              !recordStopped
            ) {
              action = "resumeRecord";
            } else {
              action = "startRecord";
            }

            if (!recordingVideoSupport && !recordingAudioSupport) {
              showAlert("Recording is not supported for this event", "danger");
              return false;
            }

            await new Promise((resolve) => {
              p_sockets[0].emit(
                action,
                { roomName, userRecordingParams },
                async ({ success, reason, recordState }) => {
                  if (success) {
                    recordStarted = true;
                    startReport = true;
                    endReport = false;
                    recordPaused = false;
                    recAttempt = true;

                    if (action == "startRecord") {
                      await rePort();
                    } else {
                      recordResumed = true;
                      await rePort(true);
                    }
                  } else {
                    showAlert(reason, "danger");
                    canRecord = true;
                    startReport = false;
                    endReport = true;
                    recAttempt = false;
                  }

                  try {
                    if (recAttempt && whiteboardStarted && !whiteboardEnded) {
                      if (recordingMediaOptions == "video") {
                        captureCanvasStream();
                      }
                    }
                  } catch (error) {}

                  resolve();
                }
              );
            });

            return recAttempt;
          }

          async function pauseRecording() {
            //attempt to pause recording and return true if successful
            let action = "pauseRecord";

            let recAttempt;

            await new Promise((resolve) => {
              p_sockets[0].emit(
                "pauseRecord",
                { roomName },
                ({ success, reason, recordState, pauseCount }) => {
                  pauseRecordCount = pauseCount;

                  if (success) {
                    startReport = false;
                    endReport = true;
                    recordPaused = true;

                    showAlert("Recording Paused", "success");

                    recAttempt = true;
                  } else {
                    let reasonMessage = `Recording Pause Failed: ${reason}; the recording is currently ${recordState}`;
                    showAlert(reasonMessage, "danger");
                    recAttempt = false;
                  }

                  resolve();
                }
              );
            });

            return recAttempt;
          }

          // define stopRecording function
          async function stopRecording() {
            //attempt to stop recording and return true if successful
            let action = "stopRecord";

            let recAttempt;

            await new Promise((resolve) => {
              p_sockets[0].emit(
                "stopRecord",
                { roomName },
                ({ success, reason, recordState }) => {
                  if (success) {
                    startReport = false;
                    endReport = true;
                    recordPaused = false;
                    recordStopped = true;
                    recAttempt = true;

                    showAlert("Recording Stopped", "success");
                  } else {
                    let reasonMessage = `Recording Stop Failed: ${reason}; the recording is currently ${recordState}`;
                    showAlert(reasonMessage, "danger");
                    recAttempt = false;
                  }

                  resolve();
                }
              );
            });

            try {
              if (recAttempt && whiteboardStarted && !whiteboardEnded) {
                if (recordingMediaOptions == "video") {
                  captureCanvasStream(false);
                }
              }
            } catch (error) {}

            return recAttempt;
          }

          //add request screen share from socket
          async function requestScreenShare() {
            // send request to socket to request screen share
            await socket.emit(
              "requestScreenShare",
              async ({ allowScreenShare }) => {
                shareScreen = await allowScreenShare;

                if (!allowScreenShare) {
                  // send an alert to the user
                  showAlert(
                    "Screen share can only be be done by one person at a time",
                    "alert-danger"
                  );
                } else {
                  let targetWidth = 1280;
                  let targetHeight = 720;

                  if (
                    targetResolution == "qhd" ||
                    eventRoomParams.targetResolutionHost == "qhd"
                  ) {
                    targetWidth = 2560;
                    targetHeight = 1440;
                  } else if (
                    targetResolution == "fhd" ||
                    eventRoomParams.targetResolutionHost == "fhd"
                  ) {
                    targetWidth = 1920;
                    targetHeight = 1080;
                  }

                  startShareScreen(targetWidth, targetHeight);
                }
              }
            );
          }

          async function startShareScreen(width = 1280, height = 720) {
            // start screen share function
            //attempt to start screen share and return true if successful
            if (
              navigator.mediaDevices &&
              navigator.mediaDevices.getDisplayMedia
            ) {
              shared = true;
              await navigator.mediaDevices
                .getDisplayMedia({
                  video: {
                    cursor: "always",
                    width: width,
                    height: height,
                    frameRate: 30,
                  },
                  audio: false,
                })
                .then(streamSuccessScreen)
                .catch((err) => {
                  shared = false;
                  //check if they are using safari and recommend using chrome or another browser
                  if (
                    navigator.userAgent.indexOf("Safari") != -1 &&
                    navigator.userAgent.indexOf("Chrome") == -1
                  ) {
                    showAlert(
                      "Could not share screen, make sure you are on a computer and try using Chrome or another browser",
                      "alert-danger"
                    );
                  } else {
                    showAlert(
                      "Could not share screen, make sure you are on a computer",
                      "alert-danger"
                    );
                  }
                });
            } else {
              if (
                navigator.userAgent.indexOf("Safari") != -1 &&
                navigator.userAgent.indexOf("Chrome") == -1
              ) {
                showAlert(
                  "Could not share screen, make sure you are on a computer and try using Chrome or another browser",
                  "alert-danger"
                );
              } else {
                showAlert(
                  "Could not share screen, make sure you are on a computer",
                  "alert-danger"
                );
              }
            }
          }

          //stop screen share
          async function stopShareScreen() {
            // stop screen share function
            //attempt to stop screen share and return true if successful
            shared = false;
            shareScreenStarted = false;
            shareScreen = false;
            shareEnded = true;
            updateMainWindow = true;

            if (defer_receive) {
              defer_receive = false;
              await getVideos();
            }

            $("#screenshareState").html(
              '<button style="background-color: transparent;border: 0; font-size: medium;position: relative;" id="screenshareState"> <span class="fa-stack fa-md border-0" ><i class="fas fa-desktop fa-stack-1x border-0"></i><i class="fas fa-ban fa-stack-2x border-0" style="color:Tomato"></i></span> </button>'
            );
            localStreamScreen.getTracks().forEach((track) => track.stop());
            await disconnectSendTransportScreen();
            if (p_sockets.length > 0) {
              try {
                await disconnectSendTransportScreen(true);
              } catch (error) {}
            }

            try {
              if (annotateScreenStream) {
                annotateScreenStream = false;
                await $("#screenAnnotateModal").modal("show");
                await sleep(500);
                await $("#screenAnnotateModal").modal("hide");
              }
            } catch (error) {}

            if (eventType == "conference") {
              await moveBoard();
              await $(".maingrid").remove();
              //add timer
              await addTimer();
              let height95 = window.innerHeight * 0.95;
              $(".othergrid").css("height", height95 + "px");
            }

            try {
              await prepopulateUserMedia(hostLabel);
            } catch (error) {}

            try {
              await reorderStreams(false, true);
            } catch (error) {}

            lock_screen = false;
            forceFullDisplay = prevForceFullDisplay;
            firstAll = false;
            first_round = false;
          }

          async function addReactions() {
            // Create a modal element for broadcasting and chat to message participants
            const modalHtml = `
  <div class="modal fade" id="reactionModal" tabindex="-1" role="dialog" aria-labelledby="reactionModalLabel" aria-hidden="true">
      <div class="modal-dialog modal-dialog-centered" >
          <div class="modal-content" style="background-color: rgba(255, 255, 255, 0.35);max-height: 400px; overflow-y: auto;position: absolute;min-width:300px;top: -1px;right: -1px;">
              <div class="modal-body text-center" id="reactChatPanel">
              </div>
          </div>
      </div>
  </div>
  `;

            // Convert the HTML string into a DOM element
            const modalFragment = document
              .createRange()
              .createContextualFragment(modalHtml);

            // Append the modal element to the body
            document.body.appendChild(modalFragment);
          }

          async function addParticipants() {
            // Create a modal element for broadcasting and chat to show participants
            const modalHtml = `
  <div class="modal fade" id="reactParticipantsModal" tabindex="-1" role="dialog" aria-labelledby="reactParticipantsModalLabel" aria-hidden="true">
      <div class="modal-dialog modal-dialog-centered" >
          <div class="modal-content" style="background-color: rgba(255, 255, 255, 0.35);max-height: 400px; overflow-y: auto;position: absolute;min-width:300px;top: -1px;right: -1px;">
          <div class="modal-body text-center" id="reactParticipants">
            <div class="form-group">
            <input type="text" class="form-control" id="react-participant-filter" placeholder="Search ...">
            </div>
            <div id="react-participant-list">
              <!-- Participant rows will be dynamically added here -->
            </div>
          </div>
          </div>
      </div>
  </div>
  `;
            // Convert the HTML string into a DOM element
            const modalFragment = document
              .createRange()
              .createContextualFragment(modalHtml);

            // Append the modal element to the body
            document.body.appendChild(modalFragment);
          }

          async function addShareEvent() {
            // function to show share event modal
            //valid if on broadcast or chat

            let formatName = "Broadcast";
            if (eventType == "chat") {
              formatName = "Chat";
            }

            let checkislevel = islevel == "2" ? true : false;
            // Create a modal element for broadcasting and chat to share event via links
            const modalHtml = `
  <div class="modal fade" id="shareEventModal" tabindex="-1" role="dialog" aria-labelledby="shareEventModalLabel" aria-hidden="true">
      <div class="modal-dialog modal-dialog-centered" >
          <div class="modal-content" style="background-color: rgba(255, 255, 255, 0.35);max-height: 400px; overflow-y: auto;position: absolute;min-width:300px;top: -1px;right: -1px;">
          <div class="modal-body text-center" id="shareEvent">
            <div class="form-group">
            <label for="broadcastIdCopy2">${formatName} ID:</label>
            <div class="input-group">
              <input type="text" class="form-control" id="broadcastIdCopy2" value="" readonly>
              <div class="input-group-append">
                <button class="btn btn-secondary" type="button" id="copyBroadcastIdButton2" data-toggle="tooltip" data-placement="bottom" title="Copy ${formatName} ID to clipboard"><i class="fas fa-copy"></i></button>
              </div>
            </div>
          </div>
  
          ${
            checkislevel
              ? `
            <div class="form-group">
              <label for="broadcastPasscodeCopy2">${formatName} Passcode (Host):</label>
              <div class="input-group">
                <input type="text" class="form-control" id="broadcastPasscodeCopy2" value="" readonly>
                <div class="input-group-append">
                  <button style="background-color: rgba(255, 255, 255, 0.25)" class="btn btn-secondary" type="button" id="copyBroadcastPasscodeButton2" data-toggle="tooltip" data-placement="bottom" title="Copy ${formatName} Passcode (Host) to clipboard"><i class="fas fa-copy"></i></button>
                </div>
              </div>
            </div>
            <br>
          `
              : ""
          }        
  
          <br>
  
          <div class="input-group mb-3">
          <input type="text" id="shareLinkBroadcast2" class="form-control" readonly>
          <div class="input-group-append">
            <button style="background-color: rgba(255, 255, 255, 0.25)" class="btn btn-outline-secondary" type="button" id="copyShareLinkBroadcastButton2" data-toggle="tooltip" data-placement="top" title="Copy Link"><i class="far fa-copy"></i></button>
            <button style="background-color: rgba(255, 255, 255, 0.25)" class="btn btn-outline-secondary" type="button" id="shareWhatsappBroadcastButton2"><i class="fab fa-whatsapp"></i></button>
            <button style="background-color: rgba(255, 255, 255, 0.25)" class="btn btn-outline-secondary" type="button" id="shareFacebookBroadcastButton2"><i class="fab fa-facebook"></i></button>
            <button style="background-color: rgba(255, 255, 255, 0.25)" class="btn btn-outline-secondary" type="button" id="shareEmailBroadcastButton2"><i class="far fa-envelope"></i></button>
          </div>
        </div>
  
      </div>  
   </div>
  </div>
  `;

            // Convert the HTML string into a DOM element
            const modalFragment = document
              .createRange()
              .createContextualFragment(modalHtml);

            // Append the modal element to the body
            document.body.appendChild(modalFragment);
          }

          async function addRecordingModal() {
            //remove the default modal and add a new one for recording broadcast
            //find recording modal and empty the contents
            $("#recordingModal").empty();

            const modalHtml = `
                <div class="modal-dialog modal-dialog-centered" >
                        <div class="modal-content" style="background-color: rgba(255, 255, 255, 0.35);max-height: 400px; overflow-y: auto;position: absolute;min-width:300px;top: -1px;right: -1px;">
                          <div class="modal-body text-center" id="reactParticipants">
                            <div id="standardReactPanel">
                              
                            </div>
  
                            <div class="row">
                              <div class="col-6">
                                <button type="button" class="btn btn-primary btn-block" id="confirmRecButton">Confirm</button>
                              </div>
                              <div class="col-6">
                                <button type="button" class="btn btn-success btn-block" id="startRecButton">Start</button>
                              </div>
                          </div>
                          </div>
                        </div>
                      </div>
                  </div>
              `;

            // Convert the HTML string into a DOM element
            const modalFragment = document
              .createRange()
              .createContextualFragment(modalHtml);

            // add it to the recording modal
            $("#recordingModal").append(modalFragment);
          }

          //add floating buttons for chat/broadcasts
          async function addFloatingMediaButtons(forBasic = true) {
            // add floating buttons for chat/broadcasts; replaces the default buttons in the menu modal
            //forBasic = true for broadcast and false for chat
            if (!buttonsAddedForChat) {
              if (islevel == "2" && forBasic) {
                hostLabel = "You (Host)";
              } else if (!forBasic) {
                hostLabel = "You";
              }

              addReactions();
              addShareEvent();

              if (islevel == "2" && forBasic) {
                addParticipants();
                addRecordingModal();
              }

              if (forBasic) {
                //key positionings for buttons on the screen for broadcast
                const buttonedEnd = document.createElement("button");
                buttonedEnd.style.cssText =
                  "background-color: rgba(255, 255, 255, 0.25); border: 0; font-size: medium; position: absolute; bottom: 5px; right: -2px;";
                buttonedEnd.id = "hangState";
                buttonedEnd.innerHTML =
                  '<i class="fas fa-phone-slash fa-lg border-0"></i>';

                // Add a click event listener to the hangState button
                buttonedEnd.addEventListener("click", async () => {
                  await socket.emit("disconnectUser", {
                    member: member,
                    roomName: roomName,
                    ban: false,
                  });
                });

                let buttonedViewerCount = `<button  style="background-color: rgba(255, 255, 255, 0.25);border: 0; font-size: medium; position: absolute; bottom: 55px; right: -2px;" id="reactParticipant-counter"> 1 <i class="fas fa-chart-bar fa-rotate-270 fa-lg"></i> </button>`;

                const buttonedReact = document.createElement("button");
                buttonedReact.style.cssText =
                  "background-color: rgba(255, 255, 255, 0.25); border: 0; font-size: medium; position: absolute; bottom: 105px; right: -2px;";
                buttonedReact.id = "reactState";
                buttonedReact.innerHTML =
                  '<i class="fas fa-comments fa-lg border-0"></i>';

                // Add a click event listener to the messageState button
                buttonedReact.addEventListener("click", async () => {
                  if (isReactionModalShown) {
                    $("#reactionModal").modal("hide");
                    isReactionModalShown = false;
                  } else {
                    $("#reactionModal").modal("show");
                    isReactionModalShown = true;
                  }
                });

                const buttonedShare = document.createElement("button");
                buttonedShare.style.cssText =
                  "background-color: rgba(255, 255, 255, 0.25); border: 0; font-size: medium; position: absolute; bottom: 155px; right: -2px;";
                buttonedShare.id = "shareState";
                buttonedShare.innerHTML =
                  '<i class="fas fa-share-alt fa-lg border-0"></i>';

                // Add a click event listener to the shareState button
                buttonedShare.addEventListener("click", async () => {
                  if (isShareEventModalShown) {
                    $("#shareEventModal").modal("hide");
                    isShareEventModalShown = false;
                  } else {
                    $("#shareEventModal").modal("show");
                    isShareEventModalShown = true;
                  }
                });

                $("body").append(buttonedEnd);
                $("body").append(buttonedReact);
                $("body").append(buttonedViewerCount);
                $("body").append(buttonedShare);
              } else {
                // key positionings for buttons on the screen for chat
                const buttonedReact = document.createElement("button");
                buttonedReact.style.cssText =
                  "background-color: rgba(255, 255, 255, 0.25); border: 0; font-size: medium; position: absolute; bottom: 205px; right: -2px;";
                buttonedReact.id = "reactState";
                buttonedReact.innerHTML =
                  '<i class="fas fa-comments fa-lg border-0"></i>';

                // Add a click event listener to the messageState button
                buttonedReact.addEventListener("click", async () => {
                  if (isReactionModalShown) {
                    $("#reactionModal").modal("hide");
                    isReactionModalShown = false;
                  } else {
                    $("#reactionModal").modal("show");
                    isReactionModalShown = true;
                  }
                });

                const buttonedShare = document.createElement("button");
                buttonedShare.style.cssText =
                  "background-color: rgba(255, 255, 255, 0.25); border: 0; font-size: medium; position: absolute; bottom: 255px; right: -2px;";
                buttonedShare.id = "shareState";
                buttonedShare.innerHTML =
                  '<i class="fas fa-share-alt fa-lg border-0"></i>';

                // Add a click event listener to the shareState button
                buttonedShare.addEventListener("click", async () => {
                  if (isShareEventModalShown) {
                    $("#shareEventModal").modal("hide");
                    isShareEventModalShown = false;
                  } else {
                    $("#shareEventModal").modal("show");
                    isShareEventModalShown = true;
                  }
                });

                const buttonedEnd = document.createElement("button");
                buttonedEnd.style.cssText =
                  "background-color: rgba(255, 255, 255, 0.25); border: 0; font-size: medium; position: absolute; bottom: 5px; right: -2px;";
                buttonedEnd.id = "hangState";
                buttonedEnd.innerHTML =
                  '<i class="fas fa-phone-slash fa-lg border-0"></i>';

                // Add a click event listener to the hangState button
                buttonedEnd.addEventListener("click", async () => {
                  await socket.emit("disconnectUser", {
                    member: member,
                    roomName: roomName,
                    ban: false,
                  });
                });

                $("body").append(buttonedEnd);
                $("body").append(buttonedReact);
                $("body").append(buttonedShare);
              }

              if (islevel == "2" || !forBasic) {
                // host screen, add the buttons for host for host to record broadcast
                //show participants/viewers

                let buttonedMic;
                let buttonedVideo;
                let buttonedSwitchCamera;

                if (!forBasic) {
                  buttonedMic = `<button  style="background-color: rgba(255, 255, 255, 0.25);border: 0; font-size: medium; position: absolute; bottom: 55px; right: -2px;" class="micStated"> <i class="fas fa-microphone-slash fa-lg border-0" > </i>  </button>`;
                  buttonedVideo = `<button  style="background-color: rgba(255, 255, 255, 0.25);border: 0; font-size: medium; position: absolute; bottom: 105px; right: -4px;"  class="videoStated"> <i class="fas fa-video-slash fa-lg border-0" > </i>  </button>`;
                  buttonedSwitchCamera = `<button  style="background-color: rgba(255, 255, 255, 0.25);border: 0; font-size: medium; position: absolute; bottom: 155px; right: -2px;" class="switchCamera"> <i class="fas fa-sync fa-lg border-0"> </i>  </button>`;
                } else {
                  buttonedMic = `<button  style="background-color: rgba(255, 255, 255, 0.25);border: 0; font-size: medium; position: absolute; bottom: 205px; right: -2px;" class="micStated"> <i class="fas fa-microphone-slash fa-lg border-0" > </i>  </button>`;
                  buttonedVideo = `<button  style="background-color: rgba(255, 255, 255, 0.25);border: 0; font-size: medium; position: absolute; bottom: 255px; right: -4px;"  class="videoStated"> <i class="fas fa-video-slash fa-lg border-0" > </i>  </button>`;
                  buttonedSwitchCamera = `<button  style="background-color: rgba(255, 255, 255, 0.25);border: 0; font-size: medium; position: absolute; bottom: 305px; right: -2px;" class="switchCamera"> <i class="fas fa-sync fa-lg border-0"> </i>  </button>`;
                }

                let buttonedParticipants = document.createElement("button");
                buttonedParticipants.style.cssText =
                  "background-color: rgba(255, 255, 255, 0.25); border: 0; font-size: medium; position: absolute; bottom: 355px; right: -2px;";
                buttonedParticipants.id = "participantsState";
                buttonedParticipants.innerHTML =
                  '<i class="fas fa-users fa-lg border-0"></i>';

                buttonedParticipants.addEventListener("click", async () => {
                  if (isReactionParticipantModalShown) {
                    $("#reactParticipantsModal").modal("hide");
                    isReactionParticipantModalShown = false;
                  } else {
                    $("#reactParticipantsModal").modal("show");
                    isReactionParticipantModalShown = true;
                  }
                });

                let buttonedRecord = `<button  style="background-color: rgba(255, 255, 255, 0.25);border: 0; font-size: large; position: absolute; left: 50%; transform: translateX(-50%); bottom: 5px;" class="recordStated">  <i class="fas fa-record-vinyl fa-lg"></i> Record </button>`;

                $("body").append(buttonedMic);
                $("body").append(buttonedVideo);
                $("body").append(buttonedSwitchCamera);

                if (forBasic) {
                  $("body").append(buttonedParticipants);
                  $("body").append(buttonedRecord);
                }

                // recording controls
                loadVidAud();
              }

              //change the display details of the share event modal
              if (forBasic) {
                loadBroadcastModal("broadcast", "Broadcast");
              } else {
                loadBroadcastModal("chat", "Chat");
              }

              buttonsAddedForChat = true;
            }

            // //set to windowWidth and windowHeight
            let windowHeight = $(window).height();
            if (isBrowserBarHidden()) {
              windowHeight = $(document).height();

              $("#mainAspect").css("height", `${windowHeight}px`);
            } else {
              $("#mainAspect").css("height", `${windowHeight}px`);
            }
            $("#mainAspect").css("width", `${window.innerWidth}px`);

            // style="overflow: -moz-hidden-unscrollable; display:hidden;"
            $("#mainAspect").css("overflow", "hidden");
            $("#mainAspect").css("margin", "0px");
            $("#mainAspect").css("padding", "0px");

            $(".maingrid").css("padding", 0);
            $(".maingrid").css("margin", 0);

            document.documentElement.style.overflowY = "hidden";
            document.documentElement.style.overflowX = "hidden";
            document.documentElement.style.margin = "0px";
            document.documentElement.style.padding = "0px";
          }

          //continue with media stuff
          const streamSuccessAudio = async (stream) => {
            localStreamAudio = await stream;
            //add the audio stream track to the localStream
            //if there localStream is null then add the audio stream to the localStream else add the audio stream track to the localStream
            if (localStream == null) {
              localStream = await new MediaStream([
                localStreamAudio.getAudioTracks()[0],
              ]);
            } else {
              localStream.addTrack(localStreamAudio.getAudioTracks()[0]);
            }

            const audioTracked = await localStream.getAudioTracks()[0];
            defAudioID = await audioTracked.getSettings().deviceId;
            userDefaultAudioInputDevice = await defAudioID;

            params = a_params;
            audioParamse = { ...params };

            audioParams = await {
              track: localStream.getAudioTracks()[0],
              ...audioParamse,
            };

            //create transport if not created else connect transport
            if (!transportCreated) {
              await createSendTransport("audio");
              if (p_sockets.length > 0) {
                try {
                  await createSendTransportMediaSFU("audio");
                } catch (error) {}
              }
            } else {
              if (!transportCreatedAudio) {
                await connectSendTransportAudio(audioParams);
                if (p_sockets.length > 0) {
                  try {
                    await connectSendTransportAudio(audioParams, true);
                  } catch (error) {}
                }
              } else {
                await resumeSendTransportAudio();
                if (p_sockets.length > 0) {
                  try {
                    await resumeSendTransportAudio(true);
                  } catch (error) {}
                }
              }
            }

            //update mic icon
            $(".micStated").html(
              '<button style="background-color: transparent;border: 0; font-size: medium;" id="micState" class="micStated"> <i class="fas fa-microphone fa-lg border-0"  > </i>  </button>'
            );

            //update the participants array to reflect the change
            audioAlreadyOn = true;

            if (micAction == true) {
              micAction = false;
            }

            //update the participants array to reflect the change
            await participants.forEach((participant) => {
              if (
                participant.socketId == socket.id &&
                participant.name == member
              ) {
                participant.muted = false;
              }
            });

            //update the transport created state
            transportCreated = true;
            transportCreatedAudio = true;

            //reupdate screen display if host
            if (videoAlreadyOn == false && islevel == "2") {
              if (!lock_screen && !shared) {
                updateMainWindow = true;
                await prepopulateUserMedia(hostLabel);
                updateMainWindow = false;
              }
            }
          };

          const streamSuccessNull = async () => {
            //join room with no media
            await joinRoom();
            await addNonProducer();
          };

          const addNonProducer = async () => {
            //join the room as a non producer (no media)
            await socket.emit("addNonProducer", { roomName });
          };

          const streamSuccessScreen = async (stream) => {
            // share screen on success
            localStreamScreen = await stream;

            //create transport if not created else connect transport
            if (!transportCreated) {
              await createSendTransport("screen");
              if (p_sockets.length > 0) {
                try {
                  await createSendTransportMediaSFU("screen");
                } catch (error) {}
              }
            } else {
              await connectSendTransportScreen(localStreamScreen);
              if (p_sockets.length > 0) {
                try {
                  await connectSendTransportScreen(localStreamScreen, true);
                } catch (error) {}
              }
            }

            //alert the socket that you are sharing screen
            await socket.emit("startScreenShare");

            //change the screen icon
            await $("#screenshareState").html(
              '<button style="background-color: transparent;border: 0; font-size: medium;" id="screenshareState"> <i class="fas fa-desktop fa-lg border-0"  > </i>  </button>'
            );

            //reupdate the screen display
            try {
              await prepopulateUserMedia(hostLabel);
            } catch (error) {}

            //reorder streams if required

            try {
              if (eventType == "conference") {
                await reorderStreams(false, true);
                await prepopulateUserMedia(hostLabel);
              } else {
                await reorderStreams();
              }
            } catch (error) {
              try {
                await rePort();
              } catch (error) {}
            }

            //handle screen share end
            localStreamScreen.getVideoTracks()[0].onended = async function () {
              //supports both manual and automatic screen share end
              await disconnectSendTransportScreen();
              if (p_sockets.length > 0) {
                try {
                  await disconnectSendTransportScreen(true);
                } catch (error) {}
              }
              await stopShareScreen();
            };

            //update the participants array to reflect the change
            screenAlreadyOn = true;

            //if user requested to share screen, update the screenAction state
            if (screenAction == true) {
              screenAction = false;
            }

            //update the transport created state
            transportCreatedScreen = true;

            try {
              if (annotateScreenStream) {
                await $("#screenAnnotateModal").modal("show");
                await sleep(500);
                await $("#screenAnnotateModal").modal("hide");
              }
            } catch (error) {}
          };

          const streamSuccessVideo = async (stream) => {
            localStreamVideo = await stream;
            //add the video stream track to localStream

            if (localStream == null) {
              localStream = await new MediaStream([
                localStreamVideo.getVideoTracks()[0],
              ]);
            } else {
              // remove all video tracks that are currently in the localStream
              await localStream.getVideoTracks().forEach((track) => {
                localStream.removeTrack(track);
              });
              // add the new video track to the localStream
              await localStream.addTrack(localStreamVideo.getVideoTracks()[0]);
            }

            //get the video track settings
            const videoTracked = await localStream.getVideoTracks()[0];
            defVideoID = await videoTracked.getSettings().deviceId;
            userDefaultVideoInputDevice = await defVideoID;
            currentFacingMode = await videoTracked.getSettings().facingMode;

            allowed = true;

            //apply the video constraints
            if (islevel == "2") {
              if (!shared || !shareScreenStarted) {
                params = await h_params;
                videoParamse = await { ...params };
              } else {
                params = await v_params;
                videoParamse = await { ...params };
              }
            } else {
              params = await v_params;
              videoParamse = await { ...params };
            }

            //remove vp9 codec from the video codecs; support only vp8 and h264
            let codecs = device.rtpCapabilities.codecs.filter(
              (codec) =>
                codec.mimeType.toLowerCase() !== "video/vp9" &&
                codec.kind === "video"
            );
            let codec = codecs[0];

            //create transport if not created else connect transport
            videoParams = await {
              track: localStream.getVideoTracks()[0],
              ...videoParamse,
              codec,
            };

            if (keepBackground && appliedBackground) {
              videoAlreadyOn = true;
              $("#changeBackground").trigger("click");
              await $("#applyBackgroundButton").prop("disabled", false);
              $("#applyBackgroundButton").trigger("click");
              await sleep(250);
              await $("#saveBackgroundButton").prop("disabled", false);
              $("#saveBackgroundButton").trigger("click");
              await sleep(500);
              $("#backgroundRemovalModal").modal("hide");
            } else {
              if (!transportCreated) {
                await createSendTransport("video");
                if (p_sockets.length > 0) {
                  try {
                    await createSendTransportMediaSFU("video");
                  } catch (error) {}
                }
              } else {
                await connectSendTransportVideo(videoParams);
                if (p_sockets.length > 0) {
                  try {
                    await connectSendTransportVideo(videoParams, true);
                  } catch (error) {}
                }
              }
            }

            //change the video icon
            $(".videoStated").html(
              '<button style="background-color: transparent;border: 0; font-size: medium;" id="videoState" class="videoStated"> <i class="fas fa-video fa-lg border-0"  > </i>  </button>'
            );

            //update the participants array to reflect the change
            videoAlreadyOn = true;

            //if user requested to share video, update the videoAction state
            if (videoAction == true) {
              videoAction = false;
            }

            // update the display screen if host
            if (islevel == "2") {
              updateMainWindow = true;
            }

            //update the participants array to reflect the change
            await participants.forEach((participant) => {
              if (
                participant.socketId == socket.id &&
                participant.name == member
              ) {
                participant.videoOn = true;
              }
            });

            //update the transport created state
            transportCreatedVideo = true;

            //reupdate the screen display
            if (lock_screen) {
              try {
                await reorderStreams(true, true);
              } catch (error) {}
            } else {
              try {
                await reorderStreams(false, true);
              } catch (error) {}
            }
          };

          async function moveBoard() {
            try {
              // Get the whiteboard element
              let whiteboard = await document.getElementById(
                "whiteboard-interface"
              );

              // Temporarily move the whiteboard to the body and hide it
              await document.body.appendChild(whiteboard);
              whiteboard.style.display = "none";
            } catch (error) {}

            try {
              // Get the screenboard element
              let screenboard = await document.getElementById(
                "screenboard-interface"
              );

              // Temporarily move the screenboard to the body and hide it
              await document.body.appendChild(screenboard);
              screenboard.style.display = "none";
            } catch (error) {}
          }

          async function prepopulateUserMedia(name) {
            if (eventType == "chat") {
              return;
            }

            //find the participants array with islevel == '2' (host)
            let host = null;
            let hostStream;

            if (shareScreenStarted == true || shared == true) {
              //screen share started
              // add/remove main grid if conference or not
              if (eventType == "conference") {
                let maingrid = $(".maingrid");

                if (shared || shareScreenStarted) {
                  if (maingrid.length == 0) {
                    //add maingrid
                    await addMainGrid();
                  }
                } else {
                  await moveBoard();
                  await $(".maingrid").remove();
                  //add timer
                  await addTimer();
                }
              }

              //switch display to optimize for screen share

              prevForceFullDisplay = forceFullDisplay;
              screenForceFullDisplay = forceFullDisplay;

              let orientation = checkOrientation();
              if (
                orientation === "portrait" ||
                window.matchMedia("(max-width: 768px)").matches
              ) {
                if (shareScreenStarted || shared) {
                  screenForceFullDisplay = false;
                }
              }

              if (shared) {
                // you are sharing
                host = { name: member };
                hostStream = await localStreamScreen;
                if (islevel == "2") {
                  adminOnMainScreen = true;
                } else {
                  adminOnMainScreen = false;
                }

                mainScreenPerson = host.name;
              } else {
                //someone else is sharing
                host = await participants.find(
                  (participant) =>
                    participant.ScreenID == screenId &&
                    participant.ScreenOn == true
                );

                if (whiteboardStarted && !whiteboardEnded) {
                  host = { name: "WhiteboardActive", islevel: "2" };
                  hostStream = { producerId: "WhiteboardActive" };
                }

                if (host == null) {
                  // remoteScreenStream
                  host = await participants.find(
                    (participant) => participant.ScreenOn == true
                  );
                }

                // check remoteScreenStream
                if (host != null && !host.name.includes("WhiteboardActive")) {
                  if (remoteScreenStream.length == 0) {
                    hostStream = await allVideoStreams.find(
                      (stream) => stream.producerId == host.ScreenID
                    );
                  } else {
                    hostStream = await remoteScreenStream[0];
                  }
                }

                if (host.islevel == "2") {
                  adminOnMainScreen = true;
                } else {
                  adminOnMainScreen = false;
                }
                mainScreenPerson = host.name;
              }
            } else {
              //screen share not started
              if (eventType == "conference") {
                // no main grid
                return;
              }

              host = await participants.find(
                (participant) => participant.islevel == "2"
              );

              if (host != null) {
                mainScreenPerson = host.name;
              }
            }

            //if host is not null, check if host videoIsOn
            if (host != null) {
              //populate the main screen with the host video
              if (shareScreenStarted == true || shared == true) {
                try {
                  forceFullDisplay = screenForceFullDisplay;
                  if (whiteboardStarted && !whiteboardEnded) {
                    await addMainBoard();
                  } else {
                    await addMainVideo(
                      host,
                      (diffStream = true),
                      (streamName = hostStream)
                    );
                  }
                  forceFullDisplay = prevForceFullDisplay;
                  mainScreenFilled = true;
                  if (host.islevel == "2") {
                    adminOnMainScreen = true;
                  } else {
                    adminOnMainScreen = false;
                  }
                  mainScreenPerson = host.name;
                } catch (error) {}
                return;
              }

              if (
                (islevel != "2" && !host.videoOn) ||
                (islevel == "2" && (!host.videoOn || !videoAlreadyOn))
              ) {
                if (islevel == "2" && videoAlreadyOn) {
                  try {
                    await addMainVideo(host);
                    mainScreenFilled = true;
                    if (host.islevel == "2") {
                      adminOnMainScreen = true;
                    } else {
                      adminOnMainScreen = false;
                    }
                    mainScreenPerson = host.name;
                  } catch (error) {}
                } else {
                  let audOn = false;
                  if (islevel == "2" && audioAlreadyOn) {
                    audOn = true;
                  } else {
                    if (host != null && islevel != "2") {
                      audOn = host.muted == false;
                    }
                  }

                  try {
                    if (audOn) {
                      try {
                        await addBlankMainVideo(host.name, false, audOn);
                      } catch (error) {}

                      mainScreenFilled = true;
                      if (host.islevel == "2") {
                        adminOnMainScreen = true;
                      } else {
                        adminOnMainScreen = false;
                      }
                      mainScreenPerson = host.name;
                    } else {
                      try {
                        await addBlankMainVideo(name, false, audOn);
                      } catch (error) {}

                      mainScreenFilled = false;
                      if (host.islevel == "2") {
                        adminOnMainScreen = true;
                      } else {
                        adminOnMainScreen = false;
                      }
                      mainScreenPerson = host.name;
                    }
                  } catch (error) {}
                }
              } else {
                if (shareScreenStarted == true || shared == true) {
                  try {
                    if (whiteboardStarted && !whiteboardEnded) {
                      await addMainBoard();
                    } else {
                      await addMainVideo(
                        host,
                        (diffStream = true),
                        (streamName = hostStream)
                      );
                    }

                    mainScreenFilled = true;
                    if (host.islevel == "2") {
                      adminOnMainScreen = true;
                    } else {
                      adminOnMainScreen = false;
                    }
                    mainScreenPerson = host.name;
                  } catch (error) {}
                } else {
                  try {
                    await addMainVideo(host);
                    mainScreenFilled = true;
                    if (host.islevel == "2") {
                      adminOnMainScreen = true;
                    } else {
                      adminOnMainScreen = false;
                    }
                    mainScreenPerson = host.name;
                  } catch (error) {}
                }
              }
            } else {
              try {
                await addBlankMainVideo(name);
                mainScreenFilled = false;
                adminOnMainScreen = false;
                mainScreenPerson = null;
              } catch (error) {}
            }

            updateMainWindow = false;
          }

          async function addBlankMainVideo(
            name,
            doUpper = true,
            addwav = false
          ) {
            //add a blank main video (main screen)

            try {
              // Get the whiteboard element
              let whiteboard = await document.getElementById(
                "whiteboard-interface"
              );

              // Temporarily move the whiteboard to the body and hide it
              await document.body.appendChild(whiteboard);
              whiteboard.style.display = "none";
            } catch (error) {}

            try {
              // Get the screenboard element
              let screenboard = await document.getElementById(
                "screenboard-interface"
              );

              // Temporarily move the screenboard to the body and hide it
              await document.body.appendChild(screenboard);
              screenboard.style.display = "none";
            } catch (error) {}

            const allMiniGrid1 = await document.querySelectorAll(".maingrids");
            allMiniGrid1.forEach((grid) => {
              grid.remove();
            });

            //remove all children of all .maingrid-container and empty the containers
            await $(".maingrid-container").empty();

            //create a new maingrid div
            let maingrids = await $(
              '<div class="maingrids" style="display: grid; grid-gap: 0px; justify-content: center;width: 100%;margin: 0%;padding: 0%;margin-top:0px;padding-top:0px"></div>'
            );
            await $(".maingrid-container").append(maingrids);

            let initials = name;

            if (doUpper) {
              initials = name.toUpperCase();
            }

            let miniCard;
            if (!addwav) {
              miniCard = $('<div class="mini-carded first"></div>');
              miniCard.attr("data-initials", initials);
              let fontSize = "2.5em";
              if (window.matchMedia("(max-width: 576px)").matches) {
                if (dispActiveNames.length > 8) {
                  fontSize = "2.0em";
                } else if (dispActiveNames.length > 12) {
                  fontSize = "1.75em";
                }
              }
              miniCard.css("--font-size", fontSize);
            }

            if (addwav) {
              //show the waveform
              miniCard = $('<div class="card"></div>');
              miniCard.css({
                width: "100%",
                height: "100%",
                margin: "0px",
                padding: "0px",
                background: "linear-gradient(135deg, #f5f7fa 0%, #c3cfe2 100%)",
              });

              // Create the overlay element
              let overlay = $('<div class="overlay"></div>');
              overlay.css({
                position: "absolute",
                top: "0",
                left: "0",
                "min-width": "50%",
                "min-height": "3%",
                "max-height": "6%",
                display: "grid",
                "grid-template-columns": "4fr 2fr 1fr",
                "grid-gap": "3px",
              });

              // Create the name column and append it to the overlay
              let nameColumn = $('<div class="name-column"></div>');
              nameColumn.css({
                display: "flex",
                "justify-content": "center",
                "align-items": "center",
                "background-color": "rgba(0, 0, 0, 0.5)",
                padding: "2px",
                color: "white",
                fontSize: "1.0em",
              });
              nameColumn.text(name);
              overlay.append(nameColumn);

              // Create the waveform element and append it to the overlay
              let waveform = $('<div class="waveform sound"></div>');
              waveform.attr("id", "wave" + name); // Add ID to waveform
              waveform.css({
                display: "flex",
                "justify-content": "left",
                "align-items": "center",
                "background-color": "rgba(0, 0, 0, 0.05)",
                padding: "2px",
                color: "white",
              });
              // hide the waveform
              waveform.hide();

              // Add individual bars to the waveform
              for (let i = 0; i < 9; i++) {
                let bar = $('<div class="bar"></div>');
                waveform.append(bar);
              }

              overlay.append(waveform);

              //append the overlay to the card
              miniCard.append(overlay);

              miniCard.addClass("mini-carded");
              miniCard.addClass("active-video");
              miniCard.attr("data-initials", initials);

              let fontSize = "2.5em";
              if (window.matchMedia("(max-width: 576px)").matches) {
                if (dispActiveNames.length > 8) {
                  fontSize = "2.0em";
                } else if (dispActiveNames.length > 12) {
                  fontSize = "1.75em";
                }
              }
              miniCard.css("--font-size", fontSize);
            }

            maingrids.append(miniCard);
            await updateMainCardsGrid();
          }

          async function addMainBoard() {
            try {
              await moveBoard();

              //add a main board (main screen)
              const allMiniGrid1 = await document.querySelectorAll(
                ".maingrids"
              );
              allMiniGrid1.forEach((grid) => {
                grid.remove();
              });

              $(".maingrid-container").empty();

              //create a new maingrid div
              let maingrids = await $(
                '<div class="maingrids" style="display: grid; grid-gap: 0px; justify-content: center;width: 100%;margin: 0%;padding: 0%;margin-top:0px;padding-top:0px"></div>'
              );
              $(".maingrid-container").append(maingrids);

              //get the whiteboard
              let whiteboard = await document.getElementById(
                "whiteboard-interface"
              );
              //show the whiteboard
              whiteboard.style.display = "block";

              //create a new maingrid div
              await $(".maingrids").append(whiteboard);

              updateMainCardsGrid();
            } catch (error) {}
          }

          async function addMainVideo(
            host,
            diffStream = false,
            streamName = null
          ) {
            //add a main video (main screen)
            let remoteProducerId;
            let hostStream;
            let participant;
            let participant_;
            let streame;

            // Get the whiteboard element
            await moveBoard();

            const allMiniGrid1 = await document.querySelectorAll(".maingrids");
            allMiniGrid1.forEach((grid) => {
              grid.remove();
            });

            //remove all children of all .maingrid-container and empty the containers
            $(".maingrid-container").empty();

            //create a new maingrid div
            let maingrids = await $(
              '<div class="maingrids" style="display: grid; grid-gap: 0px; justify-content: center;width: 100%;margin: 0%;padding: 0%;margin-top:0px;padding-top:0px"></div>'
            );
            $(".maingrid-container").append(maingrids);

            if (diffStream == true) {
              if (shared) {
                host.stream = await streamName;
              } else {
                host.stream = await streamName.stream;
              }
              host.mirror = false;
            } else {
              remoteProducerId = await host.videoID;
              if (islevel == "2") {
                host.stream =
                  keepBackground && virtualStream
                    ? virtualStream
                    : await localStreamVideo;
                host.mirror = true;
              } else {
                streame = await oldAllStreams.find(
                  (streame) => streame.producerId == remoteProducerId
                );
                host.stream = await streame.stream;
                host.mirror = false;
              }
            }
            //host video on maingrid
            participant = host;
            participant_ = host;

            let card = await createCardElements(
              participant,
              participant_,
              remoteProducerId,
              false
            );

            // Create the overlay element
            let overlay = $('<div class="overlay"></div>');
            overlay.css({
              position: "absolute",
              top: "0",
              left: "0",
              "min-width": "50%",
              "min-height": "3%",
              "max-height": "6%",
              display: "grid",
              "grid-template-columns": "4fr 2fr 1fr",
              "grid-gap": "3px",
            });

            // Create the name column and append it to the overlay
            let nameColumn = $('<div class="name-column"></div>');
            nameColumn.css({
              display: "flex",
              "justify-content": "center",
              "align-items": "center",
              "background-color": "rgba(0, 0, 0, 0.5)",
              padding: "2px",
              color: "white",
              fontSize: "1.0em",
            });
            nameColumn.text(host.name);
            overlay.append(nameColumn);

            // Create the waveform element and append it to the overlay
            let waveform = $('<div class="waveform sound"></div>');
            waveform.attr("id", "wave" + host.name); // Add ID to waveform
            waveform.css({
              display: "flex",
              "justify-content": "left",
              "align-items": "center",
              "background-color": "rgba(0, 0, 0, 0.05)",
              padding: "2px",
              color: "white",
            });
            // hide the waveform
            waveform.hide();

            // Add individual bars to the waveform
            for (let i = 0; i < 9; i++) {
              let bar = $('<div class="bar"></div>');
              waveform.append(bar);
            }

            overlay.append(waveform);

            //append the overlay to the card
            card.append(overlay);

            let miniCard = $('<div class="mini-card last"></div>');
            miniCard.append(card);
            // Append the screenboard-interface if conditions are met
            if (shared && diffStream) {
              if (annotateScreenStream) {
                try {
                  const canvas = $("#screenboard-interface");

                  // Make it visible and adjust styles for overlay
                  canvas.css({
                    display: "flex",
                    width: "100%",
                    height: "100%",
                    position: "absolute",
                    top: "0",
                    left: "0",
                    "z-index": "1000", // Ensure it is on top
                  });

                  const canvasBoard = $("#screenboardContent");
                  canvasBoard.css({
                    width: "100%",
                    height: "100%",
                  });

                  miniCard.append(canvas);
                } catch (error) {}
              } else {
                //add a button to trigger the annotation
                let annotateButton = $(
                  '<button class="btn btnBoardScreen btn-primary annotateScreenBtn" style="position: absolute; top: 5px; right: 5px; z-index: 1000;"><i class="fas fa-pencil-alt"></i></button>'
                );
                annotateButton.click(async function () {
                  prevForceFullDisplay = false;
                  forceFullDisplay = false;
                  $("#annotateScreen").trigger("click");
                  await prepopulateUserMedia(hostLabel);
                  showAlert(
                    `You can now annotate the screen. If you cannot see your annotation controls (on top), try minimizing your screen by using 'Cmd' + '-' (on Mac) or 'Ctrl' + '-' (on Windows).`,
                    "success",
                    9000
                  );
                  //hide the button
                  annotateButton.hide();
                });
                miniCard.append(annotateButton);
              }
            }
            await maingrids.append(miniCard);

            //update width and height of the video
            await updateMainCardsGrid();
          }

          window.addEventListener("load", async () => {
            await prepopulateUserMedia(hostLabel);
            await rePort();
          });

          //on successful connection, create listeners for the remote socket
          socket.on("new-producer", async (data) => {
            //handle new producer
            signalNewConsumerTransport(data.producerId, data.islevel, socket);

            //handle display for screen share
            first_round = false;
            if (shareScreenStarted || shared) {
              if (window.matchMedia("(max-width: 768px)").matches) {
                if (!landScaped) {
                  showAlert("Rotate your screen for optimal view.", "success");
                  landScaped = true;
                }
              }

              first_round = true;
            }
          });

          socket.on("producer-closed", async ({ remoteProducerId }) => {
            //handle producer closed

            const producerToClose = await consumerTransports.find(
              (transportData) => transportData.producerId === remoteProducerId
            );

            if (!producerToClose) {
              return;
            }
            // check if the ID of the producer to close is == screenId
            let kind = producerToClose.consumer.kind;

            if (producerToClose.producerId == screenId) {
              kind = "screenshare";
            }
            try {
              await producerToClose.consumerTransport.close();
            } catch (error) {}

            try {
              await producerToClose.consumer.close();
            } catch (error) {}

            consumerTransports = await consumerTransports.filter(
              (transportData) => transportData.producerId !== remoteProducerId
            );
            //close and resize the videos
            await closeAndResize(remoteProducerId, kind);
          });

          const joinConRoom = (sock, islevel) => {
            //connects to specific room on the remote socket (sock)
            // for external users pass { roomName,member,islevel, sec:secret, apiUserName:apiUserName} as data
            //where sec is the secret (token) and apiUserName is your apiUserName
            return new Promise((resolve, reject) => {
              sock.emit(
                "joinConRoom",
                { roomName, islevel, member },
                (data) => {
                  resolve(data);
                }
              );
            });
          };

          const joinRoom = async () => {
            //function to join the room and produce media (if needed)
            await socket.emit(
              "joinRoom",
              { roomName, islevel, member },
              async (data) => {
                //check if rtpCapabilities is null, if null, check banned, or hostNotJoined
                //if not null, then create device
                //banned is true if user is banned; hostNotJoined is true if host is not in the room

                if (data.rtpCapabilities == null) {
                  //redirect to home page with showalert that user is not allowed to join
                  await showAlert(
                    "Sorry, you cannot join this event. Redirecting to home page in 1 seconds."
                  );

                  setTimeout(async function () {
                    window.location.href = await redirectURL;
                  }, 1000);
                } else {
                  //check and connect to the room on mediasfu
                  if (
                    data.mediasfuURL &&
                    data.mediasfuURL != "" &&
                    data.mediasfuURL != null &&
                    data.mediasfuURL.length > 10
                  ) {
                    //connect to the mediasfu if you already have the mediasfuURL
                    try {
                      await joinMediasfu(data.mediasfuURL);
                      confHide = true;
                      if (deferHide) {
                        await hideLoadingModal();
                      }
                    } catch (error) {
                      confHide = true;
                      if (deferHide) {
                        await hideLoadingModal();
                      }
                    }
                  } else if (
                    (!data.mediasfuURL ||
                      data.mediasfuURL == "" ||
                      data.mediasfuURL.length < 10) &&
                    islevel != "2" &&
                    data.allowRecord
                  ) {
                    if (
                      data.apiKey &&
                      data.apiKey != "" &&
                      data.apiKey.length == 64 &&
                      data.apiUserName &&
                      data.apiUserName != "" &&
                      data.apiUserName.length > 5 &&
                      (roomName.startsWith("s") || roomName.startsWith("p"))
                    ) {
                      //join room on mediaSFU
                      const payload = {
                        action: "join",
                        meetingID: roomName,
                        userName: member,
                      };

                      const response = await joinRoomOnMediaSFU(
                        payload,
                        data.apiUserName,
                        data.apiKey
                      );

                      if (response.success && response.data.success) {
                        mediasfuURL = response.data.publicURL;

                        try {
                          await socket.emit(
                            "updateMediasfuURL",
                            { eventID: roomName, mediasfuURL },
                            async ({ success }) => {}
                          );
                        } catch (error) {
                          confHide = true;
                          if (deferHide) {
                            await hideLoadingModal();
                          }
                        }

                        try {
                          await joinMediasfu(mediasfuURL);
                          confHide = true;
                          if (deferHide) {
                            await hideLoadingModal();
                          }
                        } catch (error) {
                          confHide = true;
                          if (deferHide) {
                            await hideLoadingModal();
                          }
                        }
                      } else {
                        confHide = true;
                        if (deferHide) {
                          await hideLoadingModal();
                        }
                      }
                    } else {
                      confHide = true;
                      if (deferHide) {
                        await hideLoadingModal();
                      }
                    }
                  } else {
                    console.log("no mediasfuURL", confHide, deferHide);
                    confHide = true;
                    if (deferHide) {
                      await hideLoadingModal();
                    }
                  }

                  //assign the rtpCapabilities
                  rtpCapabilities = data.rtpCapabilities;
                  //assign the host passcode
                  adminPasscode = data.secureCode;
                  //assign the meeting and recording params
                  eventRoomParams = data.eventRoomParams;
                  getRecordParams(data.recordingParams);
                  itemPageLimit = eventRoomParams.itemPageLimit;
                  eventType = eventRoomParams.type;
                  //auto grant permission to other person in chat event
                  if (eventType == "chat" && islevel != "2") {
                    youAreCoHost = true;
                  }

                  if (eventType == "chat") {
                    //update interface for chat event
                    meetingDisplayType = "all";
                    autoWave = false;
                    forceFullDisplay = true;
                    chatSetting = true;

                    const badgeContainer = $(
                      '<div class="badge-container" ></div>'
                    );
                    const progressTimer = $(
                      '<div id="meetingProgressTimer" class="progress-timer badge bg-success"></div>'
                    );
                    badgeContainer.append(progressTimer);

                    ///add the badge container to the main aspect
                    $("#mainAspect").append(badgeContainer);
                  }

                  //assign permissions and defined media types
                  audioSetting = eventRoomParams.audioSetting;
                  videoSetting = eventRoomParams.videoSetting;
                  screenshareSetting = eventRoomParams.screenshareSetting;
                  chatSetting = eventRoomParams.chatSetting;
                  audioOnlyRoom =
                    eventRoomParams.mediaType == "video" ? false : true;

                  // update ui for webinar, conference and basic
                  if (eventType == "broadcast" || eventType == "chat") {
                    //hide the chat and participants

                    let addForBasic = false;

                    if (eventType == "broadcast") {
                      addForBasic = true;
                      $(".othergrid").remove();
                      itemPageLimit = 1;

                      let height100 = 1 * windowHeight;

                      $("#mainAspect").css("height", height100);
                      $(".maingrid").css("height", height100);
                    } else {
                      moveBoard();
                      $(".maingrid").remove();
                      itemPageLimit = 2;
                    }

                    $("#subAspect").remove();
                    $("#mainAspect").css("padding", 0);
                    $("#mainAspect").css("margin", 0);

                    //remove element with id of controlButtons
                    $("#controlButtons").remove();
                    addFloatingMediaButtons(addForBasic);
                  } else if (eventType == "conference") {
                    let maingrid = $(".maingrid");

                    if (shared || shareScreenStarted) {
                      if (maingrid.length == 0) {
                        //add maingrid
                        await addMainGrid();
                      }
                    } else {
                      await moveBoard();
                      await $(".maingrid").remove();
                      //add timer
                      await addTimer();
                    }
                  }

                  //update the number of participants on the interface page
                  screenPageLimit = Math.min(screenPageLimit, itemPageLimit);

                  //assign resolution and orientation
                  if (islevel == "2") {
                    targetOrientation = eventRoomParams.targetOrientationHost;
                    targetResolution = eventRoomParams.targetResolutionHost;
                  } else {
                    targetOrientation = eventRoomParams.targetOrientation;
                    targetResolution = eventRoomParams.targetResolution;
                  }

                  //assign the media capture specifications
                  if (targetOrientation == "landscape") {
                    if (targetResolution == "hd") {
                      vidCons = hdCons;
                    } else if (targetResolution == "QnHD") {
                      vidCons = QnHDCons;
                    } else if (targetResolution == "fhd") {
                      vidCons = fhdCons;
                    } else if (targetResolution == "qhd") {
                      vidCons = qhdCons;
                    } else {
                      vidCons = sdCons;
                    }
                  } else if (targetOrientation == "neutral") {
                    if (targetResolution == "hd") {
                      vidCons = hdConsNeu;
                    } else if (targetResolution == "QnHD") {
                      vidCons = QnHDConsNeu;
                    } else if (targetResolution == "fhd") {
                      vidCons = fhdConsNeu;
                    } else if (targetResolution == "qhd") {
                      vidCons = qhdConsNeu;
                    } else {
                      vidCons = sdConsNeu;
                    }
                  } else {
                    if (targetResolution == "hd") {
                      vidCons = hdConsPort;
                    } else if (targetResolution == "QnHD") {
                      vidCons = QnHDConsPort;
                    } else if (targetResolution == "fhd") {
                      vidCons = fhdConsPort;
                    } else if (targetResolution == "qhd") {
                      vidCons = qhdConsPort;
                    } else {
                      vidCons = sdConsPort;
                    }
                  }

                  if (targetResolution == "hd") {
                    await v_params.encodings.forEach((encoding) => {
                      if (encoding.maxBitrate) {
                        encoding.maxBitrate *= 4; // Multiply by 4 for "hd" resolution
                        encoding.initialAvailableBitrate *= 4;
                      }
                    });

                    await h_params.encodings.forEach((encoding) => {
                      if (encoding.maxBitrate) {
                        encoding.maxBitrate *= 4; // Multiply by 4 for "hd" resolution
                        encoding.initialAvailableBitrate *= 4;
                      }
                    });

                    frameRate = 15;
                  } else if (targetResolution == "QnHD") {
                    await v_params.encodings.forEach((encoding) => {
                      if (encoding.maxBitrate) {
                        encoding.maxBitrate *= 0.25; // Multiply by 0.25 for QnHD resolution
                        encoding.minBitrate *= 0.25; // Multiply by 0.25 for QnHD resolution
                        encoding.initialAvailableBitrate *= 0.25;
                      }
                    });

                    await h_params.encodings.forEach((encoding) => {
                      if (encoding.maxBitrate) {
                        encoding.maxBitrate *= 0.25; // Multiply by 0.25 for QnHD resolution
                        encoding.minBitrate *= 0.25; // Multiply by 0.25 for QnHD resolution
                        encoding.initialAvailableBitrate *= 0.25;
                      }
                    });

                    frameRate = 5;
                    h_params.codecOptions.videoGoogleStartBitrate *= 0.25;
                    v_params.codecOptions.videoGoogleStartBitrate *= 0.25;
                  } else if (targetResolution == "fhd") {
                    await v_params.encodings.forEach((encoding) => {
                      if (encoding.maxBitrate) {
                        encoding.maxBitrate *= 8; // Multiply by 8 for "fhd" resolution
                        encoding.initialAvailableBitrate *= 8;
                      }
                    });

                    await h_params.encodings.forEach((encoding) => {
                      if (encoding.maxBitrate) {
                        encoding.maxBitrate *= 8; // Multiply by 8 for "fhd" resolution
                        encoding.initialAvailableBitrate *= 8;
                      }
                    });

                    frameRate = 20;
                  } else if (targetResolution == "qhd") {
                    await v_params.encodings.forEach((encoding) => {
                      if (encoding.maxBitrate) {
                        encoding.maxBitrate *= 16; // Multiply by 16 for "qhd" resolution
                        encoding.initialAvailableBitrate *= 16;
                      }
                    });

                    await h_params.encodings.forEach((encoding) => {
                      if (encoding.maxBitrate) {
                        encoding.maxBitrate *= 16; // Multiply by 16 for "qhd" resolution
                        encoding.initialAvailableBitrate *= 16;
                      }
                    });

                    frameRate = 30;
                  }

                  if (recordingVideoSupport) {
                    //add more bitrate for recording
                    await v_params.encodings.forEach((encoding) => {
                      if (encoding.maxBitrate) {
                        encoding.maxBitrate *= 1.2; // Multiply by 1.2
                        encoding.minBitrate *= 1.2; // Multiply by 1.2
                        encoding.initialAvailableBitrate *= 1.2;
                      }
                    });

                    await h_params.encodings.forEach((encoding) => {
                      if (encoding.maxBitrate) {
                        encoding.maxBitrate *= 1.2; // Multiply by 1.2
                        encoding.minBitrate *= 1.2; // Multiply by 1.2
                        encoding.initialAvailableBitrate *= 1.2;
                      }
                    });

                    h_params.codecOptions.videoGoogleStartBitrate *= 1.2;
                    v_params.codecOptions.videoGoogleStartBitrate *= 1.2;
                  }

                  //finally create a device
                  await createDevice();
                  await createReceiveAllTransports(socket);
                }
              }
            );
          };

          const createDevice = async () => {
            // create a device and load the rtpCapabilities
            try {
              if (!device) {
                device = await new mediasoupClient.Device();

                await device.load({
                  routerRtpCapabilities: rtpCapabilities,
                });
              }

              //load spinner and get messages from the server
              hideSpannedMessages(true);
              await tuneMessages();
            } catch (error) {
              if (error.name === "UnsupportedError") {
              }
            }
          };

          const createReceiveAllTransports = async (nsock) => {
            if (!membersReceived) {
              deferReceiveAllTransports = true;
              return;
            }

            // receive transports from an IP (nsock)
            await nsock.emit(
              "createReceiveAllTransports",
              { roomName, member },
              async ({ producersExist }) => {
                let options = ["2", "1", "0"];
                if (producersExist) {
                  for (let i = 0; i < options.length; i++) {
                    let xlevel = options[i];
                    await getProducersAlt(xlevel, nsock);
                  }
                }
              }
            );
          };

          const createSendTransport = async (option) => {
            //create send transport to produce media
            //islevel is '0', '1', or '2'; '2' is host
            await socket.emit(
              "createWebRtcTransport",
              { consumer: false, islevel: islevel },
              async ({ params }) => {
                if (params.error) {
                  return;
                }

                producerTransport = await device.createSendTransport(params);

                await producerTransport.on(
                  "connect",
                  async ({ dtlsParameters }, callback, errback) => {
                    try {
                      await socket.emit("transport-connect", {
                        dtlsParameters,
                      });

                      callback();
                    } catch (error) {
                      errback(error);
                    }
                  }
                );

                await producerTransport.on(
                  "produce",
                  async (parameters, callback, errback) => {
                    try {
                      await socket.emit(
                        "transport-produce",
                        {
                          kind: parameters.kind,
                          rtpParameters: parameters.rtpParameters,
                          appData: parameters.appData,
                          islevel: islevel,
                          name: member,
                        },
                        async ({ id, producersExist }) => {
                          callback({ id });
                        }
                      );
                    } catch (error) {
                      errback(error);
                    }
                  }
                );

                //listen for connection state change
                await producerTransport.on(
                  "connectionstatechange",
                  async (state) => {
                    switch (state) {
                      case "connecting":
                        break;

                      case "connected":
                        break;

                      case "failed":
                        await producerTransport.close();
                        break;

                      default:
                        break;
                    }
                  }
                );

                transportCreated = true;
                await connectSendTransport(option);
              }
            );
          };

          const createSendTransportMediaSFU = async (
            option,
            mediafu_socket = p_sockets[0]
          ) => {
            //create send transport to produce media
            //islevel is '0', '1', or '2'; '2' is host
            await mediafu_socket.emit(
              "createWebRtcTransport",
              { consumer: false, islevel: islevel },
              async ({ params }) => {
                if (params.error) {
                  return;
                }

                producerTransportMediaSFU = await device.createSendTransport(
                  params
                );

                await producerTransportMediaSFU.on(
                  "connect",
                  async ({ dtlsParameters }, callback, errback) => {
                    try {
                      await mediafu_socket.emit("transport-connect", {
                        dtlsParameters,
                      });

                      callback();
                    } catch (error) {
                      errback(error);
                    }
                  }
                );

                await producerTransportMediaSFU.on(
                  "produce",
                  async (parameters, callback, errback) => {
                    try {
                      await mediafu_socket.emit(
                        "transport-produce",
                        {
                          kind: parameters.kind,
                          rtpParameters: parameters.rtpParameters,
                          appData: parameters.appData,
                          islevel: islevel,
                          name: member,
                        },
                        async ({ id, producersExist }) => {
                          callback({ id });
                        }
                      );
                    } catch (error) {
                      errback(error);
                    }
                  }
                );

                //listen for connection state change
                await producerTransportMediaSFU.on(
                  "connectionstatechange",
                  async (state) => {
                    switch (state) {
                      case "connecting":
                        break;

                      case "connected":
                        break;

                      case "failed":
                        await producerTransportMediaSFU.close();
                        break;

                      default:
                        break;
                    }
                  }
                );

                transportCreated = true;
                await connectSendTransportMediaSFU(option);
              }
            );
          };

          const connectSendTransportScreen = async (stream, remote = false) => {
            //connect send transport for screen share
            params = await screen_params;

            let codec = await device.rtpCapabilities.codecs.find(
              (codec) => codec.mimeType.toLowerCase() === "video/vp9"
            );
            if (remote) {
              screenProducerMediaSFU = await producerTransportMediaSFU.produce({
                track: stream.getVideoTracks()[0],
                ...params,
                codec: codec,
                appData: { mediaTag: "screen-video" },
              });
            } else {
              screenProducer = await producerTransport.produce({
                track: stream.getVideoTracks()[0],
                ...params,
                codec: codec,
                appData: { mediaTag: "screen-video" },
              });
            }
          };

          const connectSendTransportAudio = async (
            audioParams,
            remote = false
          ) => {
            //connect send transport for audio
            if (remote) {
              audioProducerMediaSFU = await producerTransportMediaSFU.produce(
                audioParams
              );
            } else {
              audioProducer = await producerTransport.produce(audioParams);
            }
          };

          const connectSendTransportVideo = async (
            videoParams,
            remote = false
          ) => {
            //connect send transport for video
            if (remote) {
              videoProducerMediaSFU = await producerTransportMediaSFU.produce(
                videoParams
              );
              return;
            } else {
              videoProducer = await producerTransport.produce(videoParams);
            }

            if (islevel == "2") {
              updateMainWindow = true;
            }
          };

          const disconnectSendTransportScreen = async (remote = false) => {
            //disconnect send transport for screen share
            if (remote) {
              await screenProducerMediaSFU.close();
            } else {
              await screenProducer.close();
            }

            //notify the server
            if (remote) {
              await p_sockets[0].emit("closeScreenProducer");
              await p_sockets[0].emit("pauseProducerMedia", {
                mediaTag: "screen",
                roomName: roomName,
              });
            } else {
              await socket.emit("closeScreenProducer");
              await socket.emit("pauseProducerMedia", {
                mediaTag: "screen",
                roomName: roomName,
              });
            }
          };

          const disconnectSendTransportAudio = async (remote = false) => {
            if (remote) {
              await audioProducerMediaSFU.pause();
            } else {
              await audioProducer.pause();
            }

            //update the ui
            if (videoAlreadyOn == false && islevel == "2" && !remote) {
              if (!lock_screen && !shared) {
                updateMainWindow = true;
                await prepopulateUserMedia(hostLabel);
                updateMainWindow = false;
              }
            }
            //notify the server
            if (remote) {
              await p_sockets[0].emit("pauseProducerMedia", {
                mediaTag: "audio",
                roomName: roomName,
              });
            } else {
              await socket.emit("pauseProducerMedia", {
                mediaTag: "audio",
                roomName: roomName,
              });
            }
          };

          const disconnectSendTransportVideo = async (remote = false) => {
            //disconnect send transport for video
            if (remote) {
              await videoProducerMediaSFU.close();
            } else {
              await videoProducer.close();
            }
            //notify the server
            if (remote) {
              await p_sockets[0].emit("pauseProducerMedia", {
                mediaTag: "video",
                roomName: roomName,
              });
            } else {
              await socket.emit("pauseProducerMedia", {
                mediaTag: "video",
                roomName: roomName,
              });
            }

            if (remote) {
              return;
            }

            //update the ui
            if (islevel == "2") {
              updateMainWindow = true;
            }

            if (lock_screen) {
              await reorderStreams(true, true);

              // await rePort()
            } else {
              await reorderStreams(false, true);
            }
          };

          const resumeSendTransportAudio = async (remote = false) => {
            //resume send transport for audio
            if (remote) {
              await audioProducerMediaSFU.resume();
            } else {
              await audioProducer.resume();
            }

            //update the ui
            if (videoAlreadyOn == false && islevel == "2" && !remote) {
              if (!lock_screen && !shared) {
                updateMainWindow = true;
                await prepopulateUserMedia(hostLabel);
                updateMainWindow = false;
              }
            }
          };

          const connectSendTransport = async (option) => {
            //connect send transport for audio, video, screen share, or all

            if (option == "audio") {
              await connectSendTransportAudio(audioParams);
            } else if (option == "video") {
              await connectSendTransportVideo(videoParams);
            } else if (option == "screen") {
              if (
                whiteboardStarted &&
                !whiteboardEnded &&
                canvasStream &&
                islevel == "2" &&
                !shared
              ) {
                await connectSendTransportScreen(canvasStream);
              } else {
                await connectSendTransportScreen(localStreamScreen);
              }
            } else {
              await connectSendTransportAudio(audioParams);
              await connectSendTransportVideo(videoParams);
            }
          };

          const connectSendTransportMediaSFU = async (option) => {
            //connect send transport for audio, video, screen share, or all

            if (option == "audio") {
              await connectSendTransportAudio(audioParams, true);
            } else if (option == "video") {
              await connectSendTransportVideo(videoParams, true);
            } else if (option == "screen") {
              if (
                whiteboardStarted &&
                !whiteboardEnded &&
                canvasStream &&
                islevel == "2" &&
                !shared
              ) {
                await connectSendTransportScreen(canvasStream, true);
              } else {
                await connectSendTransportScreen(localStreamScreen, true);
              }
            } else {
              await connectSendTransportAudio(audioParams, true);
              await connectSendTransportVideo(videoParams, true);
            }
          };

          const signalNewConsumerTransport = async (
            remoteProducerId,
            xlevel,
            nsock
          ) => {
            //signal a new producer to the local consumer

            if (consumingTransports.includes(remoteProducerId)) {
              //already consuming
              return;
            }

            if (!device) {
              return;
            }

            await consumingTransports.push(remoteProducerId);

            await nsock.emit(
              "createWebRtcTransport",
              { consumer: true, islevel: xlevel },
              async ({ params }) => {
                if (params.error) {
                  return;
                }

                try {
                  let consumerTransport = await device.createRecvTransport(
                    params
                  );

                  await consumerTransport.on(
                    "connect",
                    async ({ dtlsParameters }, callback, errback) => {
                      try {
                        await nsock.emit("transport-recv-connect", {
                          dtlsParameters,
                          serverConsumerTransportId: params.id,
                        });

                        callback();
                      } catch (error) {
                        errback(error);
                      }
                    }
                  );

                  //listen for connection state change
                  await consumerTransport.on(
                    "connectionstatechange",
                    async (state) => {
                      switch (state) {
                        case "connecting":
                          break;

                        case "connected":
                          break;

                        case "failed":
                          await consumerTransport.close();
                          if (lock_screen) {
                            await reorderStreams(true);
                          } else {
                            await reorderStreams();
                          }

                          break;

                        default:
                          break;
                      }
                    }
                  );

                  await connectRecvTransport(
                    consumerTransport,
                    remoteProducerId,
                    params.id,
                    nsock
                  );
                } catch (error) {
                  return;
                }
              }
            );
          };

          const getProducersAlt = async (xlevel, nsock) => {
            await nsock.emit("getProducersAlt", {}, async (producerIds) => {
              if (producerIds.length > 0) {
                await producerIds.forEach((id) =>
                  signalNewConsumerTransport(id, xlevel, nsock)
                );
              }
            });
          };

          const connectRecvTransport = async (
            consumerTransport,
            remoteProducerId,
            serverConsumerTransportId,
            nsock
          ) => {
            //connect receive transport to consume media

            await nsock.emit(
              "consume",
              {
                rtpCapabilities: device.rtpCapabilities,
                remoteProducerId,
                serverConsumerTransportId,
              },
              async ({ params }) => {
                if (params.error) {
                  return;
                }

                const consumer = await consumerTransport.consume({
                  id: params.id,
                  producerId: params.producerId,
                  kind: params.kind,
                  rtpParameters: params.rtpParameters,
                });

                consumerTransports = await [
                  ...consumerTransports,
                  {
                    consumerTransport,
                    serverConsumerTransportId: params.id,
                    producerId: remoteProducerId,
                    consumer,
                    socket_: nsock,
                  },
                ];

                const { track } = await consumer;

                await nsock.emit(
                  "consumer-resume",
                  { serverConsumerId: params.serverConsumerId },
                  async ({ resumed }) => {
                    if (resumed) {
                      //consumer resumed and ready to be used

                      if (params.kind == "audio") {
                        //audio resumed

                        //media display and ui update to prioritize audio/video
                        let nStream = new MediaStream([track]);
                        addMiniAudio(nStream, remoteProducerId, consumer);

                        //add to allaudiostreams array; add producerId, stream
                        allAudioStreams = await [
                          ...allAudioStreams,
                          { producerId: remoteProducerId, stream: nStream },
                        ];

                        //check if the participant with audioID == remoteProducerId has a valid videoID of not null or "" or undefined
                        //sometimes we do not have the name instantly, so we need to wait for it
                        let participant = await participants.filter(
                          (participant) =>
                            participant.audioID == remoteProducerId
                        );

                        let name;

                        try {
                          name = await participant[0].name;
                        } catch (error) {}

                        if (name) {
                          //add to audStreamNames array; add producerId, name
                          audStreamNames = await [
                            ...audStreamNames,
                            { producerId: remoteProducerId, name: name },
                          ];
                          if (
                            !mainScreenFilled &&
                            participant[0].islevel == "2"
                          ) {
                            updateMainWindow = true;
                            await prepopulateUserMedia(hostLabel);
                            updateMainWindow = false;
                          }
                        } else {
                          return;
                        }

                        //checks for display type and updates the ui
                        let checker;
                        let alt_checker = false;

                        if (meetingDisplayType == "video") {
                          checker =
                            participant[0].videoID != null &&
                            participant[0].videoID != "" &&
                            participant[0].videoID != undefined;
                        } else {
                          checker = true;
                          alt_checker = true;
                        }

                        if (checker) {
                          if (shareScreenStarted || shared) {
                            if (!alt_checker) {
                              await reorderStreams();
                            }
                          } else {
                            if (alt_checker && meetingDisplayType != "video") {
                              await reorderStreams(false, true);
                            } else if (
                              !alt_checker &&
                              meetingDisplayType == "video"
                            ) {
                              //no video found
                              let micIcon = $("#Audio" + participant.name);
                              // Change the icon based on the muted status
                              if (micIcon) {
                                if (participant.muted) {
                                  micIcon
                                    .removeClass("fa-microphone")
                                    .addClass("fa-microphone-slash");
                                  let waveform = $("#wave" + participant.name);
                                  if (waveform) {
                                    waveform.hide();
                                  }
                                } else {
                                  micIcon
                                    .removeClass("fa-microphone-slash")
                                    .addClass("fa-microphone");
                                  let waveform = $("#wave" + participant.name);
                                  if (waveform) {
                                    waveform.show();
                                  }
                                }
                              } else {
                                let waveform = $("#wave" + participant.name);
                                if (waveform && !participant.muted) {
                                  waveform.show();
                                }
                              }
                            }
                          }
                        }
                      } else {
                        //video resumed
                        let nStream = new MediaStream([track]);

                        //check for display type and update the ui
                        if (remoteProducerId == screenId) {
                          //put on Main screen for screen share
                          updateMainWindow = true;
                          remoteScreenStream = await [
                            { producerId: remoteProducerId, stream: nStream },
                          ];

                          if (eventType == "conference") {
                            let maingrid = $(".maingrid");

                            if (shared || shareScreenStarted) {
                              if (maingrid.length == 0) {
                                //add maingrid
                                await addMainGrid();
                              }
                            } else {
                              await moveBoard();
                              $(".maingrid").remove();
                              //add timer
                              await addTimer();
                            }
                          }

                          if (!lock_screen) {
                            await prepopulateUserMedia(hostLabel);
                            await reorderStreams(false, true);
                          } else {
                            if (!first_round) {
                              await prepopulateUserMedia(hostLabel);
                              await reorderStreams(false, true);
                            }
                          }

                          lock_screen = true;
                          firstAll = true;
                        } else {
                          // non screen share video resumed

                          //operations to add video to the ui (either main screen or mini screen)

                          //get the name of the participant with videoID == remoteProducerId
                          let participant = await participants.filter(
                            (participant) =>
                              participant.videoID == remoteProducerId
                          );

                          if (
                            participant.length > 0 &&
                            participant[0].name != null &&
                            participant[0].name != "" &&
                            participant[0].name != undefined &&
                            participant[0].name !== member
                          ) {
                            allVideoStreams = await [
                              ...allVideoStreams,
                              {
                                producerId: remoteProducerId,
                                stream: nStream,
                                socket_: nsock,
                              },
                            ];
                          }

                          let admin = await participants.filter(
                            (participant) => participant.islevel == "2"
                          );

                          if (participant.length > 0) {
                            let name = participant[0].name;
                            streamNames = [
                              ...streamNames,
                              { producerId: remoteProducerId, name: name },
                            ];
                          }

                          // if not screenshare, filter out stream that belongs to participant with islevel == '2' (host)
                          // find the id of the participant with islevel == '2'
                          if (!shareScreenStarted) {
                            let admin = await participants.filter(
                              (participant) => participant.islevel == "2"
                            );
                            // remove video stream with producerId == admin.id
                            // get the videoID of the admin

                            if (admin.length > 0) {
                              let adminVidID = admin[0].videoID;

                              if (adminVidID != null && adminVidID != "") {
                                let oldAllStreams_ = [];
                                //check if len of allVideoStreams is > 0
                                if (oldAllStreams.length > 0) {
                                  oldAllStreams_ = oldAllStreams;
                                }

                                oldAllStreams = await allVideoStreams.filter(
                                  (streame) => streame.producerId == adminVidID
                                );

                                if (oldAllStreams.length < 1) {
                                  oldAllStreams = oldAllStreams_;
                                }

                                allVideoStreams = await allVideoStreams.filter(
                                  (streame) => streame.producerId != adminVidID
                                );

                                adminIDStream = adminVidID;
                                adminNameStream = admin[0].name;

                                if (remoteProducerId == adminVidID) {
                                  updateMainWindow = true;
                                }
                              }

                              gotAllVids = true;
                            }
                          } else {
                            //check if the videoID is either that of the admin or that of the screen participant
                            let admin = await participants.filter(
                              (participant) => participant.islevel == "2"
                            );
                            let screenParticipant = await participants.filter(
                              (participant) => participant.ScreenID == screenId
                            );

                            //see if producerId is that of admin videoID or screenParticipant videoID
                            let adminVidID;
                            if (admin.length > 0) {
                              adminVidID = await admin[0].videoID;
                            }

                            let screenParticipantVidID;
                            if (screenParticipant.length > 0) {
                              screenParticipantVidID =
                                await screenParticipant[0].videoID;
                            }

                            if (adminVidID != null && adminVidID != "") {
                              adminIDStream = adminVidID;
                              adminNameStream = admin[0].name;
                            }

                            if (
                              screenParticipantVidID != null &&
                              screenParticipantVidID != ""
                            ) {
                              screenShareIDStream = screenParticipantVidID;
                              screenShareNameStream = screenParticipant[0].name;
                            }

                            if (
                              (adminVidID != null && adminVidID != "") ||
                              (screenParticipantVidID != null &&
                                screenParticipantVidID != "")
                            ) {
                              if (
                                adminVidID == remoteProducerId ||
                                screenParticipantVidID == remoteProducerId
                              ) {
                                await reorderStreams(true);
                                return;
                              }
                            }
                          }

                          //update the ui
                          if (lock_screen || shared) {
                            defer_receive = true;

                            if (!first_round) {
                              await reorderStreams(false, true);
                            }
                          } else {
                            await reorderStreams(false, true);
                          }
                        }
                      }
                    }
                  }
                );
              }
            );
          };

          async function reUpdateInter(
            name,
            add,
            force = false,
            average = 127
          ) {
            // function to periodically update the ui for active media streams

            if (eventType == "broadcast" || eventType == "chat") {
              return;
            }

            let refLimit = screenPageLimit - 1;

            if (shareScreenStarted || shared) {
            } else {
              refLimit = itemPageLimit - 1;

              if (add) {
                const currentTime = Date.now();
                if (
                  (currentTime - lastReorderTime >= reorderInterval &&
                    average > 128.5) ||
                  (average > 130 &&
                    currentTime - lastReorderTime >= fastOrderInterval)
                ) {
                  lastReorderTime = currentTime;
                  sortAudioLoudness = true;
                  // updateMainWindow = true;
                  if (eventType == "conference") {
                    await onScreenChanges(true);
                  } else {
                    await reorderStreams(false, true);
                  }
                  sortAudioLoudness = false;
                  return;
                }
              }
            }

            if (shareScreenStarted || shared) {
              let newLimitedStreams_ = [];
              let newLimitedStreamsIDs_ = [];

              if (add) {
                let participant = await participants.find(
                  (participant) => participant.name == name
                );

                let videoID = participant.videoID;

                if (videoID == null || videoID == "" || videoID == undefined) {
                  return;
                }
                // check if videoID is in newLimitedStreamsIDs
                //check length of newLimitedStreamsIDs

                if (!newLimitedStreamsIDs.includes(videoID)) {
                  //first check length of newLimitedStreams to not exceed refLimit, if so remove oldSoundID from newLimitedStreams
                  if (newLimitedStreams.length > refLimit) {
                    let oldoldSounds = oldSoundIds;
                    // remove stream from newLimitedStreams
                    //loop through oldSoundIds and remove one and stop if newLimitedStreams.length <refLimit
                    for (let i = 0; i < oldSoundIds.length; i++) {
                      if (newLimitedStreams.length > refLimit) {
                        // remove stream from newLimitedStreams
                        if (
                          oldSoundIds[i] != screenShareNameStream ||
                          oldSoundIds[i] != adminNameStream
                        ) {
                          newLimitedStreams = newLimitedStreams.filter(
                            (stream) => stream.producerId != oldSoundIds[i]
                          );
                          newLimitedStreamsIDs = newLimitedStreamsIDs.filter(
                            (id) => id != oldSoundIds[i]
                          );
                          oldoldSounds = oldoldSounds.filter(
                            (id) => id != oldSoundIds[i]
                          );
                        }
                      }
                    }
                    oldSoundIds = await oldoldSounds;
                  }

                  // find the stream with the videoID in allVideoStreams
                  let stream = allVideoStreams.find(
                    (stream) => stream.producerId == videoID
                  );
                  // add stream to newLimitedStreams
                  if (newLimitedStreams.length < screenPageLimit) {
                    newLimitedStreams = [...newLimitedStreams, stream];
                    newLimitedStreamsIDs = [...newLimitedStreamsIDs, videoID];
                    // add the soundID to oldSoundIds
                    if (!oldSoundIds.includes(name)) {
                      oldSoundIds = [...oldSoundIds, name];
                    }
                    await changeVids();
                  }
                }
              } else {
                let participant = await participants.find(
                  (participant) => participant.name == name
                );

                videoID = await participant.videoID;

                if (videoID == null || videoID == "" || videoID == undefined) {
                  return;
                }

                if (!force) {
                  try {
                    // remove stream from newLimitedStreams
                    if (newLimitedStreams.length < screenPageLimit) {
                      return;
                    }
                    newLimitedStreams = newLimitedStreams.filter(
                      (stream) => stream.producerId != videoID
                    );
                    newLimitedStreamsIDs = newLimitedStreamsIDs.filter(
                      (id) => id != videoID
                    );
                    oldSoundIds = oldSoundIds.filter((id) => id != name);
                    await changeVids();
                  } catch (error) {}
                } else {
                  //check if the persons.muted == false
                  let mic = participant.muted;
                  if (mic) {
                    try {
                      // remove stream from newLimitedStreams
                      newLimitedStreams = newLimitedStreams.filter(
                        (stream) => stream.producerId != videoID
                      );
                      newLimitedStreamsIDs = newLimitedStreamsIDs.filter(
                        (id) => id != videoID
                      );
                      oldSoundIds = oldSoundIds.filter((id) => id != name);
                      await changeVids();
                    } catch (error) {}
                  }
                }
              }
            }
          }

          async function reorderStreams(add = false, screenChanged = false) {
            // function to reorder streams on the ui

            if (!add) {
              newLimitedStreams = [];
              newLimitedStreamsIDs = [];
              activeSounds = []; // get actives back in
            }

            let youyou = await allVideoStreams.filter(
              (stream) => stream.producerId == "youyou"
            );
            let admin = await participants.filter(
              (participant) => participant.islevel == "2"
            );

            if (admin.length > 0) adminVidID = await admin[0].videoID;
            else {
              adminVidID = null;
            }

            if (!(adminVidID === null || adminVidID === "")) {
              let adminStream = await allVideoStreams.find(
                (stream) => stream.producerId === adminVidID
              );

              if (!add) {
                newLimitedStreams = await [...newLimitedStreams, ...youyou];
                newLimitedStreamsIDs = await [
                  ...newLimitedStreamsIDs,
                  ...youyou.map((stream) => stream.producerId),
                ];
              } else {
                // first check if youyou is in newLimitedStreams, use the newLimitedStreams
                let youyouStream = await newLimitedStreams.find(
                  (stream) => stream.producerId === "youyou"
                );

                if (!youyouStream) {
                  //add it to the newLimitedStreams
                  newLimitedStreams = await [...newLimitedStreams, ...youyou];
                  newLimitedStreamsIDs = await [
                    ...newLimitedStreamsIDs,
                    ...youyou.map((stream) => stream.producerId),
                  ];
                }
              }

              if (adminStream) {
                adminIDStream = adminVidID;

                if (!add) {
                  newLimitedStreams = await [...newLimitedStreams, adminStream];
                  newLimitedStreamsIDs = await [
                    ...newLimitedStreamsIDs,
                    adminStream.producerId,
                  ];
                } else {
                  // first check if admin is in newLimitedStreams, use the newLimitedStreams
                  let adminStreamer = await newLimitedStreams.find(
                    (stream) => stream.producerId === adminVidID
                  );

                  if (!adminStreamer) {
                    //add it to the newLimitedStreams
                    newLimitedStreams = await [
                      ...newLimitedStreams,
                      adminStream,
                    ];
                    newLimitedStreamsIDs = await [
                      ...newLimitedStreamsIDs,
                      adminStream.producerId,
                    ];
                  }
                }
              } else {
                //find in oldAllStreams
                let oldAdminStream = await oldAllStreams.find(
                  (stream) => stream.producerId === adminVidID
                );

                if (oldAdminStream) {
                  //add it to the allVideoStream

                  adminIDStream = adminVidID;
                  adminNameStream = admin[0].name;

                  if (!add) {
                    newLimitedStreams = await [
                      ...newLimitedStreams,
                      oldAdminStream,
                    ];
                    newLimitedStreamsIDs = await [
                      ...newLimitedStreamsIDs,
                      oldAdminStream.producerId,
                    ];
                  } else {
                    // first check if admin is in newLimitedStreams, use the newLimitedStreams
                    let adminStreamer = await newLimitedStreams.find(
                      (stream) => stream.producerId === adminVidID
                    );
                    if (!adminStreamer) {
                      //add it to the newLimitedStreams
                      newLimitedStreams = await [
                        ...newLimitedStreams,
                        oldAdminStream,
                      ];
                      newLimitedStreamsIDs = await [
                        ...newLimitedStreamsIDs,
                        oldAdminStream.producerId,
                      ];
                    }
                  }
                }
              }

              //find the participant with the screenID same as screenId and put the videoID it in the newLimitedStreams array if it is not already there
              //look in participants array for the participant with the screenID same as screenId
              let screenParticipant = await participants.filter(
                (participant) => participant.ScreenID == screenId
              );

              if (screenParticipant.length > 0) {
                // get the videoID of the screenParticipant
                let screenParticipantVidID = await screenParticipant[0].videoID;
                // check if the screenParticipantVidID is already in the newLimitedStreams array and not null
                let screenParticipantVidID_ = await newLimitedStreams.filter(
                  (stream) => stream.producerId == screenParticipantVidID
                );
                if (
                  screenParticipantVidID_.length < 1 &&
                  screenParticipantVidID != null
                ) {
                  screenShareIDStream = screenParticipantVidID;
                  screenShareNameStream = screenParticipant[0].name;
                  // add the screenParticipantVidID to the newLimitedStreams array
                  let screenParticipantVidID__ = await allVideoStreams.filter(
                    (stream) => stream.producerId == screenParticipantVidID
                  );
                  newLimitedStreams = await [
                    ...newLimitedStreams,
                    ...screenParticipantVidID__,
                  ];
                  newLimitedStreamsIDs = await [
                    ...newLimitedStreamsIDs,
                    ...screenParticipantVidID__.map(
                      (stream) => stream.producerId
                    ),
                  ];
                }
              }
            } else {
              if (!add) {
                newLimitedStreams = await [...newLimitedStreams, ...youyou];
                newLimitedStreamsIDs = await [
                  ...newLimitedStreamsIDs,
                  ...youyou.map((stream) => stream.producerId),
                ];
              } else {
                // first check if youyou is in newLimitedStreams, use the newLimitedStreams
                let youyouStream = await newLimitedStreams.find(
                  (stream) => stream.producerId === "youyou"
                );

                if (!youyouStream) {
                  //add it to the newLimitedStreams
                  newLimitedStreams = await [...newLimitedStreams, ...youyou];
                  newLimitedStreamsIDs = await [
                    ...newLimitedStreamsIDs,
                    ...youyou.map((stream) => stream.producerId),
                  ];
                }
              }

              //find the participant with the screenID same as screenId and put the videoID it in the newLimitedStreams array if it is not already there
              //look in participants array for the participant with the screenID same as screenId
              let screenParticipant = await participants.filter(
                (participant) => participant.ScreenID == screenId
              );

              if (screenParticipant.length > 0) {
                // get the videoID of the screenParticipant
                let screenParticipantVidID = await screenParticipant[0].videoID;
                // check if the screenParticipantVidID is already in the newLimitedStreams array and not null
                let screenParticipantVidID_ = await newLimitedStreams.filter(
                  (stream) => stream.producerId == screenParticipantVidID
                );
                if (
                  screenParticipantVidID_.length < 1 &&
                  screenParticipantVidID != null
                ) {
                  screenShareIDStream = screenParticipantVidID;
                  screenShareNameStream = screenParticipant[0].name;
                  // add the screenParticipantVidID to the newLimitedStreams array
                  let screenParticipantVidID__ = await allVideoStreams.filter(
                    (stream) => stream.producerId == screenParticipantVidID
                  );
                  newLimitedStreams = await [
                    ...newLimitedStreams,
                    ...screenParticipantVidID__,
                  ];
                  newLimitedStreamsIDs = await [
                    ...newLimitedStreamsIDs,
                    ...screenParticipantVidID__.map(
                      (stream) => stream.producerId
                    ),
                  ];
                }
              }
            }

            //reflect the changes on the ui
            await changeVids(screenChanged);
          }

          socket.on("userWaiting", async ({ name }) => {
            //update with name of the participant that joined the waiting room
            //name is the name of the participant that joined the waiting room

            showAlert(`${name} joined the waiting room.`, "danger", 2000);

            //update requests-count
            let totalReq = totalRequests + waitingParticipants.length;
            $(".request-count").text(totalReq);
          });

          socket.on("personJoined", async ({ name }) => {
            //update with name of the participant that joined the event
            //name is the name of the participant that joined the event

            showAlert(`${name} joined the event.`, "success", 2000);
          });

          socket.on("allWaitingRoomMembers", async (waiting_data) => {
            //update waitingParticipants array
            //waitingParticipantss is the updated waitingParticipants array

            let { waitingParticipantss } = waiting_data;
            if (!waitingParticipantss) {
              waitingParticipantss = waiting_data.waitingParticipants;
            }

            waitingParticipants = waitingParticipantss;
            let totalReq = totalRequests + waitingParticipants.length;
            $(".request-count").text(totalReq);
          });

          const getRecordParams = async (recordParams) => {
            //get record params for the event
            (recordingAudioPausesLimit =
              recordParams.recordingAudioPausesLimit),
              (recordingAudioPausesCount =
                recordParams.recordingAudioPausesCount),
              (recordingAudioSupport = recordParams.recordingAudioSupport),
              (recordingAudioPeopleLimit =
                recordParams.recordingAudioPeopleLimit),
              (recordingAudioParticipantsTimeLimit =
                recordParams.recordingAudioParticipantsTimeLimit),
              (recordingVideoPausesCount =
                recordParams.recordingVideoPausesCount),
              (recordingVideoPausesLimit =
                recordParams.recordingVideoPausesLimit),
              (recordingVideoSupport = recordParams.recordingVideoSupport),
              (recordingVideoPeopleLimit =
                recordParams.recordingVideoPeopleLimit),
              (recordingVideoParticipantsTimeLimit =
                recordParams.recordingVideoParticipantsTimeLimit),
              (recordingAllParticipantsSupport =
                recordParams.recordingAllParticipantsSupport),
              (recordingVideoParticipantsSupport =
                recordParams.recordingVideoParticipantsSupport),
              (recordingAllParticipantsFullRoomSupport =
                recordParams.recordingAllParticipantsFullRoomSupport),
              (recordingVideoParticipantsFullRoomSupport =
                recordParams.recordingVideoParticipantsFullRoomSupport),
              (recordingPreferredOrientation =
                recordParams.recordingPreferredOrientation),
              (recordingSupportForOtherOrientation =
                recordParams.recordingSupportForOtherOrientation),
              (recordingMultiFormatsSupport =
                recordParams.recordingMultiFormatsSupport);
          };

          socket.on("ban", async ({ name }) => {
            //ban a participant
            //name is the name of the participant to be banned

            if (activeNames.includes(name) || dispActiveNames.includes(name)) {
              participants = await participants.filter(
                (participant) => participant.name != name
              );
              await reorderStreams(false, true);
            }
          });

          socket.on("allMembers", async (data_members) => {
            //updated members array; relevant to the host
            //members is the updated members array
            //requests is the updated requests array
            //coHost is the updated coHost
            //coHostResponsibilities is the updated coHostResponsibility

            // operations to update the ui

            let requestss = data_members.requests;
            let coHoste = data_members.coHost;
            let coHostRes = data_members.coHostResponsibilities;
            let members = data_members.members;

            //filter out the participant that isBanned == true
            participantsAll = await members;
            //remove every field other than isBanned and name from participantsAll
            participantsAll = await participantsAll.map((participant) => ({
              isBanned: participant.isBanned,
              name: participant.name,
            }));

            participants = await members.filter(
              (participant) => participant.isBanned == false
            );

            if (eventType == "broadcast") {
              let participantCounter = await document.getElementById(
                "reactParticipant-counter"
              );
              if (participantCounter) {
                let formattedNumber = await formatNumber(participants.length);
                participantCounter.innerHTML =
                  (await formattedNumber) +
                  ' <i class="fas fa-chart-bar fa-rotate-270 fa-lg"></i>';
              }
            }

            //check if dispActivenames is not empty and contains the name of the participant that is not in the participants array
            if (dispActiveNames.length > 0) {
              //check if the participant that is not in the participants array is in the dispActiveNames array
              let dispActiveNames_ = await dispActiveNames.filter(
                (name) =>
                  !participants
                    .map((participant) => participant.name)
                    .includes(name)
              );
              if (dispActiveNames_.length > 0) {
                //remove the participant that is not in the participants array from the dispActiveNames array
                await reorderStreams(false, true);
              }
            }

            //operations to update the ui; make sure we are connected to the server before updating the ui
            // allMembers might get called before we are connected to the server

            if (screenId != null) {
              let host = await participants.find(
                (participant) =>
                  participant.ScreenID == screenId &&
                  participant.ScreenOn == true
              );
              if (deferScreenReceived && screenId != null && host) {
                shareScreenStarted = true;
              }
            }

            if (confHide) {
              await hideLoadingModal();
            } else {
              deferHide = true;
            }

            // return requests for only ids that are in the participants array and update the count badge, that is .request-count
            requests = requestss.filter((request) =>
              participants.some((participant) => participant.id == request.id)
            );

            coHost = coHoste;
            coHostResponsibility = coHostRes;

            separateRequests();
            totalRequests = requests.length;

            try {
              if (!lock_screen && !firstAll) {
                await onScreenChanges(); //true

                if (meetingDisplayType != "all") {
                  firstAll = true;
                }
              } else {
                if (islevel == "2") {
                  if (!hostFirstSwitch) {
                    await onScreenChanges();
                    hostFirstSwitch = true; //get self display
                  }
                }
              }
            } catch (error) {}

            if (!membersReceived) {
              membersReceived = true;
              await createReceiveAllTransports(socket);
            }
          });

          socket.on("allMembersRest", async (data_members) => {
            //updated members array; relevant to the others (not host)
            //members is the updated members array
            //settings is the updated settings array (for room media settings, allow audio, video, screenshare, chat, etc)
            //coHost is the updated coHost
            //coHostResponsibilities is the updated coHostResponsibility

            let coHoste = data_members.coHost;
            let coHostRes = data_members.coHostResponsibilities;
            let members = data_members.members;
            let settings = data_members.settings;

            // operations to update the ui
            participantsAll = members;
            //remove every field other than isBanned and name from participantsAll
            participantsAll = participantsAll.map((participant) => ({
              isBanned: participant.isBanned,
              name: participant.name,
            }));

            participants = members.filter(
              (participant) => participant.isBanned == false
            );

            if (eventType == "broadcast") {
              let participantCounter = document.getElementById(
                "reactParticipant-counter"
              );
              if (participantCounter) {
                let formattedNumber = formatNumber(participants.length);
                participantCounter.innerHTML =
                  formattedNumber +
                  ' <i class="fas fa-chart-bar fa-rotate-270 fa-lg"></i>';
              }
            }

            //operations to update the ui; make sure we are connected to the server before updating the ui
            // allMembers might get called before we are connected to the server
            if (screenId != null) {
              let host = participants.find(
                (participant) =>
                  participant.ScreenID == screenId &&
                  participant.ScreenOn == true
              );
              if (deferScreenReceived && screenId != null && host) {
                shareScreenStarted = true;
              }
            }

            if (dispActiveNames.length > 0) {
              //check if the participant that is not in the participants array is in the dispActiveNames array
              let dispActiveNames_ = await dispActiveNames.filter(
                (name) =>
                  !participants
                    .map((participant) => participant.name)
                    .includes(name)
              );
              if (dispActiveNames_.length > 0 && membersReceived) {
                //remove the participant that is not in the participants array from the dispActiveNames array
                await reorderStreams(false, true);
              }
            }

            if (confHide) {
              await hideLoadingModal();
            } else {
              deferHide = true;
            }

            // return requests for only ids that are in the participants array
            requests = requests.filter((request) =>
              participants.some((participant) => participant.id == request.id)
            );

            coHost = coHoste;
            coHostResponsibility = coHostRes;

            try {
              if (!lock_screen && !firstAll) {
                await onScreenChanges(); //true
                // firstAll = true // true for only videos in front display
              }
              if (meetingDisplayType != "all") {
                firstAll = true;
              }
            } catch (error) {}

            try {
              if (membersReceived) {
                audioSetting = settings[0];
                videoSetting = settings[1];
                screenshareSetting = settings[2];
                chatSetting = settings[3];
              }
            } catch (error) {}

            if (!membersReceived) {
              membersReceived = true;
              await createReceiveAllTransports(socket);
            }
          });

          socket.on("updatedCoHost", async (cohost_data) => {
            //updated coHost
            //coHost is the updated coHost
            //coHostResponsibilities is the updated coHostResponsibility

            let coHoste = cohost_data.coHost;
            let coHostRes = cohost_data.coHostResponsibilities;

            if (eventType != "broadcast" && eventType != "chat") {
              //only update the coHost if the event type is not broadcast or chat

              coHost = coHoste;
              coHostResponsibility = coHostRes;

              if (member == coHost) {
                if (!youAreCoHost) {
                  youAreCoHost = true;
                  showAlert(`You are now a co-host.`, "success", 1500);
                  // find request-count and show it
                  $(".request-count").show();
                }
              } else {
                youAreCoHost = false;

                if (islevel != "2") {
                  $(".request-count").hide();
                }
              }
            } else {
              if (islevel != "2") {
                youAreCoHost = true;
              }
            }
          });

          socket.on("participantRequested", async ({ userRequest }) => {
            //userRequest is the request of the participant

            //operations to update the ui
            //add the userRequest to the requests array
            //check if the userRequest is not already in the requests array
            if (
              requests.some(
                (request) =>
                  request.id == userRequest.id &&
                  request.icon == userRequest.icon &&
                  request.name == userRequest.name
              )
            ) {
            } else {
              requests = [...requests, userRequest];
            }
            //update the count badge, that is .request-count
            requestCount = requests.length;

            let reqCount = requestCount + waitingParticipants.length;

            $(".request-count").text(reqCount);
            //if islevel !=2 then hide .request-count
            if (islevel != "2") {
              if (coHost != member) {
                $(".request-count").hide();
              } else {
                $(".request-count").show();
                const menuAccess = document.querySelector("#menuAccess");
                menuAccess.classList.add("active");
                setTimeout(function () {
                  menuAccess.classList.remove("active");
                }, 3000);
              }
            } else {
              //get the menuAccess button
              const menuAccess = document.querySelector("#menuAccess");
              menuAccess.classList.add("active");
              setTimeout(function () {
                menuAccess.classList.remove("active");
              }, 3000);
            }
          });

          socket.on("hostRequestResponse", async ({ requestResponse }) => {
            //requestResponse is the response of the host to the request of the participant

            // check the action of the admin and if accept, allow the action
            //notify the user if the action was accepted or not
            requests = requests.filter(
              (request) =>
                request.id !== requestResponse.id &&
                request.icon !== requestResponse.type &&
                request.name !== requestResponse.name &&
                request.username !== requestResponse.username
            );
            requestType = requestResponse.type;

            if (requestResponse.action == "accepted") {
              if (requestType == "fa-microphone") {
                //tell the user that the unmute request was accepted
                showAlert(
                  "Unmute request was accepted; click the mic button again to begin.",
                  "success",
                  15000
                );
                micAction = true;
                audioRequestState = "accepted";
              } else if (requestType == "fa-video") {
                //tell the user that the video request was not accepted
                showAlert(
                  "Video request was accepted; click the video button again to begin.",
                  "success",
                  15000
                );
                videoAction = true;
                videoRequestState = "accepted";
              } else if (requestType == "fa-desktop") {
                //tell the user that the screenshare request was not accepted
                showAlert(
                  "Screenshare request was accepted; click the screenshare button again to begin.",
                  "success",
                  15000
                );
                screenAction = true;
                screenRequestState = "accepted";
              } else if (requestType == "fa-comments") {
                //tell the user that the chat request was not accepted
                showAlert(
                  "Chat request was accepted; click the chat button again to begin.",
                  "success",
                  15000
                );
                chatAction = true;
                chatRequestState = "accepted";
              }
            } else {
              //notify the user that the action was not accepted, get the type of request and tell the user that the action was not accepted
              requestType = requestResponse.type;
              if (requestType == "fa-microphone") {
                //tell the user that the unmute request was not accepted

                showAlert("Unmute request was not accepted", "danger");
                audioRequestState = "rejected";
                //set audioRequestTimer to maker user wait for updateRequestIntervalSeconds seconds before requesting again
                audioRequestTimer = updateRequestIntervalSeconds;
                // set datetimenow to current time
                audioRequestTimeNow = new Date();
                //add updateRequestIntervalSeconds seconds to datetimenow
                audioRequestTimeNow.setSeconds(
                  audioRequestTimeNow.getSeconds() + audioRequestTimer
                );
                //set audioRequestTime to the new time
                audioRequestTime = audioRequestTimeNow;
              } else if (requestType == "fa-video") {
                //tell the user that the video request was not accepted
                showAlert("Video request was not accepted", "danger");
                videoRequestState = "rejected";
                //set videoRequestTimer to maker user wait for updateRequestIntervalSeconds seconds before requesting again from UTC time now
                videoRequestTimer = updateRequestIntervalSeconds;
                // set datetimenow to current time
                videoRequestTimeNow = new Date();
                //add updateRequestIntervalSeconds seconds to datetimenow
                videoRequestTimeNow.setSeconds(
                  videoRequestTimeNow.getSeconds() + videoRequestTimer
                );
                //set videoRequestTime to the new time
                videoRequestTime = videoRequestTimeNow;
              } else if (requestType == "fa-desktop") {
                //tell the user that the screenshare request was not accepted
                showAlert("Screenshare request was not accepted", "danger");
                screenRequestState = "rejected";
                //set screenRequestTimer to maker user wait for updateRequestIntervalSeconds seconds before requesting again
                screenRequestTimer = updateRequestIntervalSeconds;
                // set datetimenow to current time
                screenRequestTimeNow = new Date();
                //add updateRequestIntervalSeconds seconds to datetimenow
                screenRequestTimeNow.setSeconds(
                  screenRequestTimeNow.getSeconds() + screenRequestTimer
                );
                //set screenRequestTime to the new time
                screenRequestTime = screenRequestTimeNow;
              } else if (requestType == "fa-comments") {
                //tell the user that the chat request was not accepted
                showAlert("Chat request was not accepted", "danger");
                chatRequestState = "rejected";
                //set chatRequestTimer to maker user wait for updateRequestIntervalSeconds seconds before requesting again
                chatRequestTimer = updateRequestIntervalSeconds;
                // set datetimenow to current time
                chatRequestTimeNow = new Date();
                //add updateRequestIntervalSeconds seconds to datetimenow
                chatRequestTimeNow.setSeconds(
                  chatRequestTimeNow.getSeconds() + chatRequestTimer
                );
                //set chatRequestTime to the new time
                chatRequestTime = chatRequestTimeNow;
              }
            }
          });

          socket.on("screenProducerId", async ({ producerId }) => {
            //producerId is the producerId of the screen participant

            //check if members data has been received with the screenId participant in it
            let host = participants.find(
              (participant) =>
                participant.ScreenID == screenId && participant.ScreenOn == true
            );

            //operations to update the ui
            if (membersReceived && host) {
              screenId = producerId;
              shareScreenStarted = true;
              deferScreenReceived = false;
            } else {
              deferScreenReceived = true;
              screenId = producerId;
            }
          });

          //generic alert function
          function showAlert(message, state, duration = 4000) {
            $("#alertMessage").text(message);
            if (state === "success") {
              $("#alertModal")
                .find(".modal-body .alert")
                .removeClass("alert-danger")
                .addClass("alert-success");
            } else {
              $("#alertModal")
                .find(".modal-body .alert")
                .removeClass("alert-success")
                .addClass("alert-danger");
            }
            $("#alertModal").modal("show");
            setTimeout(function () {
              $("#alertModal").modal("hide");
            }, duration);
          }

          //check permission function
          async function checkPermission(permissionType) {
            //permissionType is audioSetting, videoSetting, screenshareSetting, chatSetting
            //do a switch case to check for the permissionType and return the response
            switch (permissionType) {
              case "audioSetting":
                if (audioSetting === "allow") {
                  return 0;
                } else if (audioSetting === "approval") {
                  return 1;
                } else {
                  return 2;
                }
                break;
              case "videoSetting":
                if (videoSetting === "allow") {
                  return 0;
                } else if (videoSetting === "approval") {
                  return 1;
                } else {
                  return 2;
                }
                break;
              case "screenshareSetting":
                if (screenshareSetting === "allow") {
                  return 0;
                } else if (screenshareSetting === "approval") {
                  return 1;
                } else {
                  return 2;
                }
                break;
              case "chatSetting":
                if (chatSetting === "allow") {
                  return 0;
                } else if (chatSetting === "approval") {
                  return 1;
                } else {
                  return 2;
                }
                break;
              default:
            }
          }

          $(document).on(
            "hide.bs.modal",
            "#reactParticipantsModal",
            async function () {
              isReactionParticipantModalShown = false;
              $("#react-participant-filter").val(""); // clear the filter
              $("#react-participant-filter").attr("placeholder", "Search ..."); // load the placeholder
            }
          );

          $(document).on(
            "show.bs.modal",
            "#reactParticipantsModal",
            async function () {
              isReactionParticipantModalShown = true;

              if (islevel == "2") {
                await populateParticipantList();
              }
            }
          );

          $(document).on("hide.bs.modal", "#reactionModal", async function () {
            isReactionModalShown = false;
          });

          $(document).on("show.bs.modal", "#reactionModal", async function () {
            const groupMessages = await messages.filter(
              (message) => message.group == true
            );
            await renderMessages(groupMessages, "group", member);
            isReactionModalShown = true;
          });

          $(document).on(
            "hide.bs.modal",
            "#shareEventModal",
            async function () {
              isShareEventModalShown = false;
            }
          );

          $(document).on(
            "show.bs.modal",
            "#shareEventModal",
            async function () {
              isShareEventModalShown = true;
            }
          );

          loadVidAud();

          async function loadVidAud() {
            // Event listener for the "Recording Modal" show event

            $("#confirmRecButton").on("click", function () {
              // Retrieve the values from the input fields and select elements
              let displayType = $("#displayType").val();
              let nameTags = $("#nameTags").val();
              let backgroundColor = $("#backgroundColor").val();
              let nameTagsColor = $("#nameTagsColor").val();
              let orientationVideo = $("#orientationVideo").val();
              let hlsadd = $("#addHLS").val();
              let addText = $("#addText").val();
              let customText = $("#customText").val();
              let customTextPosition = $("#customTextPosition").val();
              let customTextColor = $("#customTextColor").val();

              let mediaOptions = $("#mediaOptions").val();
              let audioOptions = $("#audioOptions").val();
              let videoOptions;
              if (eventType != "conference") {
                videoOptions = $("#videoOptions").val();
              } else {
                videoOptions = "all";
              }

              var selectedRecordOption = $("#recordDisplayOptions").val();

              if (eventType == "broadcast") {
                audioOptions = "host";
                videoOptions = "mainScreen";
                selectedRecordOption = "";
              }

              if (selectedRecordOption === "videoOpt") {
                selectedRecordOption = "video";
                recordingVideoOptimized = true;
              } else {
                recordingVideoOptimized = false;
              }

              if (
                prevRecordingMediaOptions != mediaOptions &&
                !clearedToResume
              ) {
                showAlert(
                  "You have changed the media options. Please stick to the first one."
                );
                return;
              }

              confirmedToRecord = true;
              recordingDisplayType = selectedRecordOption;
              recordingNameTags = nameTags;
              recordingBackgroundColor = backgroundColor;
              recordingNameTagsColor = nameTagsColor;
              recordingOrientationVideo = orientationVideo;
              recordingMediaOptions = mediaOptions;
              recordingAudioOptions = audioOptions;
              recordingVideoOptions = videoOptions;
              recordingVideoType = displayType;
              recordingAddHLS = hlsadd;
              recordingAddText = addText;
              recordingCustomText = customText;
              recordingCustomTextPosition = customTextPosition;
              recordingCustomTextColor = customTextColor;

              // recordingVideoParticipantsFullRoomSupport = minigrid and main video
              if (eventType != "broadcast") {
                if (
                  !recordingVideoParticipantsFullRoomSupport &&
                  recordingVideoOptions == "all" &&
                  mediaOptions == "video"
                ) {
                  if (meetingDisplayType == "all") {
                    if (breakOutRoomStarted && !breakOutRoomEnded) {
                    } else {
                      showAlert(
                        "You are not allowed to record videos of all participants; change the meeting display type to video or video optimized."
                      );
                      return;
                    }
                  }
                }

                // recordingAllParticipantsSupport  = others other than host screen (video + audio)
                if (
                  !recordingAllParticipantsSupport &&
                  recordingVideoOptions == "all"
                ) {
                  showAlert("You are only allowed to record yourself.");
                  return;
                }

                // recordingVideoParticipantsSupport (maingrid + non-host screenshare person)
                if (
                  !recordingVideoParticipantsSupport &&
                  recordingDisplayType == "video"
                ) {
                  showAlert(
                    "You are not allowed to record other video participants."
                  );
                  return;
                }
              }

              if (
                !recordingSupportForOtherOrientation &&
                recordingOrientationVideo == "all"
              ) {
                showAlert("You are not allowed to record all orientations.");
                return;
              }

              if (
                recordingPreferredOrientation == "landscape" &&
                recordingOrientationVideo == "portrait" &&
                !recordingSupportForOtherOrientation
              ) {
                showAlert(
                  "You are not allowed to record portrait orientation."
                );
                return;
              } else if (
                recordingPreferredOrientation == "portrait" &&
                recordingOrientationVideo == "landscape" &&
                !recordingSupportForOtherOrientation
              ) {
                showAlert(
                  "You are not allowed to record landscape orientation."
                );
                return;
              }

              if (
                !recordingMultiFormatsSupport &&
                recordingVideoType == "all"
              ) {
                showAlert("You are not allowed to record all formats.");
                return;
              }

              if (eventType != "broadcast") {
                if (recordingMediaOptions == "video") {
                  if (meetingDisplayType === "media") {
                    if (recordingDisplayType === "all") {
                      showAlert(
                        "Recording display type can be either video, video optimized or media when meeting display type is media."
                      );
                      recordingDisplayType = meetingDisplayType;
                      return;
                    }
                  } else if (meetingDisplayType === "video") {
                    if (
                      recordingDisplayType === "all" ||
                      recordingDisplayType === "media"
                    ) {
                      showAlert(
                        "Recording display type can be either video or video optimized when meeting display type is video."
                      );
                      recordingDisplayType = meetingDisplayType;
                      return;
                    }

                    if (meetingVideoOptimized && !recordingVideoOptimized) {
                      showAlert(
                        "Recording display type can be only video optimized when meeting display type is video optimized."
                      );
                      recordingVideoOptimized = meetingVideoOptimized;
                      return;
                    }
                  }
                } else {
                  if (
                    recordingDisplayType === "all" ||
                    recordingDisplayType === "media"
                  ) {
                  } else {
                    recordingDisplayType = "media";
                  }
                  recordingVideoOptimized = false;
                }
              }

              if (
                recordingDisplayType == "all" &&
                !recordingAllParticipantsFullRoomSupport
              ) {
                showAlert("You can only record all participants with media");
                return;
              }

              let mainSpecs = {
                mediaOptions: recordingMediaOptions,
                audioOptions: recordingAudioOptions,
                videoOptions: recordingVideoOptions,
                videoType: recordingVideoType,
                videoOptimized: recordingVideoOptimized,
                recordingDisplayType: recordingDisplayType,
                addHLS: recordingAddHLS,
              };
              let dispSpecs = {
                nameTags: recordingNameTags,
                backgroundColor: recordingBackgroundColor,
                nameTagsColor: recordingNameTagsColor,
                orientationVideo: recordingOrientationVideo,
              };

              let textSpecs = {
                addText: recordingAddText,
                customText: recordingCustomText,
                customTextPosition: recordingCustomTextPosition,
                customTextColor: recordingCustomTextColor,
              };

              userRecordingParams = {
                mainSpecs: mainSpecs,
                dispSpecs: dispSpecs,
                textSpecs: textSpecs,
              };
            });

            $("#startRecButton").on("click", function () {
              if (!confirmedToRecord) {
                showAlert(
                  "Please confirm your settings before starting the recording."
                );
                return;
              }

              if (recordingMediaOptions == "video" && !videoAlreadyOn) {
                showAlert(
                  "Please turn on your video before starting the video recording."
                );
                return;
              }

              if (recordingMediaOptions == "audio" && !audioAlreadyOn) {
                showAlert(
                  "Please turn on your audio before starting the audio recording."
                );
                return;
              }

              // Retrieve the values from the input fields and select elements
              clearedToRecord = true;

              // Close the modal or perform any other desired action
              $("#recordingModal").modal("hide");
            });

            //action for video button
            $(".videoStated").click(async function () {
              if (audioOnlyRoom) {
                showAlert(
                  "You cannot turn on your camera in an audio only event.",
                  "danger"
                );
                return;
              }

              if (videoAlreadyOn) {
                //check and alert before turning off
                if (islevel == "2" && (recordStarted || recordResumed)) {
                  if (!(recordPaused || recordStopped)) {
                    if (recordingMediaOptions == "video") {
                      showAlert(
                        "You cannot turn off your camera while recording video; pause or stop the recording to continue.",
                        "danger"
                      );
                      return;
                    }
                  }
                }

                $(".videoStated").html(
                  '<button style="background-color: transparent;border: 0; font-size: medium;" id="videoState" class="videoStated"> <i class="fas fa-video-slash fa-lg border-0"  > </i>  </button>'
                );

                videoAlreadyOn = false;
                //localStreamVideo.getVideoTracks()[0].enabled = false;
                localStream.getVideoTracks()[0].enabled = false;
                await disconnectSendTransportVideo();
                if (p_sockets.length > 0) {
                  try {
                    await disconnectSendTransportVideo(true);
                  } catch (error) {}
                }
              } else {
                if (adminRestrictSetting) {
                  //return with access denied by admin
                  showAlert("Access denied by host", "danger");
                  return;
                }

                let response = 2;

                if (!videoAction && islevel != "2" && !youAreCoHost) {
                  //check if video permission is set to approval
                  response = await checkPermission("videoSetting");

                  if (response == 1) {
                    //approval

                    //check if request is pending or not
                    if (videoRequestState === "pending") {
                      showAlert("A request is already pending", "danger");
                      return;
                    }
                    // check if rejected and current time is less than videoRequestTime
                    if (
                      videoRequestState === "rejected" &&
                      Date.now() - videoRequestTime < 1
                    ) {
                      showAlert(
                        "A request has been rejected. Please try again later",
                        "danger"
                      );
                      return;
                    }

                    // send request to host
                    showAlert("A request has been sent to the host", "success");
                    videoRequestState = "pending";
                    //create a request and add to the request list and send to host

                    //create a request and add to the request list and send to host
                    let userRequest = {
                      id: socket.id,
                      name: member,
                      icon: "fa-video",
                      username: member,
                    };
                    await socket.emit("participantRequest", {
                      userRequest,
                      roomName,
                    });
                  } else if (response == 2) {
                    //if video permission is set to deny then show alert
                    showAlert(
                      "You are not allowed to turn on your video.",
                      "danger"
                    );
                    return;
                  }
                } else {
                  response = 0;
                }

                if (response == 0) {
                  let constraints = {
                    video: {
                      deviceId: userDefaultVideoInputDevice,
                      ...vidCons,
                      frameRate: { ideal: frameRate },
                      facingMode: currentFacingMode,
                    },
                    audio: false,
                  };

                  await navigator.mediaDevices
                    .getUserMedia(constraints)
                    .then(streamSuccessVideo)
                    .catch(async (error) => {
                      constraints = {
                        video: {
                          ...vidCons,
                          frameRate: { ideal: frameRate },
                        },
                        audio: false,
                      };
                      await navigator.mediaDevices
                        .getUserMedia(constraints)
                        .then(streamSuccessVideo)
                        .catch(async (error) => {
                          constraints = {
                            video: {
                              ...vidCons,
                            },
                            audio: false,
                          };
                          await navigator.mediaDevices
                            .getUserMedia(constraints)
                            .then(streamSuccessVideo)
                            .catch((error) => {
                              showAlert(
                                "Allow access to your camera.",
                                "danger"
                              );
                            });
                        });
                    });
                } else {
                  return;
                }
              }
            });

            //action for mic button
            $(".micStated").click(async function () {
              if (audioAlreadyOn) {
                if (islevel == "2" && (recordStarted || recordResumed)) {
                  if (!(recordPaused || recordStopped)) {
                    if (recordingMediaOptions == "audio") {
                      showAlert(
                        "You cannot turn off your audio while recording audio; pause or stop the recording to continue.",
                        "danger"
                      );
                      return;
                    }
                  }
                }

                // localStreamAudio.getAudioTracks()[0].enabled = false;
                localStream.getAudioTracks()[0].enabled = false;

                $(this).html(
                  '<button style="background-color: transparent;border: 0; font-size: medium;" id="micState" class="micStated"> <i class="fas fa-microphone-slash fa-lg border-0"  > </i>  </button>'
                );

                audioAlreadyOn = false;
                await disconnectSendTransportAudio();
                if (p_sockets.length > 0) {
                  try {
                    await disconnectSendTransportAudio(true);
                  } catch (error) {}
                }
                audioPaused = true;
              } else {
                if (adminRestrictSetting) {
                  //return with access denied by admin
                  showAlert("Access denied by host", "danger");
                  return;
                }

                if (!micAction && islevel != "2" && !youAreCoHost) {
                  //check and turn on audio
                  response = await checkPermission("audioSetting");
                } else {
                  response = 0;
                }
                //do switch case to check for response

                switch (response) {
                  case 0:
                    //allow
                    if (audioPaused) {
                      localStream.getAudioTracks()[0].enabled = true;
                      audioAlreadyOn = true;
                      await resumeSendTransportAudio();
                      await socket.emit("resumeProducerAudio", {
                        mediaTag: "audio",
                        roomName: roomName,
                      });

                      if (p_sockets.length > 0) {
                        try {
                          await resumeSendTransportAudio(true);
                          await p_sockets[0].emit("resumeProducerAudio", {
                            mediaTag: "audio",
                            roomName: roomName,
                          });
                        } catch (error) {}
                      }

                      $(".micStated").html(
                        '<button style="background-color: transparent;border: 0; font-size: medium;" id="micState" class="micStated"> <i class="fas fa-microphone fa-lg border-0"  > </i>  </button>'
                      );

                      if (micAction == true) {
                        micAction = false;
                      }

                      await participants.forEach((participant) => {
                        if (
                          participant.socketId == socket.id &&
                          participant.name == member
                        ) {
                          participant.muted = false;
                        }
                      });

                      transportCreated = true;

                      transportCreatedAudio = true;
                    } else {
                      await navigator.mediaDevices
                        .getUserMedia({
                          audio: { deviceId: userDefaultAudioInputDevice },
                          video: false,
                        })
                        .then(streamSuccessAudio)
                        .catch((error) => {
                          showAlert(
                            "Allow access to your microphone.",
                            "danger"
                          );
                        });
                    }

                    break;
                  case 1:
                    //approval

                    //check if request is pending or not
                    if (audioRequestState === "pending") {
                      showAlert("A request is already pending", "danger");
                      return;
                    }
                    // check if rejected and current time is less than audioRequestTime
                    if (
                      audioRequestState === "rejected" &&
                      Date.now() - audioRequestTime < requestIntervalSeconds
                    ) {
                      showAlert(
                        "A request has been rejected. Please try again later",
                        "danger"
                      );
                      return;
                    }

                    // send request to host
                    showAlert("A request has been sent to the host", "success");
                    audioRequestState = "pending";

                    //create a request and add to the request list and send to host
                    let userRequest = {
                      id: socket.id,
                      name: member,
                      icon: "fa-microphone",
                      username: member,
                    };
                    await socket.emit("participantRequest", {
                      userRequest,
                      roomName,
                    });

                    break;
                  case 2:
                    //disallow
                    showAlert("You are not allowed to turn on audio", "danger");
                    break;
                  default:
                }
              }
            });

            // Add event listener to the switchCamera button
            $(".switchCamera").on("click", async function () {
              if (audioOnlyRoom) {
                showAlert(
                  "You cannot turn on your camera in an audio only event.",
                  "danger"
                );
                return;
              }

              let checkoff = false;

              if (
                (recordStarted || recordResumed) &&
                !recordStopped &&
                !recordPaused
              ) {
                if (recordingMediaOptions == "video") {
                  checkoff = true;
                }
              }

              if (!allowed) {
                showAlert(
                  "Allow access to your camera by starting it for the first time.",
                  "danger"
                );
                return;
              }

              if (checkoff) {
                if (videoAlreadyOn) {
                  showAlert(
                    "Please turn off your video before switching.",
                    "danger"
                  );
                  return;
                }
              } else {
                if (!videoAlreadyOn) {
                  showAlert(
                    "Please turn on your video before switching.",
                    "danger"
                  );
                  return;
                }
              }

              //camera switching logic here
              prevFacingMode = await currentFacingMode;
              if (currentFacingMode === "environment") {
                currentFacingMode = "user";
              } else {
                currentFacingMode = "environment";
              }

              await switchUserVideoAlt(currentFacingMode, checkoff);
              $("#mediaSettingsModal").modal("hide");
            });

            //action for record button
            $(".recordStated").click(async function () {
              if (stopLaunchRecording) {
                showAlert(
                  "You are not allowed to record or record has been stopped",
                  "danger"
                );
                return;
              }

              if (launchRecording) {
                // check recording support
                // if (!recordingAudioSupport && !recordingVideoSupport) {
                //     showAlert('You are not allowed to record');
                //     return;
                // }

                if (1 == 1) {
                  //(allowed && canRecord)
                  canRecord = false;
                  canDownload = false;

                  clearedToRecord = false;
                  //change the button icon

                  $("#recordingModal").modal("show");
                } else if (allowed && !canRecord) {
                  canRecord = true;

                  if (eventType != "broadcast") {
                    $(".recordStated").html(
                      '<button class="list-group-item list-group-item-action recordStated" style="background-color: transparent;border: 0; font-size: medium;padding-left: 0; margin-left: 0;" id="recordState" > <i class="fas fa-stop-circle fa-lg border-0 mr-2"  > </i>Record</button>'
                    );
                  } else {
                    $(".recordStated").html(
                      `<button  style="background-color: transparent;border: 0; font-size: large; position: absolute; left: 50%; transform: translateX(-50%); bottom: 5px;" class="recordStated">  <i class="fas fa-record-vinyl fa-lg"></i> Record </button>`
                    );
                  }
                } else if (!allowed) {
                  showAlert("You are not allowed to record without video on");
                }
              }
            });
          }

          //action for screen button
          $("#screenshareState").click(async function () {
            if (audioOnlyRoom) {
              showAlert(
                "You cannot share screen in an audio only event.",
                "danger"
              );
              return;
            }

            if (screenAlreadyOn) {
              await $(this).html(
                '<button style="background-color: transparent;border: 0; font-size: medium;position: relative;" id="screenshareState"> <span class="fa-stack fa-md border-0" ><i class="fas fa-desktop fa-stack-1x border-0"></i><i class="fas fa-ban fa-stack-2x border-0" style="color:Tomato"></i></span> </button>'
              );
              screenAlreadyOn = false;
              await stopShareScreen();
            } else {
              if (adminRestrictSetting) {
                //return with access denied by admin
                showAlert("Access denied by host", "danger");
                return;
              }

              //check and turn on screen
              if (!screenAction && islevel != "2" && !youAreCoHost) {
                response = await checkPermission("screenshareSetting");
              } else {
                response = 0;
              }

              //do switch case to check for response
              switch (response) {
                case 0:
                  //allow
                  checkScreenShare();
                  break;
                case 1:
                  //approval
                  //check if request is pending or not
                  if (screenRequestState === "pending") {
                    showAlert("A request is already pending", "danger");
                    return;
                  }
                  // check if rejected and current time is less than screenRequestTime
                  if (
                    screenRequestState === "rejected" &&
                    Date.now() - screenRequestTime < requestIntervalSeconds
                  ) {
                    showAlert(
                      "A request has been rejected. Please try again later",
                      "danger"
                    );
                    return;
                  }
                  // send request to host
                  showAlert("A request has been sent to the host", "success");
                  screenRequestState = "pending";
                  //create a request and add to the request list and send to host
                  userRequest = {
                    id: socket.id,
                    name: member,
                    icon: "fa-desktop",
                    username: member,
                  };
                  await socket.emit("participantRequest", {
                    userRequest,
                    roomName,
                  });
                  break;
                case 2:
                  //disallow
                  showAlert("You are not allowed to share screen", "danger");
                  break;
                default:
              }
            }
          });

          //action for chat button
          $("#chatState").click(function () {
            if (chatAlreadyOn) {
              $(this).html(
                '<i class="fas fa-comment-dots fa-lg border-0"  > </i>'
              );
              chatAlreadyOn = false;
              //hide chat
              $("#chat").hide();
            } else {
              $(this).html(
                '<i class="fas fa-comment-slash fa-lg border-0"  > </i>'
              );
              chatAlreadyOn = true;
              //show chat
              $("#chat").show();
            }
          });

          //set initial heights
          let windowHeight = $(window).innerHeight();
          if (isBrowserBarHidden()) {
            windowHeight = $(document).height();
          }

          let height95 = 0.95 * windowHeight;
          let height5 = 0.05 * windowHeight;
          $("#mainAspect").css("height", height95);
          $("#subAspect").css("height", height5);

          if (eventType == "broadcast" || eventType == "chat") {
            //remove element with id of controlButtons
            let addForBasic = false;

            if (eventType == "broadcast") {
              addForBasic = true;
              $(".othergrid").remove();
              itemPageLimit = 1;

              let height100 = 1 * windowHeight;

              $("#mainAspect").css("height", height100);
              $(".maingrid").css("height", height100);
            } else {
              moveBoard();
              $(".maingrid").remove();
              itemPageLimit = 2;
            }

            $("#subAspect").remove();

            ///remove nay padding and margin on the mainAspect
            $("#mainAspect").css("padding", 0);
            $("#mainAspect").css("margin", 0);

            //remove element with id of controlButtons
            $("#controlButtons").remove();

            addFloatingMediaButtons(addForBasic);
          } else if (eventType == "conference") {
            if (shareScreenStarted || shared) {
            } else {
              $(".othergrid").css("height", height95);
            }
          }

          async function allowUserIn(participantId, participantName, type) {
            //function to allow user in
            //participantId is the id of the participant
            //participantName is the name of the participant
            //type is the type of the response (true or false)

            await socket.emit("allowUserIn", {
              participantId,
              participantName,
              type,
              roomName,
            });
          }

          $(".btn-close-waitings").click(function () {
            $("#waitingRoomModal").modal("hide");
            $("#waitingroom-filter").val(""); // clear the filter
            $("#waitingroom-filter").attr("placeholder", "Search ..."); // load the placeholder
          });

          // Add event listener for search input of requests
          const waitingPeople = document.getElementById("waitingroom-filter");
          waitingPeople.addEventListener("keyup", filterWaitingRoomList);

          async function filterWaitingRoomList() {
            //function to filter participants
            const participantWaitingRoomList =
              document.getElementById("waitingroom-list");
            const participantWaitingRoomCounter =
              document.getElementById("waitings-counter");

            // Clear the participant list before repopulating it
            participantWaitingRoomList.innerHTML = "";
            participantWaitingRoomCounter.innerText = "";

            const filterInput = document.getElementById("waitingroom-filter");

            // Filter participants based on search query
            const filterQuery = filterInput.value.toLowerCase().trim();
            const filteredParticipants = waitingParticipants.filter(
              (participant) => {
                return participant.name.toLowerCase().includes(filterQuery);
              }
            );

            // Populate the participant list with the filtered participants
            populateWaitingRoomList(filteredParticipants);
          }

          async function populateWaitingRoomList(waitingParticipants) {
            const waitingRoomList = document.getElementById("waitingroom-list");
            const waitingRoomCounter =
              document.getElementById("waitings-counter");

            // Clear the waiting room list and counter before repopulating them
            waitingRoomList.innerHTML = "";
            waitingRoomCounter.innerText = "";

            // Loop through the waiting room participants array and create a row for each participant
            for (let i = 0; i < waitingParticipants.length; i++) {
              const participant = waitingParticipants[i];

              // Create a row element
              const row = document.createElement("div");
              row.classList.add("row", "mb-2");

              // Create a column for the name
              const nameCol = document.createElement("div");
              nameCol.classList.add("col-7", "text-left");
              nameCol.innerText = participant.name;

              row.appendChild(nameCol);

              // Create a column for the accept button
              const acceptCol = document.createElement("div");
              acceptCol.classList.add("col-2", "text-left");
              const acceptButton = document.createElement("button");
              acceptButton.classList.add("btn", "btn-sm", "btn-success");
              acceptButton.innerHTML = '<i class="fas fa-check"></i>';
              acceptButton.id = "acceptButton" + participant.name;
              acceptButton.addEventListener("click", function () {
                // Handle accept button click event
                // get the id of the participant
                let waitId = this.id;
                let participantName = waitId.replace("acceptButton", "");
                let participantt_ = waitingParticipants.find(
                  (participant) => participant.name === participantName
                );
                if (participantt_) {
                  // send signal to allow participant in
                  var participantId = participantt_.id;
                  allowUserIn(participantId, participantName, "true");
                }

                // remove the participant from the waiting room list
                waitingParticipants = waitingParticipants.filter(
                  (participant) => participant.name !== participantName
                );

                // remove the item from the waiting room list
                populateWaitingRoomList(waitingParticipants);
              });
              acceptCol.appendChild(acceptButton);
              row.appendChild(acceptCol);

              // Create a column for the reject button
              const rejectCol = document.createElement("div");
              rejectCol.classList.add("col-2", "text-right");
              const rejectButton = document.createElement("button");
              rejectButton.classList.add("btn", "btn-sm", "btn-danger");
              rejectButton.innerHTML = '<i class="fas fa-times"></i>';
              rejectButton.id = "rejectButton" + participant.name;
              rejectButton.addEventListener("click", function () {
                // Handle reject button click event
                // get the id of the participant
                let waitId = this.id;
                let participantName = waitId.replace("rejectButton", "");
                let participantt_ = waitingParticipants.find(
                  (participant) => participant.name === participantName
                );
                if (participantt_) {
                  // send signal to allow participant in
                  let participantId = participantt_.id;
                  allowUserIn(participantId, participantName, "false");
                }

                // remove the participant from the waiting room list
                waitingParticipants = waitingParticipants.filter(
                  (participant) => participant.name !== participantName
                );
                // remove the item from the waiting room list
                populateWaitingRoomList(waitingParticipants);
              });
              rejectCol.appendChild(rejectButton);
              row.appendChild(rejectCol);

              const emptyCol = document.createElement("div");
              emptyCol.classList.add("col-1", "text-end");
              row.appendChild(emptyCol);

              // Add the row to the waiting room list
              waitingRoomList.appendChild(row);
            }

            // Update the waiting room counter
            waitingRoomCounter.innerText = waitingParticipants.length;
          }

          // Add an event listener to the modal so that it repopulates the participant list each time it's shown
          const waitingmodal = document.getElementById("waitingRoomModal");

          $(document).on(
            "show.bs.modal",
            "#waitingRoomModal",
            async function () {
              try {
                await populateWaitingRoomList(waitingParticipants);
              } catch (error) {}
            }
          );

          //  hiding the modal for waiting room
          $(document).on(
            "hide.bs.modal",
            "#waitingRoomModal",
            async function () {
              totalRequests =
                (await micRequests.length) +
                screenshareRequests.length +
                videoRequests.length +
                chatRequests.length;
              let totalReqs = totalRequests + waitingParticipants.length;

              $(".request-count").text(totalReqs);

              //if islevel !=2 then hide .request-count
              if (islevel != "2") {
                if (coHost != member) {
                  $(".request-count").hide();
                } else {
                  $(".request-count").show();
                }
              }
            }
          );

          // Function to populate the participant list
          function filterParticipantListOthers() {
            const participantList = document.getElementById("participant-list");
            const filterInput = document.getElementById("participant-filter");
            const participantCount = document.getElementById(
              "participant-counter"
            );

            // Clear the participant list before repopulating it
            participantList.innerHTML = "";

            // Filter participants based on search query
            const filterQuery = filterInput.value.toLowerCase().trim();
            const filteredParticipants = participants.filter((participant) => {
              return participant.name.toLowerCase().includes(filterQuery);
            });

            // Update participant count badge
            participantCount.innerText = filteredParticipants.length;

            // Loop through the filtered participants array and create a row for each participant
            for (let i = 0; i < filteredParticipants.length; i++) {
              const participant = filteredParticipants[i];

              // Create a row element
              const row = document.createElement("div");
              row.classList.add("row", "mb-2");

              // Create a column for the name
              const nameCol = document.createElement("div");
              nameCol.classList.add("col-8");
              nameCol.innerText = participant.name;
              row.appendChild(nameCol);

              // Create a column for the mic indicator
              const micCol = document.createElement("div");
              micCol.classList.add("col-3", "text-center");
              const micIndicator = document.createElement("i");
              micIndicator.classList.add(
                "fas",
                participant.muted ? "fa-dot-circle-o" : "fa-dot-circle",
                participant.muted ? "text-danger" : "text-success"
              );
              micCol.appendChild(micIndicator);
              row.appendChild(micCol);

              const emptyCol = document.createElement("div");
              emptyCol.classList.add("col-1", "text-end");
              row.appendChild(emptyCol);

              // Add the row to the participant list
              participantList.appendChild(row);
            }
          }

          // Function to populate the participant list
          function filterParticipantList() {
            let participantList;
            let filterInput;
            let participantCount;

            if (eventType == "broadcast") {
              participantList = document.getElementById(
                "react-participant-list"
              );
              filterInput = document.getElementById("react-participant-filter");
              participantCount = document.getElementById(
                "reactParticipant-counter"
              );
            } else {
              participantList = document.getElementById("participant-list");
              filterInput = document.getElementById("participant-filter");
              participantCount = document.getElementById("participant-counter");
            }

            // Clear the participant list before repopulating it
            participantList.innerHTML = "";

            // Filter participants based on search query
            const filterQuery = filterInput.value.toLowerCase().trim();
            const filteredParticipants = participants.filter((participant) => {
              return participant.name.toLowerCase().includes(filterQuery);
            });

            // Update participant count badge
            if (eventType != "broadcast") {
              participantCount.innerText = filteredParticipants.length;
            } else {
              let formattedNumber = formatNumber(filteredParticipants.length);
              participantCount.innerHTML =
                formattedNumber +
                ' <i class="fas fa-chart-bar fa-rotate-270 fa-lg"></i>';
            }

            // Loop through the filtered participants array and create a row for each participant
            for (let i = 0; i < filteredParticipants.length; i++) {
              const participant = filteredParticipants[i];

              // Create a row element
              const row = document.createElement("div");
              row.classList.add("row", "mb-2");

              // Create a column for the name
              const nameCol = document.createElement("div");
              nameCol.classList.add("col-4");
              if (participant.islevel == "2") {
                if (participant.name === member) {
                  // add (you) to the member name
                  nameCol.innerText = participant.name + " (you)";
                } else {
                  nameCol.innerText = participant.name + " (host)";
                }
              } else {
                if (participant.name === member) {
                  // add (you) to the member name
                  nameCol.innerText = participant.name + " (you)";
                } else {
                  if (coHost == participant.name) {
                    nameCol.innerText = participant.name + " (co-host)";
                  } else {
                    nameCol.innerText = participant.name;
                  }
                }
              }
              row.appendChild(nameCol);

              // Create a column for the mic indicator
              const micCol = document.createElement("div");
              micCol.classList.add("col-1", "text-center");
              if (eventType != "broadcast") {
                const micIndicator = document.createElement("i");
                micIndicator.classList.add(
                  "fas",
                  participant.muted ? "fa-dot-circle-o" : "fa-dot-circle-o",
                  participant.muted ? "text-danger" : "text-success"
                );
                micIndicator.id = "micIndicator" + participant.name;
                micCol.appendChild(micIndicator);
              }
              row.appendChild(micCol);

              // Create a column for the mute button
              const muteCol = document.createElement("div");
              muteCol.classList.add("col-2", "text-right");
              if (eventType != "broadcast") {
                const muteButton = document.createElement("button");
                muteButton.classList.add("btn", "btn-sm", "btn-primary");
                muteButton.innerHTML = participant.muted
                  ? '<i class="fas fa-microphone-slash"></i>'
                  : '<i class="fas fa-microphone"></i>';
                muteButton.id = "Audioo" + participant.name;
                muteButton.addEventListener("click", function () {
                  //check if participants in coHostResponsibility is true or false

                  let mediaValue = false;
                  try {
                    mediaValue = coHostResponsibility.find(
                      (item) => item.name === "media"
                    ).value;
                  } catch (error) {}

                  if (islevel == "2" || (coHost == member && mediaValue)) {
                    let audioIconId = this.id;
                    let participantName = audioIconId.replace("Audioo", "");
                    let participantt_ = participants.find(
                      (obj) => obj.name === participantName
                    );
                    if (!participantt_.muted && participantt_.islevel != "2") {
                      // send signal to control media to client
                      let participantId = participantt_.id;
                      controlMedia(participantId, participantName, "all");
                      let newIcon = '<i class="fas fa-microphone-slash"></i>';
                      document.getElementById(audioIconId).innerHTML = newIcon;

                      let micIndicatorId = "micIndicator" + participantName;
                      let micIndicator =
                        document.getElementById(micIndicatorId);
                      micIndicator.classList.remove(
                        "fa-dot-circle-o",
                        "text-success"
                      );
                      micIndicator.classList.add(
                        "fa-dot-circle-o",
                        "text-danger"
                      );
                    }
                  } else {
                    showAlert(
                      "You are not allowed to mute participants",
                      "danger"
                    );
                  }
                });
                muteCol.appendChild(muteButton);
              }
              row.appendChild(muteCol);

              // Create a column for the message button
              const messageCol = document.createElement("div");
              messageCol.classList.add("col-2", "text-right");
              if (eventType != "broadcast") {
                const messageButton = document.createElement("button");
                messageButton.classList.add("btn", "btn-sm", "btn-primary");
                messageButton.innerHTML = '<i class="fas fa-comment"></i>';
                messageButton.id = "MessageButton" + participant.name;
                messageButton.addEventListener("click", function () {
                  let messageButtonId = this.id;
                  let senderId = messageButtonId.replace("MessageButton", "");

                  let chatValue = false;
                  try {
                    chatValue = coHostResponsibility.find(
                      (item) => item.name === "chat"
                    ).value;
                  } catch (error) {}

                  const showModal = () => {
                    return new Promise((resolve) => {
                      $("#messageModal").on("shown.bs.modal", () => {
                        resolve();
                      });
                      $("#messageModal").modal("show");
                    });
                  };

                  if (islevel == "2" || (coHost == member && chatValue)) {
                    showModal().then(() => {
                      openReplyInput(senderId);
                    });
                  } else {
                    showAlert("You are not allowed to send message", "danger");
                  }
                });

                messageCol.appendChild(messageButton);
              }
              row.appendChild(messageCol);

              // Create a column for the remove button
              const removeCol = document.createElement("div");
              removeCol.classList.add("col-2", "text-end");
              const removeButton = document.createElement("button");
              removeButton.classList.add("btn", "btn-sm", "btn-danger");
              removeButton.innerHTML = '<i class="fas fa-trash-alt"></i>';
              removeButton.addEventListener("click", async function () {
                let participantsValue = false;
                try {
                  participantsValue = coHostResponsibility.find(
                    (item) => item.name === "participants"
                  ).value;
                } catch (error) {}
                if (islevel == "2" || (coHost == member && participantsValue)) {
                  participants.splice(i, 1);
                  //check if filter participants has the default placeholder text; if true populateParticipantList(); else filterParticipantList();
                  if (filterInput.value === "Search ...") {
                    if (islevel == "2") {
                      populateParticipantList();
                    } else {
                      populateParticipantListOthers();
                    }
                  } else {
                    if (islevel == "2") {
                      filterParticipantList();
                    } else {
                      filterParticipantListOthers();
                    }
                  }
                } else {
                  showAlert(
                    "You are not allowed to remove participants",
                    "danger"
                  );
                }
              });

              removeCol.appendChild(removeButton);
              row.appendChild(removeCol);

              const emptyCol = document.createElement("div");
              emptyCol.classList.add("col-1", "text-end");
              row.appendChild(emptyCol);

              // Add the row to the participant list
              participantList.appendChild(row);
            }
          }

          // Add event listener for search input
          const searchInput = document.getElementById("participant-filter");
          searchInput.addEventListener("keyup", function () {
            if (islevel == "2" || coHost == member) {
              filterParticipantList();
            } else {
              filterParticipantListOthers();
            }
          });

          //Add event listener for react participant filter
          $("body").on("keyup", "#react-participant-filter", function () {
            if (islevel == "2") {
              filterParticipantList();
            }
          });

          // Function to populate the participant list
          function populateParticipantListOthers() {
            const participantList = document.getElementById("participant-list");
            const participantCounter = document.getElementById(
              "participant-counter"
            );

            // Clear the participant list and counter before repopulating them
            participantList.innerHTML = "";
            participantCounter.innerText = "";

            // Loop through the participants array and create a row for each participant
            for (let i = 0; i < participants.length; i++) {
              const participant = participants[i];

              // Create a row element
              const row = document.createElement("div");
              row.classList.add("row", "mb-2");

              // Create a column for the name
              const nameCol = document.createElement("div");
              nameCol.classList.add("col-8");

              if (participant.islevel == "2") {
                if (participant.name === member) {
                  // add (you) to the member name
                  nameCol.innerText = participant.name + " (you)";
                } else {
                  nameCol.innerText = participant.name + " (host)";
                }
              } else {
                if (participant.name === member) {
                  // add (you) to the member name
                  nameCol.innerText = participant.name + " (you)";
                } else {
                  if (coHost == participant.name) {
                    nameCol.innerText = participant.name + " (co-host)";
                  } else {
                    nameCol.innerText = participant.name;
                  }
                }
              }
              row.appendChild(nameCol);

              // Create a column for the mic indicator
              const micCol = document.createElement("div");
              micCol.classList.add("col-3", "text-center");
              const micIndicator = document.createElement("i");
              micIndicator.classList.add(
                "fas",
                participant.muted ? "fa-dot-circle-o" : "fa-dot-circle-o",
                participant.muted ? "text-danger" : "text-success"
              );
              micCol.appendChild(micIndicator);
              row.appendChild(micCol);

              const emptyCol = document.createElement("div");
              emptyCol.classList.add("col-1", "text-end");
              row.appendChild(emptyCol);

              // Add the row to the participant list
              participantList.appendChild(row);
            }

            // Update the participant counter
            participantCounter.innerText = participants.length;
          }

          // Function to populate the participant list
          function populateParticipantList() {
            let participantList;
            let participantCounter;

            if (eventType != "broadcast") {
              participantList = document.getElementById("participant-list");
              participantCounter = document.getElementById(
                "participant-counter"
              );
              participantCounter.innerText = "";
            } else {
              participantList = document.getElementById(
                "react-participant-list"
              );
              participantCounter = document.getElementById(
                "reactParticipant-counter"
              );
            }

            // Clear the participant list and counter before repopulating them
            participantList.innerHTML = "";

            // Loop through the participants array and create a row for each participant
            for (let i = 0; i < participants.length; i++) {
              const participant = participants[i];

              // Create a row element
              const row = document.createElement("div");
              row.classList.add("row", "mb-2");

              // Create a column for the name
              const nameCol = document.createElement("div");
              nameCol.classList.add("col-4");
              if (participant.islevel == "2") {
                if (participant.name === member) {
                  // add (you) to the member name
                  nameCol.innerText = participant.name + " (you)";
                } else {
                  nameCol.innerText = participant.name + " (host)";
                }
              } else {
                if (participant.name === member) {
                  // add (you) to the member name
                  nameCol.innerText = participant.name + " (you)";
                } else {
                  if (coHost == participant.name) {
                    nameCol.innerText = participant.name + " (co-host)";
                  } else {
                    nameCol.innerText = participant.name;
                  }
                }
              }
              row.appendChild(nameCol);

              // Create a column for the mic indicator
              const micCol = document.createElement("div");
              micCol.classList.add("col-1", "text-center");
              if (eventType != "broadcast") {
                const micIndicator = document.createElement("i");
                micIndicator.classList.add(
                  "fas",
                  participant.muted ? "fa-dot-circle-o" : "fa-dot-circle-o",
                  participant.muted ? "text-danger" : "text-success"
                );
                micIndicator.id = "micIndicatora" + participant.name;
                micCol.appendChild(micIndicator);
              }
              row.appendChild(micCol);

              // Create a column for the mute button
              const muteCol = document.createElement("div");
              muteCol.classList.add("col-2", "text-right");
              if (eventType != "broadcast") {
                const muteButton = document.createElement("button");
                muteButton.classList.add("btn", "btn-sm", "btn-primary");
                muteButton.innerHTML = participant.muted
                  ? '<i class="fas fa-microphone-slash"></i>'
                  : '<i class="fas fa-microphone"></i>';
                muteButton.id = "Audioa" + participant.name;
                muteButton.addEventListener("click", function () {
                  let mediaValue = false;
                  try {
                    mediaValue = coHostResponsibility.find(
                      (item) => item.name === "media"
                    ).value;
                  } catch (error) {}

                  if (
                    islevel == "2" ||
                    (coHost == member && mediaValue == true)
                  ) {
                    let audioIconId = this.id;
                    let participantName = audioIconId.replace("Audioa", "");
                    let participantt_ = participants.find(
                      (obj) => obj.name === participantName
                    );
                    if (!participantt_.muted && participantt_.islevel != "2") {
                      // send signal to control media to client
                      let participantId = participantt_.id;
                      controlMedia(participantId, participantName, "all");
                      var newIcon = '<i class="fas fa-microphone-slash"></i>';
                      document.getElementById(audioIconId).innerHTML = newIcon;
                      let micIndicatorId = "micIndicatora" + participantName;
                      let micIndicator =
                        document.getElementById(micIndicatorId);
                      micIndicator.classList.remove(
                        "fa-dot-circle-o",
                        "text-success"
                      );
                      micIndicator.classList.add(
                        "fa-dot-circle-o",
                        "text-danger"
                      );
                    }
                  } else {
                    showAlert(
                      "You are not allowed to mute other participants",
                      "danger"
                    );
                  }
                });
                muteCol.appendChild(muteButton);
              }
              row.appendChild(muteCol);

              // Create a column for the message button
              const messageCol = document.createElement("div");
              messageCol.classList.add("col-2", "text-right");

              if (eventType != "broadcast") {
                const messageButton = document.createElement("button");
                messageButton.classList.add("btn", "btn-sm", "btn-primary");
                messageButton.innerHTML = '<i class="fas fa-comment"></i>';
                messageButton.id = "MessageButtona" + participant.name;
                messageButton.addEventListener("click", function () {
                  let messageButtonId = this.id;
                  let senderId = messageButtonId.replace("MessageButtona", "");

                  const showModal = () => {
                    return new Promise((resolve) => {
                      $("#messageModal").on("shown.bs.modal", () => {
                        resolve();
                      });
                      $("#messageModal").modal("show");
                    });
                  };

                  showModal().then(() => {
                    openReplyInput(senderId);
                  });
                });

                messageCol.appendChild(messageButton);
              }
              row.appendChild(messageCol);

              // Create a column for the remove button
              const removeCol = document.createElement("div");
              removeCol.classList.add("col-2", "text-end");
              const removeButton = document.createElement("button");
              removeButton.classList.add("btn", "btn-sm", "btn-danger");
              removeButton.innerHTML = '<i class="fas fa-trash-alt"></i>';
              removeButton.id = "remove" + participant.name;
              removeButton.addEventListener("click", async function () {
                let participantsValue = false;
                try {
                  participantsValue = coHostResponsibility.find(
                    (item) => item.name === "participants"
                  ).value;
                } catch (error) {}
                // Remove the participant from the participants array
                if (
                  islevel == "2" ||
                  (coHost == member && participantsValue == true)
                ) {
                  let removeIconId = this.id;
                  let participantName = removeIconId.replace("remove", "");
                  let participantt_ = participants.find(
                    (obj) => obj.name === participantName
                  );

                  if (participantt_.islevel == "2") {
                    return;
                  }
                  let participantId = participantt_.id;
                  socket.emit("disconnectUserInitiate", {
                    member: participantt_.name,
                    roomName: roomName,
                    id: participantId,
                  });

                  participants.splice(i, 1);
                  populateParticipantList();
                } else {
                  showAlert(
                    "You are not allowed to remove other participants",
                    "danger"
                  );
                }
              });
              removeCol.appendChild(removeButton);
              row.appendChild(removeCol);

              const emptyCol = document.createElement("div");
              emptyCol.classList.add("col-1", "text-end");
              row.appendChild(emptyCol);

              // Add the row to the participant list
              participantList.appendChild(row);
            }
            // Update the participant counter
            if (eventType != "broadcast") {
              participantCounter.innerText = participants.length;
            } else {
              let formattedNumber = formatNumber(participants.length);
              participantCounter.innerHTML =
                formattedNumber +
                ' <i class="fas fa-chart-bar fa-rotate-270 fa-lg"></i>';
            }
          }

          function formatNumber(number) {
            if (number < 1e3) {
              return number.toString();
            } else if (number < 1e6) {
              return (number / 1e3).toFixed(1) + "K";
            } else if (number < 1e9) {
              return (number / 1e6).toFixed(1) + "M";
            } else if (number < 1e12) {
              return (number / 1e9).toFixed(1) + "B";
            }
          }

          // Add an event listener to the modal so that it repopulates the participant list each time it's shown
          const modal = document.getElementById("participantsModal");

          $(document).on(
            "show.bs.modal",
            "#participantsModal",
            async function () {
              //populate based on islevel
              if (islevel == "2" || coHost == member) {
                await populateParticipantList();
              } else {
                await populateParticipantListOthers();
              }
            }
          );

          $(".btn-close").click(function () {
            $("#participantsModal").modal("hide");
            $("#participant-filter").val(""); // clear the filter
            $("#participant-filter").attr("placeholder", "Search ..."); // load the placeholder
          });

          // Prepopulate the form with the existing settings
          document.getElementById("audio").value = audioSetting;
          document.getElementById("video").value = videoSetting;
          document.getElementById("screenshare").value = screenshareSetting;
          document.getElementById("chat").value = chatSetting;

          // Listen for the submit event on the form to save the changes
          document
            .getElementById("settingsForm")
            .addEventListener("submit", async function (event) {
              event.preventDefault(); // prevent the form from submitting

              audioSetting = document.getElementById("audio").value;
              videoSetting = document.getElementById("video").value;
              screenshareSetting = document.getElementById("screenshare").value;
              chatSetting = document.getElementById("chat").value;
              $("#settingsModal").modal("hide");
              //update the settings for all other participants
              await updateSettingsForRequests([
                audioSetting,
                videoSetting,
                screenshareSetting,
                chatSetting,
              ]);
            });

          $("#settingsModal").on("show.bs.modal", function () {
            // Prepopulate the form with the existing settings
            document.getElementById("audio").value = audioSetting;
            document.getElementById("video").value = videoSetting;
            document.getElementById("screenshare").value = screenshareSetting;
            document.getElementById("chat").value = chatSetting;
          });

          function separateRequests() {
            //function to separate requests into micRequests, screenshareRequests, videoRequests and chatRequests
            micRequests = requests.filter(function (request) {
              return request.icon == "fa-microphone";
            });

            screenshareRequests = requests.filter(function (request) {
              return request.icon == "fa-desktop";
            });

            videoRequests = requests.filter(function (request) {
              return request.icon == "fa-video";
            });

            chatRequests = requests.filter(function (request) {
              return request.icon === "fa-comments";
            });
          }

          socket.on("updateMediaSettings", async ({ settings }) => {
            //update the settings for all other participants by admin
            audioSetting = settings[0];
            videoSetting = settings[1];
            screenshareSetting = settings[2];
            chatSetting = settings[3];
          });

          async function closeAndResize(producerId, kind) {
            //function to close and resize the video and audio elements

            if (kind === "audio") {
              //stop the audio by removing the miniAudio with id = producerId
              //get audio element with id = producerId
              try {
                let id = `AudioOnly_${producerId}`;
                let audioElement = await document.getElementById(id);

                //remove the audio element
                audioElement.remove();
              } catch (error) {}

              //remove the audio from the allAudioStreams array
              allAudioStreams = await allAudioStreams.filter(function (
                audioStream
              ) {
                return audioStream.producerId !== producerId;
              });

              if (
                recordingDisplayType == "video" &&
                recordingVideoOptimized == true
              ) {
              } else {
                //get the name of the participant with the producerId
                let participant = await participants.find(
                  (obj) => obj.audioID === producerId
                );

                if (participant) {
                  //check if the participants videoID is not null or ""
                  if (
                    participant.videoID !== null &&
                    participant.videoID !== ""
                  ) {
                  } else {
                    //remove the participant from the activeNames array
                    activeNames = await activeNames.filter(function (name) {
                      return name !== participant.name;
                    });
                  }
                }
              }

              let checker = false;
              let alt_checker = false;

              if (meetingDisplayType == "video") {
                checker =
                  participant[0].videoID != null &&
                  participant[0].videoID != "" &&
                  participant[0].videoID != undefined;
              } else {
                checker = true;
                alt_checker = true;
              }

              if (checker) {
                if (shareScreenStarted || shared) {
                  if (!alt_checker) {
                    await reorderStreams();
                  }
                } else {
                  if (alt_checker && meetingDisplayType != "video") {
                    await reorderStreams(false, true);
                  }
                }
              }
            } else if (kind === "video") {
              //update the video elements by removing the miniVideo with id = producerId

              //remove the video from the allVideoStreams array

              //check if producerId == adminidstream
              if (producerId == adminIDStream) {
                updateMainWindow = true;
              }

              try {
                allVideoStreams = await allVideoStreams.filter(function (
                  videoStream
                ) {
                  return videoStream.producerId !== producerId;
                });

                try {
                  //try remove it from oldVideoStreams
                  oldAllStreams = await oldAllStreams.filter(function (
                    videoStream
                  ) {
                    return videoStream.producerId !== producerId;
                  });
                } catch (error) {}

                try {
                  //try remove it from newLimitedStreams
                  newLimitedStreams = await newLimitedStreams.filter(function (
                    videoStream
                  ) {
                    return videoStream.producerId !== producerId;
                  });
                } catch (error) {}
              } catch (error) {
                try {
                  //try remove it from oldVideoStreams
                  oldAllStreams = await oldAllStreams.filter(function (
                    videoStream
                  ) {
                    return videoStream.producerId !== producerId;
                  });
                } catch (error) {}
              }

              try {
                //remove the participant from activeNames
                activeNames = await activeNames.filter(function (name) {
                  //get the participant with the producerId
                  let participant = streamNames.find(
                    (obj) => obj.producerId === producerId
                  );

                  return name !== participant.name;
                });
              } catch (error) {}

              if (lock_screen) {
                defer_receive = true;
                // check if the video is the one being displayed (i.e. (newLimitedStreamsIDs))
                if (newLimitedStreamsIDs.includes(producerId)) {
                  await prepopulateUserMedia(hostLabel);
                  await reorderStreams(false, true);
                }
              } else {
                await prepopulateUserMedia(hostLabel);
                await reorderStreams(false, true);
              }
            } else if (kind === "screenshare" || kind === "screen") {
              //update the video elements by removing the mainVideo with id = producerId

              updateMainWindow = true;

              //screenshare stuff
              shareScreenStarted = false;
              shareEnded = true;

              lock_screen = false;
              firstAll = false;
              first_round = false;

              if (!gotAllVids || defer_receive) {
                defer_receive = false;
                await getVideos();
                await rePort();
              }

              if (eventType == "conference") {
                await moveBoard();
                await $(".maingrid").remove();
                //add timer
                await addTimer();
                let height95 = window.innerHeight * 0.95;
                $(".othergrid").css("height", height95 + "px");
              }

              await prepopulateUserMedia(hostLabel);
              await reorderStreams(false, true);
            }
          }

          socket.on(
            "producer-media-paused",
            async ({ producerId, kind, name }) => {
              //update to pause the audio, video, screenshare of a participant
              //producerId is the id of the producer
              //kind is the kind of media (audio, video, screenshare)
              //name is the name of the participant

              //iterate through all activeSounds and check if any participant with muted property of true is in it and remove it
              await participants.forEach(async (participant) => {
                //update the ui for mediaDisplayTypes and re-render
                if (participant.muted) {
                  try {
                    if (participant.islevel == "2") {
                      //look for videoID is null or ""

                      if (
                        participant.videoID == null ||
                        participant.videoID == "" ||
                        participant.videoID == undefined
                      ) {
                        if (!shared && !shareScreenStarted && islevel != "2") {
                          updateMainWindow = true;
                          await prepopulateUserMedia(hostLabel);
                          await prepopulateUserMedia(hostLabel);
                          updateMainWindow = false;
                        }
                      }
                    }
                  } catch (error) {}

                  try {
                    let audioModal = $("#audioModal" + participant.name);

                    if (audioModal) {
                      audioModal.hide();
                    }
                  } catch (error) {}

                  if (shareScreenStarted || shared) {
                    //check if the participant is in activeSounds
                    //remove the participant from activeSounds if need be; others might have both audio and video on

                    if (activeSounds.includes(participant.name)) {
                      //try look for 'audioModal' + participant.name and hide it
                      try {
                        let audioModal = $("#audioModal" + participant.name);

                        if (audioModal) {
                          audioModal.hide();
                        }
                      } catch (error) {}

                      //remove the participant from activeSounds
                      activeSounds = await activeSounds.filter(function (
                        audioStream
                      ) {
                        return audioStream !== participant.name;
                      });
                    }

                    reUpdateInter(participant.name, false, true);
                  } else {
                    // no screensahre so obey user display settings; show waveforms, ...
                    let micIcon = $("#Audio" + participant.name);

                    // Change the icon based on the muted status
                    if (micIcon) {
                      if (participant.muted) {
                        micIcon
                          .removeClass("fa-microphone")
                          .addClass("fa-microphone-slash");
                        let waveform = $("#wave" + participant.name);
                        if (waveform) {
                          waveform.hide();
                        }
                      } else {
                        micIcon
                          .removeClass("fa-microphone-slash")
                          .addClass("fa-microphone");
                        let waveform = $("#wave" + participant.name);
                        if (waveform) {
                          waveform.show();
                        }
                      }
                    } else {
                      let waveform = $("#wave" + participant.name);
                      if (waveform) {
                        waveform.show();
                      }
                    }
                  }
                }
              });

              //operation to update the ui based on the mediaDisplayType
              let checker = false;
              let alt_checker = false;

              if (
                meetingDisplayType == "media" ||
                (meetingDisplayType == "video" &&
                  meetingVideoOptimized == false)
              ) {
                let participant = await participants.find(
                  (obj) => obj.name === name
                );
                checker =
                  participant.videoID != null &&
                  participant.videoID != "" &&
                  participant.videoID != undefined;

                if (!checker) {
                  //may need to come in front of the video
                  if (shareScreenStarted || shared) {
                  } else {
                    // updateMainWindow = true;
                    await reorderStreams(false, true);
                  }
                }
              }

              if (kind === "audio") {
                //opertaion to update ui to optimize interest levels
                //stop the audio by removing the miniAudio with id = producerId
                //get audio element with id = producerId
                try {
                  //try and check if the name for this producerId is in oldsoundsids
                  //find the participant with this producerId as audioID
                  let participant = await participants.find(
                    (obj) => obj.audioID === producerId
                  );

                  //CHECK IF THE PARTICIPANT NAME IS IN OLDSOUNDSIDS
                  if (oldSoundIds.includes(participant.name)) {
                    //remove the participant name from oldSoundsIds
                    reUpdateInter(participant.name, false, true);
                  }
                } catch (error) {}
              }
            }
          );

          socket.on("producer-media-resumed", async ({ name, kind }) => {
            //update to resume the audio only of a participant
            //name is the name of the participant
            //kind is the kind of media (always audio)
            //this is only emitted for audio (and not video or screenshare)

            //we naturally just pause the audio and not close it; every other media is closed when user turns it off
            //so only audio gets paused and resumed with same producerId; rest get closed and reopened with new producerId (which is notified in another way)

            //opertaions to update ui to optimize interest levels
            let participant = await participants.find(
              (obj) => obj.name === name
            );

            let micIcon = $("#Audio" + participant.name);

            if (!mainScreenFilled && participant.islevel == "2") {
              updateMainWindow = true;
              await prepopulateUserMedia(hostLabel);
              updateMainWindow = false;
            }

            // Change the icon based on the muted status
            if (micIcon) {
              if (participant.muted) {
                micIcon
                  .removeClass("fa-microphone")
                  .addClass("fa-microphone-slash");
                let waveform = $("#wave" + participant.name);
                if (waveform) {
                  waveform.hide();
                }
              } else {
                micIcon
                  .removeClass("fa-microphone-slash")
                  .addClass("fa-microphone");
                let waveform = $("#wave" + participant.name);
                if (waveform) {
                  waveform.show();
                }
              }
            } else {
              let waveform = $("#wave" + participant.name);
              if (waveform) {
                waveform.show();
              }
            }

            if (meetingDisplayType == "media") {
              let participant = await participants.find(
                (obj) => obj.name === name
              );
              checker =
                participant.videoID != null &&
                participant.videoID != "" &&
                participant.videoID != undefined;

              if (!checker) {
                if (shareScreenStarted || shared) {
                } else {
                  // updateMainWindow = true;
                  await reorderStreams(false, true);
                }
              }
            }
          });

          socket.on("producer-media-closed", async ({ producerId, kind }) => {
            //update to close the video, screenshare of a participant
            //producerId is the id of the producer
            //kind is the kind of media (video, screenshare)
            //never emitted for audio

            //opertaions to update ui to optimize interest levels and close the video or screenshare
            const producerToClose = await consumerTransports.find(
              (transportData) => transportData.producerId === producerId
            );

            if (producerToClose) {
              try {
                await producerToClose.consumerTransport.close();
              } catch (error) {}

              try {
                await producerToClose.consumer.close();
              } catch (error) {}

              consumerTransports = await consumerTransports.filter(
                (transportData) => transportData.producerId !== producerId
              );

              await closeAndResize(producerId, kind);
            }
          });

          socket.on("controlMediaHost", async ({ type }) => {
            //update to control the media of a participant by host
            //type is the type of media (audio, video, screenshare, all)

            // update to stop and resume the audio, video, screenshare of a participant
            try {
              adminRestrictSetting = true;

              if (type === "audio") {
                localStream.getAudioTracks()[0].enabled = await false;

                $(".micStated").html(
                  '<button style="background-color: transparent;border: 0; font-size: medium;" id="micState" class="micStated"> <i class="fas fa-microphone-slash fa-lg border-0"  > </i>  </button>'
                );

                await disconnectSendTransportAudio();
                if (p_sockets.length > 0) {
                  try {
                    await disconnectSendTransportAudio(true);
                  } catch (error) {}
                }
                audioAlreadyOn = await false;
              } else if (type === "video") {
                localStream.getVideoTracks()[0].enabled = false;

                $(".videoStated").html(
                  '<button style="background-color: transparent;border: 0; font-size: medium;" id="videoState" class="videoStated"> <i class="fas fa-video-slash fa-lg border-0"  > </i>  </button>'
                );

                await disconnectSendTransportVideo();

                if (p_sockets.length > 0) {
                  try {
                    await disconnectSendTransportVideo(true);
                  } catch (error) {}
                }
                //
                videoAlreadyOn = await false;
                await onScreenChanges(true);
              } else if (type === "screenshare") {
                localStreamScreen.getVideoTracks()[0].enabled = false;
                await $("#screenshareState").html(
                  '<button style="background-color: transparent;border: 0; font-size: medium;position: relative;" id="screenshareState"> <span class="fa-stack fa-md border-0" ><i class="fas fa-desktop fa-stack-1x border-0"></i><i class="fas fa-ban fa-stack-2x border-0" style="color:Tomato"></i></span> </button>'
                );
                await disconnectSendTransportScreen();
                if (p_sockets.length > 0) {
                  try {
                    await disconnectSendTransportScreen(true);
                  } catch (error) {}
                }
                await stopShareScreen();
                screenAlreadyOn = await false;
              } else if (type === "chat") {
                $("#chatState").html(
                  '<button style="background-color: transparent;border: 0; font-size: medium;" id="chatState"> <i class="fas fa-comments fa-lg border-0"  > </i>  </button>'
                );
                chatAlreadyOn = await false;
              } else if (type == "all") {
                try {
                  localStream.getAudioTracks()[0].enabled = false;

                  $(".micStated").html(
                    '<button style="background-color: transparent;border: 0; font-size: medium;" id="micState" class="micStated"> <i class="fas fa-microphone-slash fa-lg border-0"  > </i>  </button>'
                  );

                  await disconnectSendTransportAudio();
                  if (p_sockets.length > 0) {
                    try {
                      await disconnectSendTransportAudio(true);
                    } catch (error) {}
                  }

                  audioAlreadyOn = false;
                } catch (error) {}

                try {
                  localStreamScreen.getVideoTracks()[0].enabled = await false;
                  await $("#screenshareState").html(
                    '<button style="background-color: transparent;border: 0; font-size: medium;position: relative;" id="screenshareState"> <span class="fa-stack fa-md border-0" ><i class="fas fa-desktop fa-stack-1x border-0"></i><i class="fas fa-ban fa-stack-2x border-0" style="color:Tomato"></i></span> </button>'
                  );
                  // await $("#screenshareState").html('<button style="background-color: transparent;border: 0; font-size: medium;" id="screenshareState"> <i class="fas fa-desktop fa-lg border-0"  > </i>  </button>');
                  await disconnectSendTransportScreen();
                  if (p_sockets.length > 0) {
                    try {
                      await disconnectSendTransportScreen(true);
                    } catch (error) {}
                  }
                  await stopShareScreen();
                  screenAlreadyOn = await false;
                } catch (error) {}

                try {
                  localStream.getVideoTracks()[0].enabled = await false;

                  await $(".videoStated").html(
                    '<button style="background-color: transparent;border: 0; font-size: medium;" id="videoState" class="videoStated"> <i class="fas fa-video-slash fa-lg border-0"  > </i>  </button>'
                  );

                  await disconnectSendTransportVideo();
                  if (p_sockets.length > 0) {
                    try {
                      await disconnectSendTransportVideo(true);
                    } catch (error) {}
                  }

                  videoAlreadyOn = await false;
                  await onScreenChanges(true);
                } catch (error) {}
              }
            } catch (error) {}
          });

          async function controlMedia(participantId, participantName, type) {
            //function control media initiated by host (co-host); host(co-host) can stop and resume audio, video, screenshare of a participant
            //participantId is the id of the participant
            //participantName is the name of the participant
            //type is the type of media (audio, video, screenshare, all)

            await socket.emit("controlMedia", {
              participantId,
              participantName,
              type,
              roomName,
            });
          }

          async function updateSettingsForRequests(settings) {
            //function to update settings for requests foe everyone; settings is an array of settings
            //settings[0] is audio setting
            //settings[1] is video setting
            //settings[2] is screenshare setting
            //settings[3] is chat setting
            await socket.emit("updateSettingsForRequests", {
              settings,
              roomName,
            });
          }

          async function updateUserofRequestStatus(requestResponse) {
            //function to update user of request status; requestResponse is an object
            //requestResponse.id is the id of the request
            //requestResponse.name is the name of the request
            //requestResponse.type is the type of the request (fa-microphone, fa-desktop, fa-video, fa-comments which are audio, screenshare, video, chat respectively)
            //requestResponse.action is the action of the request (accepted or rejected)
            //requestResponse.username is the username of the request

            await socket.emit("updateUserofRequestStatus", {
              requestResponse,
              roomName,
            });
          }

          async function addRequest(request, iconClass) {
            // function to add a request to the list
            //request is an object
            //request.id is the id of the request
            //request.name is the name of the request
            //request.type is the type of the request (fa-microphone, fa-desktop, fa-video, fa-comments which are audio, screenshare, video, chat respectively)
            //request.action is the action of the request (accepted or rejected)
            //request.username is the username of the request

            try {
              let requestRow = $("<div>").addClass(
                "row align-items-center request-actions"
              );

              let nameCol = $("<div>").addClass("col-5").text(request.name);
              //set the id field as the id of the nameCol div
              let idField = $("<div>")
                .addClass("col-0")
                .text(request.id + "::" + request.username);
              idField.hide();
              let typeCol = $("<div>")
                .addClass("col-2 text-center")
                .html('<i class="fas ' + iconClass + '"></i>');
              let acceptBtn = $("<div>")
                .addClass("col-2 text-center")
                .html(
                  $("<button>")
                    .addClass("btn btn-success accept-btn")
                    .html('<i class="fas fa-check"></i>')
                );
              let rejectBtn = $("<div>")
                .addClass("col-2 text-center")
                .html(
                  $("<button>")
                    .addClass("btn btn-danger reject-btn")
                    .html('<i class="fas fa-times"></i>')
                );
              let blank = $("<div>").addClass("col-1 text-center");

              requestRow.append(nameCol);
              requestRow.append(typeCol);
              requestRow.append(acceptBtn);
              requestRow.append(rejectBtn);
              requestRow.append(idField);
              requestRow.append(blank);
              $("#request-list").append(
                $("<div>").addClass("col-12 mb-3").append(requestRow)
              );
            } catch (error) {}
          }

          function addRequests(requests, iconClass) {
            // function to add requests to the list
            //requests is an array of requests

            try {
              requests.forEach(function (request) {
                addRequest(request, iconClass);
              });
            } catch (error) {}
          }

          async function addRequestButton() {
            // Function to  listen for response from host and filter out responded requests
            //add the actual functions to the accept and reject buttons

            try {
              $(".request-actions button").click(async function () {
                let action = $(this).hasClass("btn-success")
                  ? "accepted"
                  : "rejected";
                let requestItem = $(this).closest(".request-actions");
                let requestName = requestItem.find(".col-5").text();
                let requestIcon = requestItem.find(".col-2 i").attr("class");

                //find hidden id field
                let requestId = requestItem
                  .find(".col-0")
                  .text()
                  .split("::")[0];
                let requestUsername = requestItem
                  .find(".col-0")
                  .text()
                  .split("::")[1];

                let requestType = "";
                if (requestIcon.includes("fa-microphone")) {
                  requestType = "fa-microphone";
                } else if (requestIcon.includes("fa-desktop")) {
                  requestType = "fa-desktop";
                } else if (requestIcon.includes("fa-video")) {
                  requestType = "fa-video";
                } else if (requestIcon.includes("fa-comments")) {
                  requestType = "fa-comments";
                }
                let respondedRequest = {
                  id: requestId,
                  name: requestName,
                  type: requestType,
                  action: action,
                  username: requestUsername,
                };

                // remove the request from the list of requests
                requests = await requests.filter(function (request) {
                  return !(
                    request.id == requestId &&
                    request.icon == requestType &&
                    request.name == requestName
                  );
                });

                await updateUserofRequestStatus(respondedRequest);

                requestItem.parent().fadeOut(500, function () {
                  $(this).remove();
                });

                //update the request counter
                totalRequests = (await totalRequests) - 1;
                let totalReq = totalRequests + waitingParticipants.length;
                $("#request-counter").text(totalRequests);
                $(".request-count").text(totalReq);

                if (islevel != "2") {
                  if (coHost != member) {
                    $(".request-count").hide();
                  } else {
                    $(".request-count").show();
                  }
                }
              });
            } catch (error) {}
          }

          //populate menu with the number of requests
          let totalReq = totalRequests + waitingParticipants.length;
          $(".request-count").text(totalReq);

          $("#requestsModal").on("hide.bs.modal", function (event) {
            // Clear the request list and counter before repopulating them
            $("#request-list").html("");
            $("#request-counter").text("");
            $(".request-count").text("");

            //clear the search input
            $("#request-filter").val("Search ..."); // clear the filter
            //set the total requests to length of requests
            separateRequests();

            totalRequests =
              micRequests.length +
              screenshareRequests.length +
              videoRequests.length +
              chatRequests.length;
            let totalReqs = totalRequests + waitingParticipants.length;

            $("#request-counter").text(totalRequests);
            $(".request-count").text(totalReqs);

            //if islevel !=2 then hide .request-count
            if (islevel != "2") {
              if (coHost != member) {
                $(".request-count").hide();
              } else {
                $(".request-count").show();
              }
            }
          });

          // Pre-populate modal with existing settings
          $("#requestsModal").on("show.bs.modal", function (event) {
            var modal = $(this);

            // Clear the request list and counter before repopulating them
            separateRequests();

            totalRequests =
              micRequests.length +
              screenshareRequests.length +
              videoRequests.length +
              chatRequests.length;

            const requestList = document.getElementById("request-list");
            const requestCounter = document.getElementById("request-counter");
            const requestCount =
              document.getElementsByClassName("request-count")[0];

            requestList.innerHTML = "";
            requestCounter.innerText = "";

            addRequests(micRequests, "fa-microphone");
            addRequests(screenshareRequests, "fa-desktop");
            addRequests(videoRequests, "fa-video");
            addRequests(chatRequests, "fa-comments");
            addRequestButton();

            // Update the request counter
            requestCounter.innerText = totalRequests;
            requestCount.innerText = totalRequests;
          });

          // Add event listener for search input of requests
          const searchRequest = document.getElementById("request-filter");
          searchRequest.addEventListener("keyup", filterRequestsList);

          function filterRequestsList() {
            // Function to filter the requests list based on the search input

            const requestList = document.getElementById("request-list");
            const requestCounter = document.getElementById("request-counter");
            const requestCount =
              document.getElementsByClassName("request-count")[0];
            // Clear the request list and counter before repopulating them
            requestList.innerHTML = "";

            const filterInput = document.getElementById("request-filter");

            const filterQuery = filterInput.value.toLowerCase().trim();

            const filteredmicRequests = micRequests.filter((participant) => {
              return participant.name.toLowerCase().includes(filterQuery);
            });

            const filteredscreenshareRequests = screenshareRequests.filter(
              (participant) => {
                return participant.name.toLowerCase().includes(filterQuery);
              }
            );

            const filteredvideoRequests = videoRequests.filter(
              (participant) => {
                return participant.name.toLowerCase().includes(filterQuery);
              }
            );

            const filteredchatRequests = chatRequests.filter((participant) => {
              return participant.name.toLowerCase().includes(filterQuery);
            });

            const totalRequests =
              filteredmicRequests.length +
              filteredscreenshareRequests.length +
              filteredvideoRequests.length +
              filteredchatRequests.length;

            addRequests(filteredmicRequests, "fa-microphone");
            addRequests(filteredscreenshareRequests, "fa-desktop");
            addRequests(filteredvideoRequests, "fa-video");
            addRequests(filteredchatRequests, "fa-comments");

            addRequestButton();

            // Update the request counter
            requestCounter.innerText = totalRequests;
            requestCount.innerText = totalRequests;
          }

          //default listeners
          $(".btn-close-requests").click(function () {
            $("#requestsModal").modal("hide");
          });

          //Menu modal control
          $(".btn-close-menu").click(function () {
            $("#menuModal").modal("hide");
          });

          //videos display
          function calculateRowsAndColumns(n) {
            //calculate the number of rows and columns that we need to display n videos, might be more than n
            const sqrt = Math.sqrt(n);
            let cols = Math.floor(sqrt);
            let rows = Math.ceil(n / cols);
            let prod = rows * cols;

            while (prod < n) {
              if (cols < rows) {
                cols++;
              } else {
                rows++;
              }
              prod = rows * cols;
            }
            return [rows, cols];
          }

          function GetEstimate(n) {
            //function to get the number of rows and columns
            [rows, cols] = calculateRowsAndColumns(n);

            if (
              n < fixedPageLimit ||
              ((shareScreenStarted || shared) && n < screenPageLimit + 1)
            ) {
              removeAltGrid = true;

              if (window.matchMedia("(max-width: 576px)").matches) {
                if (
                  eventType == "chat" ||
                  (eventType == "conference" && !(shareScreenStarted || shared))
                ) {
                  return [n, n, 1];
                } else {
                  return [n, 1, n];
                }
              } else {
                if (
                  eventType == "chat" ||
                  (eventType == "conference" && !(shareScreenStarted || shared))
                ) {
                  return [n, 1, n];
                } else {
                  return [n, n, 1];
                }
              }
            }

            return [rows * cols, rows, cols];
          }

          //check to add second grid or remove it
          async function checkGrid(rows, cols, actives) {
            //function to check if we need to add a second grid or remove it
            if (rows * cols != actives) {
              if (rows * cols > actives) {
                res = actives - (rows - 1) * cols;
                if (cols * 0.5 < res) {
                  lastrow = rows;
                  lastrowcols = res;
                  remainingVideos = lastrowcols;
                } else {
                  lastrowcols = res + cols;
                  lastrow = rows - 1;
                  remainingVideos = lastrowcols;
                }

                numRows = lastrow - 1;
                numCols = cols;
                numtoaddd = (lastrow - 1) * numCols;
                actualRows = lastrow;

                removeAltGrid = false;
              }
            } else {
              //perfect fit
              numCols = cols;
              numRows = rows;
              lastrow = rows;
              lastrowcols = cols;
              remainingVideos = 0;
              numtoaddd = lastrow * numCols;
              actualRows = lastrow;
              removeAltGrid = true;
            }

            return [
              removeAltGrid,
              numtoaddd,
              numRows,
              numCols,
              remainingVideos,
              actualRows,
            ];
          }

          function updateMainCardsGrid() {
            //function to update the grid template based on the number of rows and columns

            activeVideos = 1;
            let containerWidth = $(".maingrid").width();
            let containerHeight = $(".maingrid").height();
            let cardSpacing = 2; // 2 px margin between cards
            let totalSpacing = 0;
            let cardSize = 0;

            let numCols = 1;
            let numRows = 1;
            let remainingVideos = 0;
            let actualRows = 1;

            let container = $(".maingrids");

            //calculate size of cards based on grid size
            let cardWidth = Math.floor(containerWidth);
            let cardHeight = Math.floor(containerHeight);
            const initialHeight = cardHeight;
            const initialWidth = cardWidth;

            container.css(
              "grid-template-rows",
              "repeat(" + numRows + ", " + cardHeight + "px)"
            );
            container.css(
              "grid-template-columns",
              "repeat(" + numCols + ", " + cardWidth + "px)"
            );

            if (whiteboardStarted && !whiteboardEnded) {
              try {
                const canvas = document.getElementById("whiteboard-interface");
                canvas.width = cardWidth;
                canvas.height = cardHeight;

                $("#zoomReset").click();
              } catch (error) {}
            } else if (shared && annotateScreenStream) {
              try {
                cardHeight = Math.floor(
                  localStreamScreen.getVideoTracks()[0].getSettings().height
                );
                cardWidth = Math.floor(
                  localStreamScreen.getVideoTracks()[0].getSettings().width
                );

                const canvas = document.getElementById("screenboard-interface");
                canvas.width = cardWidth;
                canvas.height = cardHeight;

                const canvasBoard =
                  document.getElementById("screenboardCanvas");
                canvasBoard.width = cardWidth;
                canvasBoard.height = cardHeight;
                canvasBoard.style.width = cardWidth + "px";
                canvasBoard.style.height = cardHeight + "px";
                canvasBoard.style.overflowX = "hidden";
                canvasBoard.style.overflowY = "hidden";
                canvasBoard.style.left = "0px";

                canvas.style.overflowX = "hidden";
                canvas.style.overflowY = "hidden";

                const screenboardContent =
                  document.getElementById("screenboardContent");
                screenboardContent.style.width = cardWidth + "px";
                screenboardContent.style.height = cardHeight + "px";

                container.css(
                  "grid-template-rows",
                  "repeat(" + numRows + ", " + cardHeight + "px)"
                );
                container.css(
                  "grid-template-columns",
                  "repeat(" + numCols + ", " + cardWidth + "px)"
                );

                //calculate half of the height between container and canvas
                const halfHeight = Math.floor(
                  (containerHeight - cardHeight) / 2
                );
                const halfWidth = Math.floor((containerWidth - cardWidth) / 2);

                $(".maingrids").css("margin-top", halfHeight + "px");
                // canvas.style.marginTop = halfHeight + 'px';
                // canvas.style.marginLeft = halfWidth + 'px';

                container.css("overflowY", "hidden");
                container.css("overflowX", "hidden");

                if (
                  window
                    .getComputedStyle(canvasBoard)
                    .getPropertyValue("right") != "0px" &&
                  window
                    .getComputedStyle(canvasBoard)
                    .getPropertyValue("left") !=
                    window
                      .getComputedStyle(canvasBoard)
                      .getPropertyValue("right") &&
                  initialWidth < cardWidth
                ) {
                  let left = initialWidth - cardWidth;
                  left = left / 2;
                  canvasBoard.style.left = left + "px";
                  canvasBoard.style.right = left + "px";
                }

                $("#zoomResetScreen").click();
              } catch (error) {}
            }
          }

          function updateMiniCardsGrid(
            rows,
            cols,
            defal = true,
            actualRows = 2,
            ind = 0
          ) {
            //function to update the grid template based on the number of rows and columns
            activeVideos = rows * cols;

            let containerWidth = $(".minigrid-container").width();

            let containerHeight;
            if (doPaginate) {
              containerHeight = Math.floor(
                $(".minigrid-container").height() - $(".nav-minigrid").height()
              );
            } else {
              containerHeight = $(".minigrid-container").height();
            }

            let cardSpacing = 3; // 3px margin between cards

            if (eventType == "chat") {
              cardSpacing = 0;
            }

            let totalSpacing = (activeVideos - 1) * cardSpacing;
            let cardSize = (containerWidth - totalSpacing) / activeVideos;

            let numCols = cols;
            let numRows = rows;
            let remainingVideos = 0;

            let container;
            if (defal) {
              if (ind == 0) {
                container = $(`#minigrid-home .minigrid`);
              } else {
                container = $(`#minigrid-${ind} .minigrid`);
              }
            } else {
              if (ind == 0) {
                container = $(`#minigrid-home .minigrid1`);
              } else {
                container = $(`#minigrid-${ind} .minigrid1`);
              }
            }

            // calculate size of cards based on grid size
            let cardWidth = Math.floor(
              (containerWidth - (numCols - 1) * cardSpacing) / numCols
            );
            let cardHeight = Math.floor(
              (containerHeight - (actualRows - 1) * cardSpacing) / actualRows
            );

            container.css(
              "grid-template-rows",
              "repeat(" + numRows + ", " + cardHeight + "px)"
            );
            container.css(
              "grid-template-columns",
              "repeat(" + numCols + ", " + cardWidth + "px)"
            );
          }

          function createCardElements(
            participant,
            participant_,
            remoteProducerId,
            type = true,
            adVideo = true
          ) {
            // Create the card elements for the participant
            let card;
            if (adVideo) {
              card = $('<div class="card"></div>');
              card.css({
                width: "100%",
                height: "100%",
                margin: "0px",
                padding: "0px",
                background:
                  "linear-gradient(135deg, #f5f7fa, #c3cfe2, #ffebcd)",
              });

              // Create the <video> element and append it to the card body
              let miniVideo = document.createElement("video");
              if (!remoteProducerId && shared) {
                remoteProducerId = "localScreenShare";
              }

              miniVideo.setAttribute("id", `${remoteProducerId}`);
              if (
                (remoteProducerId === "youyou" ||
                  remoteProducerId === "youyouyou") &&
                eventType != "chat" &&
                eventType != "conference"
              ) {
                if (
                  remoteProducerId === "youyou" ||
                  remoteProducerId === "youyouyou" ||
                  participant.mirror == true
                ) {
                  miniVideo.setAttribute(
                    "style",
                    "width: auto%; height: 100%; object-fit:contain; background: linear-gradient(135deg, #f5f7fa, #c3cfe2, #ffebcd);transform: rotateY(180deg)"
                  );
                } else {
                  miniVideo.setAttribute(
                    "style",
                    "width: auto%; height: 100%; object-fit:contain; background: linear-gradient(135deg, #f5f7fa, #c3cfe2, #ffebcd)"
                  );
                }
              } else {
                if (forceFullDisplay) {
                  if (
                    remoteProducerId === "youyou" ||
                    remoteProducerId === "youyouyou" ||
                    participant.mirror == true
                  ) {
                    miniVideo.setAttribute(
                      "style",
                      "width: 100%; height: 100%; object-fit:cover; transform: rotateY(180deg)"
                    );
                  } else {
                    miniVideo.setAttribute(
                      "style",
                      "width: 100%; height: 100%; object-fit:cover;"
                    );
                  }
                } else {
                  if (
                    remoteProducerId === "youyou" ||
                    remoteProducerId === "youyouyou" ||
                    participant.mirror == true
                  ) {
                    miniVideo.setAttribute(
                      "style",
                      "width: auto; height: 100%; object-fit:contain; background: linear-gradient(135deg, #f5f7fa, #c3cfe2, #ffebcd);transform: rotateY(180deg)"
                    );
                  } else {
                    miniVideo.setAttribute(
                      "style",
                      "width: auto; height: 100%; object-fit:contain; background: linear-gradient(135deg, #f5f7fa, #c3cfe2, #ffebcd)"
                    );
                  }
                }
              }

              miniVideo.srcObject = participant.stream;
              miniVideo.setAttribute("autoplay", true);
              miniVideo.setAttribute("playsinline", true);
              miniVideo.setAttribute("muted", true);

              card.append(miniVideo);
            } else {
              card = $('<div class="card"></div>');
              card.css({
                width: "100%",
                height: "100%",
                margin: "0px",
                padding: "0px",
                background:
                  "linear-gradient(135deg, #f5f7fa, #c3cfe2, #ffebcd)",
              });
            }

            if (!type) {
              return card;
            }

            // Create the overlay element
            let overlay = $('<div class="overlay"></div>');
            overlay.css({
              position: "absolute",
              top: "0",
              left: "0",
              "min-width": "50%",
              "min-height": "3%",
              "max-height": "6%",
              display: "grid",
              "grid-template-columns": "4fr 2fr 2fr 2fr",
              "grid-gap": "3px",
            });

            // Create the name column and append it to the overlay
            let nameColumn = $('<div class="name-column"></div>');
            nameColumn.css({
              display: "flex",
              "justify-content": "center",
              "align-items": "center",
              "background-color": "rgba(0, 0, 0, 0.5)",
              padding: "2px",
              color: "white",
              fontSize: "0.65em",
            });

            nameColumn.text(participant_.name);
            overlay.append(nameColumn);

            // Create the mic control column and append it to the overlay
            let micControl = $('<div class="mic-control"></div>');
            micControl.css({
              display: "flex",
              "justify-content": "center",
              "align-items": "center",
              "background-color": "rgba(0, 0, 0, 0.025)",
              padding: "2px",
              color: "black",
            });

            // Create the mic icon and append it to the mic control column
            let micIcon = $(
              participant_.muted
                ? '<i class="fas fa-microphone-slash"></i>'
                : '<i class="fas fa-microphone"></i>'
            );
            //add and id to the icon which is Audio + participant_.id
            micIcon.attr("id", "Audio" + participant_.name);

            micIcon.css({
              cursor: "pointer",
              "font-size": "0.65em",
            });

            micControl.on("click", function () {
              let mediaValue = false;
              try {
                mediaValue = coHostResponsibility.find(
                  (item) => item.name === "media"
                ).value;
              } catch (error) {}

              if (islevel == "2" || (mediaValue && coHost == member)) {
                let audioIconId = $(this).find("i").attr("id");

                // get the participant ID from the audio icon ID
                let participantName = audioIconId.replace("Audio", "");

                let participantt_ = participants.find((obj) => {
                  return obj.name === participantName;
                });

                if (!participantt_.muted && participantt_.islevel != "2") {
                  //send signal to control media to client
                  let participantId = participantt_.id;
                  controlMedia(participantId, participantName, "audio");

                  // toggle the audio icon to show a slash
                  let escapedSelector = $.escapeSelector(audioIconId);
                  $("#" + escapedSelector).toggleClass(
                    "fa-microphone fa-microphone-slash"
                  );
                }
              } else {
                showAlert(
                  "You are not allowed to control user media",
                  "danger"
                );
              }
            });

            micControl.append(micIcon);

            // Create the video control column and append it to the overlay
            let videoControl = $('<div class="video-control"></div>');

            videoControl.css({
              display: "flex",
              "justify-content": "center",
              "align-items": "center",
              "background-color": "rgba(0, 0, 0, 0.025)",
              padding: "2px",
              color: "black",
            });

            // Create the video icon and append it to the video control column
            let videoIcon = $(
              participant_.videoOn
                ? '<i class="fas fa-video"></i>'
                : '<i class="fas fa-video-slash"></i>'
            );
            //add an id to the icon which is Video + participant_.id
            videoIcon.attr("id", "Video" + participant_.name);
            videoIcon.css({
              cursor: "pointer",
              "font-size": "0.5em",
            });
            videoControl.append(videoIcon);

            videoControl.on("click", function () {
              let mediaValue = false;
              try {
                mediaValue = coHostResponsibility.find(
                  (item) => item.name === "media"
                ).value;
              } catch (error) {}

              if (islevel == "2" || (mediaValue && coHost == member)) {
                // get the video icon ID
                let videoIconId = $(this).find("i").attr("id");

                // get the participant ID from the video icon ID
                let participantName = videoIconId.replace("Video", "");

                //find the participant with the id
                let participantt_ = participants.find((obj) => {
                  return obj.name === participantName;
                });

                if (participantt_.videoOn && participantt_.islevel != "2") {
                  //send signal to control media to client
                  let participantId = participantt_.id;
                  controlMedia(participantId, participantName, "video");

                  // toggle the video icon to show a slash
                  let escapedSelector = $.escapeSelector(videoIconId);
                  $("#" + escapedSelector).toggleClass(
                    "fa-video fa-video-slash"
                  );
                }
              } else {
                showAlert(
                  "You are not allowed to control user media",
                  "danger"
                );
              }
            });

            // Append the mic and video control columns to the overlay
            overlay.append(micControl);
            overlay.append(videoControl);

            // Create the waveform element and append it to the overlay
            let waveform = $('<div class="waveform sound"></div>');
            waveform.attr("id", "wave" + participant_.name); // Add ID to waveform
            waveform.css({
              display: "flex",
              "justify-content": "left",
              "align-items": "center",
              "background-color": "rgba(0, 0, 0, 0.05)",
              padding: "2px",
              color: "black",
            });

            // Add individual bars to the waveform
            for (let i = 0; i < 9; i++) {
              let bar = $('<div class="bar"></div>');
              waveform.append(bar);
            }

            waveform.hide(); // Hide waveform by default

            overlay.append(waveform);

            // Append the overlay to the card
            if (eventType != "chat") {
              card.append(overlay);
            }

            return card;
          }

          function addVideosGrid(
            mainGridStreams,
            altGridStreams,
            numtoadd,
            numRows,
            numCols,
            remainingVideos,
            actualRows,
            removeAltGrid,
            ind,
            forChat = false,
            forChatMini = false,
            forChatCard = null,
            forChatID = null
          ) {
            //function to add videos to the grid

            // create mini-cards for each participant
            let allMiniGrid1;
            if (ind == 0) {
              allMiniGrid1 = document.querySelectorAll(
                "#minigrid-home .minigrid"
              );
            } else {
              allMiniGrid1 = document.querySelectorAll(
                `#minigrid-${ind} .minigrid`
              );
            }

            allMiniGrid1.forEach((grid) => {
              grid.remove();
            });

            let participant_;
            let participant;
            let remoteProducerId;

            //remove all children of all .minigrid-container and empty the containers
            if (ind == 0) {
              $("#minigrid-home").empty();
            } else {
              $(`#minigrid-${ind}`).empty();
            }

            // Create a new minigrid div
            let minigrid = $(
              '<div class="minigrid" style="display: grid; grid-gap: 3px; justify-content: center;width: 100%;margin: 0%;padding: 0%;margin-top:0px;padding-top:0px"></div>'
            );

            numtoadd = mainGridStreams.length;

            let part_with_video = 0;
            if (eventType == "chat" && forChat) {
              //count number of participants with video on
              participants.forEach((participant) => {
                if (participant.videoOn) {
                  part_with_video = part_with_video + 1;
                }
              });
            }

            // take the first numtoadd participants with video on - perfect fit
            for (let i = 0; i < numtoadd; i++) {
              participant = mainGridStreams[i];
              remoteProducerId = participant.producerId;

              let pseudoName;

              //check if there is .name in the participant object and if it is null
              if (
                participant.hasOwnProperty("producerId") &&
                participant.producerId != null &&
                participant.producerId !== ""
              ) {
                //actual video
                pseudoName = false;
              } else {
                pseudoName = true;
              }

              if (pseudoName) {
                participant_ = participant;
                remoteProducerId = participant.name;

                let miniCard = createCardElements(
                  participant,
                  participant_,
                  remoteProducerId,
                  true,
                  false
                );
                const initials = participant.name;
                miniCard.addClass("active-video");
                miniCard.addClass("mini-carded");
                miniCard.attr("data-initials", initials);
                let fontSize = "1.35em";
                if (window.matchMedia("(max-width: 576px)").matches) {
                  if (dispActiveNames.length > 8) {
                    fontSize = "1.1em";
                  } else if (dispActiveNames.length > 12) {
                    fontSize = "0.85em";
                  }
                }
                miniCard.css("--font-size", fontSize);
                minigrid.append(miniCard);
              } else {
                //check if the remoteProducerId is null and the stream is null
                if (
                  remoteProducerId == "youyou" ||
                  remoteProducerId == "youyouyou"
                ) {
                  if (!videoAlreadyOn) {
                    name = "You";
                    if (islevel == "2" && eventType != "chat") {
                      name = "You (Host)";
                    }

                    const initials = name; //.toUpperCase();
                    let miniCard = $('<div class="mini-carded first"></div>');

                    miniCard.attr("data-initials", initials);
                    let fontSize = "1.35em";
                    if (window.matchMedia("(max-width: 576px)").matches) {
                      if (dispActiveNames.length > 8) {
                        fontSize = "1.1em";
                      } else if (dispActiveNames.length > 12) {
                        fontSize = "0.85em";
                      }
                    }
                    miniCard.css("--font-size", fontSize);
                    minigrid.append(miniCard);
                  } else {
                    participant = {
                      id: "youyouyou",
                      stream:
                        keepBackground && virtualStream
                          ? virtualStream
                          : localStreamVideo,
                      name: "youyouyou",
                    };
                    participant_ = {
                      id: "youyou",
                      videoID: "youyou",
                      name: "youyouyou",
                      stream:
                        keepBackground && virtualStream
                          ? virtualStream
                          : localStreamVideo,
                    };

                    remoteProducerId = "youyouyou";

                    let miniCard;
                    let card;

                    let elementSize = {
                      width: window.innerWidth / 2,
                      height: window.innerHeight / 2,
                    };

                    if (
                      forChat &&
                      forChatMini &&
                      forChatID[0].includes("youyouyou") &&
                      numtoadd > 1 &&
                      part_with_video > 1
                    ) {
                      card = createCardElements(
                        participant,
                        participant_,
                        remoteProducerId,
                        false
                      );
                      miniCard = forChatCard;

                      elementSize = {
                        width: 120,
                        height: 120,
                      };
                    } else {
                      card = createCardElements(
                        participant,
                        participant_,
                        remoteProducerId,
                        false
                      );
                      miniCard = $('<div class="mini-card first"></div>');

                      elementSize = {
                        width: window.innerWidth / 2,
                        height: window.innerHeight / 2,
                      };
                    }

                    miniCard.addClass("active-video");
                    miniCard.append(card);

                    minigrid.append(miniCard);

                    if (eventType == "chat") {
                      //add a double click event listener to the card
                      let clickCount = 0;
                      let term_id = remoteProducerId;

                      let elementSize = {
                        width: window.innerWidth / 2,
                        height: window.innerHeight / 2,
                      };

                      async function handleDoubleClick_1() {
                        clickCount++;

                        if (clickCount === 1) {
                          clickTimeout = setTimeout(function () {
                            clickCount = 0;
                          }, 300);
                        }

                        if (clickCount === 2) {
                          clearTimeout(clickTimeout);
                          clickCount = 0;

                          part_with_video = 0;
                          participants.forEach((participant) => {
                            if (participant.videoOn) {
                              part_with_video = part_with_video + 1;
                            }
                          });

                          if (part_with_video > 1) {
                            // Create or remove the videoModal based on size
                            if (
                              elementSize.width >= window.innerWidth / 3 &&
                              elementSize.height >= window.innerHeight / 3
                            ) {
                              $(".videoModal").remove();
                              let videoModal = $(
                                '<div class="videoModal"></div>'
                              );
                              videoModal.css({
                                width: "120px",
                                height: "120px",
                              });

                              videoModal.attr("id", "videoModal_" + term_id);

                              elementSize = {
                                width: videoModal.width(),
                                height: videoModal.height(),
                              };

                              // Attach the same double-click logic to the videoModal click event
                              videoModal.on("click", handleDoubleClick_1);

                              handleVideoSwitch(
                                term_id,
                                0,
                                videoModal,
                                term_id
                              );

                              videoModal.draggable();

                              $("body").append(videoModal);
                            }
                          }
                        }
                      }

                      miniCard.on("click", handleDoubleClick_1);
                    }
                  }
                } else {
                  //get from participants the participant with the remoteProducerId
                  participant_ = ref_participants.find((obj) => {
                    return obj.videoID === remoteProducerId;
                  });

                  if (participant_) {
                    let card;
                    let miniCard;

                    let elementSize = {
                      width: window.innerWidth / 2,
                      height: window.innerHeight / 2,
                    };

                    if (
                      forChat &&
                      forChatMini &&
                      forChatID[0].includes(remoteProducerId) &&
                      numtoadd > 1 &&
                      part_with_video > 1
                    ) {
                      card = createCardElements(
                        participant,
                        participant_,
                        remoteProducerId
                      );

                      miniCard = forChatCard;

                      elementSize = {
                        width: 120,
                        height: 120,
                      };
                    } else {
                      card = createCardElements(
                        participant,
                        participant_,
                        remoteProducerId
                      );
                      miniCard = $('<div class="mini-card first"></div>');

                      elementSize = {
                        width: window.innerWidth / 2,
                        height: window.innerHeight / 2,
                      };
                    }

                    miniCard.addClass("active-video");
                    miniCard.append(card);
                    minigrid.append(miniCard);

                    if (eventType == "chat") {
                      //add a double click event listener to the card
                      let clickCount = 0;
                      let term_id = remoteProducerId;

                      let elementSize = {
                        width: window.innerWidth / 2,
                        height: window.innerHeight / 2,
                      };

                      async function handleDoubleClick_2() {
                        clickCount++;

                        if (clickCount === 1) {
                          clickTimeout = setTimeout(function () {
                            clickCount = 0;
                          }, 300);
                        }

                        if (clickCount === 2) {
                          clearTimeout(clickTimeout);
                          clickCount = 0;

                          part_with_video = 0;
                          participants.forEach((participant) => {
                            if (participant.videoOn) {
                              part_with_video = part_with_video + 1;
                            }
                          });

                          if (part_with_video > 1) {
                            // Create or remove the videoModal based on size
                            if (
                              elementSize.width >= window.innerWidth / 3 &&
                              elementSize.height >= window.innerHeight / 3
                            ) {
                              $(".videoModal").remove();
                              let videoModal = $(
                                '<div class="videoModal"></div>'
                              );
                              videoModal.css({
                                width: "120px",
                                height: "120px",
                              });
                              videoModal.attr("id", "videoModal_" + term_id);

                              elementSize = {
                                width: videoModal.width(),
                                height: videoModal.height(),
                              };

                              // Attach the same double-click logic to the videoModal click event
                              videoModal.on("click", handleDoubleClick_2);

                              handleVideoSwitch(
                                term_id,
                                0,
                                videoModal,
                                term_id
                              );

                              videoModal.draggable();

                              $("body").append(videoModal);
                            }
                          }
                        }
                      }

                      miniCard.on("click", handleDoubleClick_2);
                    }
                  }
                }
              }

              if (i == numtoadd - 1) {
                if (ind == 0) {
                  $("#minigrid-home").append(minigrid);
                } else {
                  $(`#minigrid-${ind}`).append(minigrid);
                }

                updateMiniCardsGrid(numRows, numCols, true, actualRows, ind);
              }
            }

            //if we have more than 4 videos, we need to add a new row
            numtoadd = altGridStreams.length;

            if (!removeAltGrid) {
              //remove mini grid 1
              if (ind == 0) {
                $(`#minigrid-home .minigrid1`).remove();
              } else {
                $(`#minigrid-${ind} .minigrid1`).remove();
              }

              let minigrid1 = $(
                '<div class="minigrid1" style="display: grid; grid-gap: 3px; justify-content: center;width: 100%;margin: 0%;padding: 0%;margin-top:2px;"></div>'
              );

              for (let i = 0; i < numtoadd; i++) {
                let participant = altGridStreams[i];

                let remoteProducerId = participant.producerId;

                let pseudoName;
                let participant_;

                //check if there is .name in the participant object and if it is null
                if (
                  participant.hasOwnProperty("producerId") &&
                  participant.producerId != null &&
                  participant.producerId !== ""
                ) {
                  //actual video
                  pseudoName = false;
                } else {
                  pseudoName = true;
                }

                if (pseudoName) {
                  participant_ = participant;
                  remoteProducerId = participant.name;

                  let miniCard = createCardElements(
                    participant,
                    participant_,
                    remoteProducerId,
                    true,
                    false
                  );

                  const initials = participant.name;
                  miniCard.addClass("active-video");
                  miniCard.addClass("mini-carded");
                  miniCard.attr("data-initials", initials);
                  let fontSize = "1.35em";
                  if (window.matchMedia("(max-width: 576px)").matches) {
                    if (dispActiveNames.length > 8) {
                      fontSize = "1.1em";
                    } else if (dispActiveNames.length > 12) {
                      fontSize = "0.85em";
                    }
                  }
                  miniCard.css("--font-size", fontSize);
                  minigrid1.append(miniCard);
                } else {
                  participant_ = ref_participants.find((obj) => {
                    return obj.videoID === remoteProducerId;
                  });

                  card = createCardElements(
                    participant,
                    participant_,
                    remoteProducerId
                  );

                  // Append the card to the minigrid
                  let miniCard = $('<div class="mini-card first"></div>');
                  miniCard.addClass("active-video");
                  miniCard.append(card);
                  minigrid1.append(miniCard);
                }

                //if is the last one, updateMiniCardsGrid(activeVideos); compare with actives-numtoadd
                if (i == numtoadd - 1) {
                  if (ind == 0) {
                    $("#minigrid-home").append(minigrid1);
                  } else {
                    $(`#minigrid-${ind}`).append(minigrid1);
                  }

                  updateMiniCardsGrid(1, lastrowcols, false, actualRows, ind);
                }
              }
            }
          }

          $(window).on("orientationchange", async function () {
            // function to handle orientation change
            let orientation = checkOrientation();
            screenForceFullDisplay = forceFullDisplay;
            if (orientation === "portrait") {
              if (window.matchMedia("(max-width: 768px)").matches) {
                if (shareScreenStarted || shared) {
                  screenForceFullDisplay = false;
                }
              }
            }

            //update the ui
            await onScreenChanges(true);

            await prepopulateUserMedia(hostLabel);
          });

          async function handleVideoSwitch(term_id, action, forChatCard, id) {
            //check if term_id contains youyou
            let filterYouYou = term_id.includes("youyou");

            doMin = false;
            let idss = [];

            if (action == 0) {
              doMin = true;
              idss = [term_id, ""];
            } else {
              idss = ["", term_id];
              $(".videoModal").remove();
            }

            //display the video
            await dispStreams(
              chatRefStreams,
              0,
              false,
              doMin,
              forChatCard,
              idss
            );
          }

          $(window).on("resize", async function () {
            // function to handle window resize
            await onScreenChanges(true);
            await prepopulateUserMedia(hostLabel);
          });

          function isBrowserBarHidden() {
            //function to check if the browser bar is hidden

            // Calculate the height of the visible content area (viewport)
            const viewportHeight = window.innerHeight;

            // Calculate the height of the entire browser window, including any hidden parts
            const windowHeight = screen.height;

            // Calculate the height of the browser chrome (address bar + menu bar)
            let chromeHeight;

            if (windowHeight - viewportHeight < 50) {
              chromeHeight = 1;
            } else {
              chromeHeight = 0;
            }

            // If the chrome height is greater than zero, the browser bar is visible
            return chromeHeight > 0;
          }

          async function onScreenChanges(changed = false) {
            //function to handle screen changes

            //adjust the height of the main and sub aspect
            let windowHeight = $(window).innerHeight();
            let windowWidth = $(window).width();
            //get the maximum of both and set it to the height of the main aspect
            let height = windowHeight; // Math.max(windowHeight, windowWidth);

            // Usage
            if (isBrowserBarHidden()) {
              windowHeight = $(document).height();
              height = windowHeight;
            } else {
            }

            if (eventType == "broadcast" || eventType == "chat") {
              //remove element with id of controlButtons
              let addForBasic = false;

              if (eventType == "broadcast") {
                addForBasic = true;
                $(".othergrid").remove();
                itemPageLimit = 1;

                let height100 = 1 * windowHeight;

                $("#mainAspect").css("height", height100);
                $(".maingrid").css("height", height100);
              } else {
                await moveBoard();
                $(".maingrid").remove();
                itemPageLimit = 2;
              }

              $("#subAspect").remove();

              ///remove nay padding and margin on the mainAspect
              $("#mainAspect").css("padding", 0);
              $("#mainAspect").css("margin", 0);

              //remove element with id of controlButtons
              $("#controlButtons").remove();

              addFloatingMediaButtons(addForBasic);
            } else {
              let height95 = 0.95 * height;
              let height5 = 0.05 * height;

              $("#mainAspect").css("height", height95);
              $("#subAspect").css("height", height5);

              if (
                eventType == "conference" &&
                !(shareScreenStarted || shared)
              ) {
                $(".othergrid").css("height", height95);
              }
            }

            // update the mini cards grid
            await reorderStreams(false, changed);
          }

          async function changeVids(screenChanged = false) {
            //function to change the videos on the screen
            // Call updateMiniCardsGrid() with the current number of rows and columns

            let alVideoStreams = await allVideoStreams;
            p_activeNames = await activeNames;
            p_dispActiveNames = await dispActiveNames;

            if (shareScreenStarted || (shareScreen && shared)) {
              alVideoStreams = await newLimitedStreams;

              activeNames = [];
            } else {
            }

            activeNames = [];
            dispActiveNames = [];

            ref_participants = await participants;

            let temp = await alVideoStreams;

            await temp.forEach((stream) => {
              //find the participant with the same videoID
              try {
                let participant = ref_participants.find((obj) => {
                  return obj.videoID === stream.producerId;
                });
                // if not found and producerid is not youyou or youyouyou, remove the stream
                if (
                  !participant &&
                  stream.producerId != "youyou" &&
                  stream.producerId != "youyouyou"
                ) {
                  alVideoStreams = alVideoStreams.filter(function (obj) {
                    return obj.producerId !== stream.producerId;
                  });
                }
              } catch (error) {}
            });

            if (eventType == "broadcast" || eventType == "chat") {
              sortAudioLoudness = false;
              //not needed
            } else {
            }

            if (shareScreenStarted || shared) {
              non_alVideoStreams = [];
              non_alVideoStreams_muted = [];
              mixed_alVideoStreams = [];
            } else {
              if (alVideoStreams.length > screenPageLimit) {
                //remove youyou and youyouyou from alVideoStreams
                alVideoStreams = alVideoStreams.filter(function (obj) {
                  return obj.producerId !== "youyou";
                });
                alVideoStreams = alVideoStreams.filter(function (obj) {
                  return obj.producerId !== "youyouyou";
                });

                //sort participants by muted = false
                ref_participants = await ref_participants.sort((a, b) =>
                  a.muted > b.muted ? 1 : -1
                );

                //sort alVideoStreams by order of participants
                let temp = [];
                await ref_participants.forEach((participant) => {
                  let stream = alVideoStreams.find((obj) => {
                    return obj.producerId === participant.videoID;
                  });
                  if (stream) {
                    temp.push(stream);
                  }
                });
                alVideoStreams = temp;

                //add youyou and youyouyou to the beginning of alVideoStreams
                let youyou = await allVideoStreams.find((obj) => {
                  return obj.producerId === "youyou";
                });

                if (!youyou) {
                  let youyouyou = await allVideoStreams.find((obj) => {
                    return obj.producerId === "youyouyou";
                  });
                  await alVideoStreams.unshift(youyouyou);
                } else {
                  await alVideoStreams.unshift(youyou);
                }
              }

              const admin = await participants.filter(
                (participant) => participant.islevel == "2"
              );
              let adminName = "";
              if (admin.length > 0) {
                adminName = await admin[0].name;
              }

              //get all participants that are not on alVideoStreams array and name is not == member and have muted = false and add them to non_alVideoStreams
              non_alVideoStreams = [];
              await ref_participants.forEach((participant) => {
                let stream = alVideoStreams.find((obj) => {
                  return obj.producerId === participant.videoID;
                });

                if (eventType != "chat" && eventType != "conference") {
                  if (
                    !stream &&
                    participant.name != member &&
                    !participant.muted &&
                    participant.name != adminName
                  ) {
                    non_alVideoStreams.push(participant);
                  }
                } else {
                  if (
                    !stream &&
                    participant.name != member &&
                    !participant.muted
                  ) {
                    non_alVideoStreams.push(participant);
                  }
                }
              });

              if (sortAudioLoudness) {
                //sort non_alVideoStreams_muted by loudness

                await non_alVideoStreams.sort((a, b) => {
                  const avgLoudnessA =
                    audioDecibels.find((obj) => obj.name === a.name)
                      ?.averageLoudness || 127;
                  const avgLoudnessB =
                    audioDecibels.find((obj) => obj.name === b.name)
                      ?.averageLoudness || 127;

                  return avgLoudnessB - avgLoudnessA;
                });

                if (
                  meetingDisplayType == "video" &&
                  meetingVideoOptimized &&
                  recordingVideoOptimized &&
                  recordingDisplayType == "video"
                ) {
                } else {
                  mixed_alVideoStreams = await mixStreams(
                    alVideoStreams,
                    non_alVideoStreams
                  );
                }
              }

              //get the rest with muted = true and add them to non_alVideoStreams_muted
              non_alVideoStreams_muted = [];
              await ref_participants.forEach((participant) => {
                let stream = alVideoStreams.find((obj) => {
                  return obj.producerId === participant.videoID;
                });

                if (eventType != "chat" && eventType != "conference") {
                  if (
                    !stream &&
                    participant.name != member &&
                    participant.muted &&
                    participant.name != adminName
                  ) {
                    non_alVideoStreams_muted.push(participant);
                  }
                } else {
                  if (
                    !stream &&
                    participant.name != member &&
                    participant.muted
                  ) {
                    non_alVideoStreams_muted.push(participant);
                  }
                }
              });
            }

            if (eventType == "conference" && islevel != "2") {
              // try and look for the admin stream and add it to the beginning of alVideoStreams
              // try video first then audio

              let host = await participants.find((obj) => {
                return obj.islevel == "2";
              });

              if (host) {
                remoteProducerId = await host.videoID;
                // get the stream from allvideostream with the same id as remoteProducerId

                if (islevel == "2") {
                  host.stream =
                    keepBackground && virtualStream
                      ? virtualStream
                      : await localStreamVideo;
                } else {
                  // first check if the host is in alVideoStreams
                  let hostVideo = await alVideoStreams.find((obj) => {
                    return obj.producerId === remoteProducerId;
                  });

                  if (!hostVideo) {
                    streame = await oldAllStreams.find(
                      (streame) => streame.producerId == remoteProducerId
                    );
                    // add streame to lStreams
                    if (streame) {
                      //remove any stream with name of host.name from [alVideoStreams,non_alVideoStreams,non_alVideoStreams_muted]
                      alVideoStreams = await alVideoStreams.filter(function (
                        obj
                      ) {
                        return obj.producerId !== host.videoID;
                      });

                      non_alVideoStreams = await non_alVideoStreams.filter(
                        function (obj) {
                          return obj.name !== host.name;
                        }
                      );

                      non_alVideoStreams_muted =
                        await non_alVideoStreams_muted.filter(function (obj) {
                          return obj.name !== host.name;
                        });

                      if (sortAudioLoudness) {
                        mixed_alVideoStreams =
                          await mixed_alVideoStreams.filter(function (obj) {
                            return obj.name !== host.name;
                          });

                        non_alVideoStreams_muted =
                          await non_alVideoStreams_muted.filter(function (obj) {
                            return obj.name !== host.name;
                          });

                        if (
                          meetingDisplayType == "video" &&
                          meetingVideoOptimized
                        ) {
                          await alVideoStreams.unshift(streame);
                        } else {
                          await mixed_alVideoStreams.unshift(streame);
                        }
                      } else {
                        await alVideoStreams.unshift(streame);
                      }
                    } else {
                      //look for audio stream of host if the main video stream is not found

                      await ref_participants.forEach(async (participant) => {
                        let stream = await alVideoStreams.find((obj) => {
                          return (
                            obj.producerId === participant.videoID &&
                            participant.name == host.name
                          );
                        });

                        if (stream) {
                          if (sortAudioLoudness) {
                            //remove any stream with name of host.name from mixed_alVideoStreams and return
                            mixed_alVideoStreams =
                              await mixed_alVideoStreams.filter(function (obj) {
                                return obj.name !== host.name;
                              });

                            non_alVideoStreams_muted =
                              await non_alVideoStreams_muted.filter(function (
                                obj
                              ) {
                                return obj.name !== host.name;
                              });

                            await mixed_alVideoStreams.unshift(participant);
                          } else {
                            //remove any stream with name of host.name from non_alVideoStreams and return
                            non_alVideoStreams =
                              await non_alVideoStreams.filter(function (obj) {
                                return obj.name !== host.name;
                              });

                            await non_alVideoStreams.unshift(participant);

                            return;
                          }
                        }
                      });
                    }
                  }
                }
              }
            }

            let allStreamsPaged = [];

            if (sortAudioLoudness) {
              if (meetingDisplayType == "video") {
                if (meetingVideoOptimized) {
                  // video only
                  allStreamsPaged = await [...alVideoStreams];
                } else {
                  allStreamsPaged = await [...mixed_alVideoStreams];
                }
              } else if (meetingDisplayType == "media") {
                allStreamsPaged = await [...mixed_alVideoStreams];
              } else if (meetingDisplayType == "all") {
                allStreamsPaged = await [
                  ...mixed_alVideoStreams,
                  ...non_alVideoStreams_muted,
                ];
              }
            } else {
              if (meetingDisplayType == "video") {
                allStreamsPaged = await [...alVideoStreams];
              } else if (meetingDisplayType == "media") {
                allStreamsPaged = await [
                  ...alVideoStreams,
                  ...non_alVideoStreams,
                ];
              } else if (meetingDisplayType == "all") {
                allStreamsPaged = await [
                  ...alVideoStreams,
                  ...non_alVideoStreams,
                  ...non_alVideoStreams_muted,
                ];
              }
            }

            let allStreamsPagedRecord = [];

            if (sortAudioLoudness) {
              if (recordingDisplayType == "video") {
                if (recordingVideoOptimized) {
                  // video only
                  allStreamsPagedRecord = await [...alVideoStreams];
                } else {
                  allStreamsPagedRecord = await [...mixed_alVideoStreams];
                }
              } else if (recordingDisplayType == "media") {
                allStreamsPagedRecord = await [...mixed_alVideoStreams];
              } else if (recordingDisplayType == "all") {
                allStreamsPagedRecord = await [
                  ...mixed_alVideoStreams,
                  ...non_alVideoStreams_muted,
                ];
              }
            } else {
              if (recordingDisplayType == "video") {
                allStreamsPagedRecord = await [...alVideoStreams];
              } else if (recordingDisplayType == "media") {
                allStreamsPagedRecord = await [
                  ...alVideoStreams,
                  ...non_alVideoStreams,
                ];
              } else if (recordingDisplayType == "all") {
                allStreamsPagedRecord = await [
                  ...alVideoStreams,
                  ...non_alVideoStreams,
                  ...non_alVideoStreams_muted,
                ];
              }
            }

            paginatedStreams = [];
            let combinedStreams = [];
            let limit = await itemPageLimit;

            if (shareScreenStarted || shared) {
              limit = await screenPageLimit;
            }

            let firstPage = [];
            let remainingStreams = [];
            let page;

            let limit_ = (await limit) + 1;

            if (eventType == "conference") {
              if (shared || shareScreenStarted) {
              } else {
                limit_ = (await limit_) - 1;
              }
            }

            let nForReadjustRecords = await allStreamsPagedRecord.slice(
              0,
              limit_
            );

            // Create pagination
            // Add the first page to the pagination
            // Add the first page to the pagination
            let memberInRoom = false;
            let memberRoom = -1;
            let mainRoomsLength = 0;
            let filterHost = false;
            if (breakOutRoomStarted && !breakOutRoomEnded) {
              let tempBreakoutRooms = JSON.parse(JSON.stringify(breakoutRooms));
              //get the host name and add it to the room
              let host = await participants.find((obj) => obj.islevel == "2");
              for (let room of tempBreakoutRooms) {
                try {
                  let currentStreams = [];
                  const roomIndex = tempBreakoutRooms.indexOf(room);
                  if (hostNewRoom != -1 && roomIndex == hostNewRoom) {
                    //push the host into the room; avoid duplicates

                    if (host) {
                      if (!room.map((obj) => obj.name).includes(host.name)) {
                        room = [
                          ...room,
                          { name: host.name, breakRoom: roomIndex },
                        ];
                        filterHost = true;
                      }
                    }
                  }

                  for (let participant of room) {
                    if (participant.name == member && !memberInRoom) {
                      memberInRoom = true;
                      memberRoom = participant.breakRoom;
                    }
                    let streams = await allStreamsPaged.filter((stream) => {
                      if (
                        (stream.hasOwnProperty("producerId") &&
                          stream.producerId != null &&
                          stream.producerId !== "") ||
                        (stream.hasOwnProperty("audioID") &&
                          stream.audioID != null &&
                          stream.audioID !== "")
                      ) {
                        let producerId = stream.producerId || stream.audioID;
                        let matchingParticipant = ref_participants.find(
                          (obj) =>
                            obj.audioID === producerId ||
                            obj.videoID === producerId ||
                            ((producerId == "youyou" ||
                              producerId == "youyouyou") &&
                              member == participant.name)
                        );
                        return (
                          (matchingParticipant &&
                            matchingParticipant.name === participant.name) ||
                          (participant.name == member &&
                            (producerId == "youyou" ||
                              producerId == "youyouyou"))
                        );
                      } else {
                        return (
                          stream.hasOwnProperty("name") &&
                          stream.name == participant.name
                        );
                      }
                    });

                    for (let stream of streams) {
                      if (currentStreams.length < limit_) {
                        currentStreams.push(stream);
                      }
                    }
                  }
                  await paginatedStreams.push(currentStreams);
                } catch (error) {}
              }

              //let gets all the ones that are not in the breakout rooms
              let remainingStreams = await allStreamsPaged.filter((stream) => {
                if (
                  (stream.hasOwnProperty("producerId") &&
                    stream.producerId != null &&
                    stream.producerId !== "") ||
                  (stream.hasOwnProperty("audioID") &&
                    stream.audioID != null &&
                    stream.audioID !== "")
                ) {
                  let producerId = stream.producerId || stream.audioID;
                  let matchingParticipant = ref_participants.find(
                    (obj) =>
                      obj.audioID === producerId ||
                      obj.videoID === producerId ||
                      ((producerId == "youyou" || producerId == "youyouyou") &&
                        member == obj.name)
                  );
                  return (
                    matchingParticipant &&
                    !breakoutRooms
                      .flat()
                      .map((obj) => obj.name)
                      .includes(matchingParticipant.name) &&
                    (!filterHost || matchingParticipant.name != host.name)
                  );
                } else {
                  return (
                    !breakoutRooms
                      .flat()
                      .map((obj) => obj.name)
                      .includes(stream.name) &&
                    (!filterHost || stream.name != host.name)
                  );
                }
              });

              //Add the member stream to the beginning of the remaining streams (bring to start)
              if (memberInRoom) {
                let memberStream = await allStreamsPaged.find((stream) => {
                  if (
                    stream.hasOwnProperty("producerId") &&
                    stream.producerId != null &&
                    stream.producerId !== ""
                  ) {
                    return (
                      stream.producerId == "youyou" ||
                      stream.producerId == "youyouyou"
                    );
                  }
                });
                if (memberStream && !remainingStreams.includes(memberStream)) {
                  await remainingStreams.unshift(memberStream);
                }
              }

              let remainingPaginatedStreams = [];

              // Add the remaining streams to the pagination
              if (remainingStreams.length > 0) {
                firstPage = await remainingStreams.slice(0, limit_);
                await remainingPaginatedStreams.push(firstPage);

                for (let i = limit_; i < remainingStreams.length; i += limit) {
                  page = await remainingStreams.slice(i, i + limit);
                  await remainingPaginatedStreams.push(page);
                }
              }

              mainRoomsLength = await remainingPaginatedStreams.length;

              // Add the remaining streams to the beginning of the paginatedStreams
              for (let i = remainingPaginatedStreams.length - 1; i >= 0; i--) {
                await paginatedStreams.unshift(remainingPaginatedStreams[i]);
              }
            } else {
              firstPage = await allStreamsPaged.slice(0, limit_);
              await paginatedStreams.push(firstPage);

              // Add the remaining streams to the pagination
              for (let i = limit_; i < allStreamsPaged.length; i += limit) {
                page = await allStreamsPaged.slice(i, i + limit);
                await paginatedStreams.push(page);
              }
            }

            //operation to update the ui
            $(".minigrid-content").children().not("#minigrid-home").remove();
            await $(".nav-minigrid").remove();

            let navHomer;

            prevDoPaginate = await doPaginate;
            doPaginate = false;

            let activeClass = "";
            let isActive = false;
            let showTab = "";

            if (paginatedStreams.length > 1) {
              navHomer = `
  <li class="nav-item flex-fill" style="margin: 0 auto; padding: 0 auto; border-radius: 0;" >
  <a class="nav-link custom-link" style="margin: 0 auto; padding: 0 auto;" id="minigrid-home-tab" data-toggle="tab" href="#minigrid-home" role="tab" aria-controls="minigrid-home" aria-selected="true"><i class="fas fa-star fa-lg"></i></a>
  </li>
  `;

              if (shareScreenStarted || shared) {
                doPaginate = false;
              } else {
                doPaginate = true;
              }

              if (currentUserPage > paginatedStreams.length - 1) {
                if (breakOutRoomStarted && !breakOutRoomEnded) {
                  currentUserPage = 0;
                } else {
                  currentUserPage = (await paginatedStreams.length) - 1;
                }
              } else {
                if (currentUserPage == 0) {
                  isActive = true;
                  showTab = "show active";
                  navHomer = `
  <li class="nav-item flex-fill" style="margin: 0 auto; padding: 0 auto; border-radius: 0;" >
                      <a class="nav-link custom-link active" style="margin: 0 auto; padding: 0 auto;" id="minigrid-home-tab" data-toggle="tab" href="#minigrid-home" role="tab" aria-controls="minigrid-home" aria-selected="true"><i class="fas fa-star fa-lg"></i></a>
  </li>
  `;
                }
              }

              let nava = `<ul class="nav nav-tabs nav-minigrid mb-0 pb-0 d-flex flex-nowrap overflow-auto" id="minigrid-tab" role="tablist" style="margin: 0; padding: 0; "></ul>`;
              await $(nava).insertBefore("#minigrid-tabContent");
              await $(".nav-minigrid").append(navHomer);

              if (!isActive) {
                await generatePagination(
                  paginatedStreams.length - 1,
                  true,
                  mainRoomsLength,
                  memberRoom
                );
              } else {
                await generatePagination(
                  paginatedStreams.length - 1,
                  false,
                  mainRoomsLength,
                  memberRoom
                );
              }

              //first page
              if (screenChanged) {
                await dispStreams(paginatedStreams[0], 0);
              } else {
                await dispStreams(paginatedStreams[0], 0, true);
              }

              //current page
              if (!isActive) {
                let page = await `${currentUserPage}`;
                await handlePageChange(page, mainRoomsLength);
                await $(`#minigrid-${currentUserPage}`).addClass("show active");
              }
            } else {
              doPaginate = false;
              currentUserPage = 0;

              if (screenChanged) {
                await dispStreams(paginatedStreams[0], 0);
              } else {
                await dispStreams(paginatedStreams[0], 0, true);
              }

              if (
                prevDoPaginate != doPaginate ||
                prevMeetingDisplayType != meetingDisplayType
              ) {
                let page = await `${currentUserPage}`;
                await handlePageChange(page, mainRoomsLength);
                if (currentUserPage == 0) {
                  await $(`#minigrid-home`).addClass("show active");
                } else {
                  await $(`#minigrid-${currentUserPage}`).addClass(
                    "show active"
                  );
                }
              }
            }
          }

          async function resumePauseAudioStreams(
            breakRoom = -1,
            inBreakRoom = false
          ) {
            let room;
            let currentStreams = [];

            //if in break room, get the room with breakRoom == breakRoom
            if (inBreakRoom && breakRoom != -1) {
              room = breakoutRooms[breakRoom];
              limitedBreakRoom = room;
            } else {
              //get all participants not in breakout rooms
              room = ref_participants.filter(
                (participant) =>
                  !breakoutRooms
                    .flat()
                    .map((obj) => obj.name)
                    .includes(participant.name)
              );
              limitedBreakRoom = room;
            }

            try {
              let addHostAudio = false;
              if (islevel != "2" && eventType == "conference") {
                const roomMember = breakoutRooms.find((r) =>
                  r.find((p) => p.name == member)
                );
                let memberBreakRoom = -1;
                if (roomMember) {
                  memberBreakRoom = breakoutRooms.indexOf(roomMember);
                }
                if (
                  (inBreakRoom && breakRoom !== hostNewRoom) ||
                  (!inBreakRoom &&
                    hostNewRoom !== -1 &&
                    hostNewRoom !== memberBreakRoom)
                ) {
                  let host = participants.find((obj) => obj.islevel == "2");
                  //remove the host from the room
                  room = room.filter(
                    (participant) => participant.name !== host.name
                  );
                } else {
                  if (
                    (inBreakRoom && breakRoom == hostNewRoom) ||
                    (!inBreakRoom && hostNewRoom === -1) ||
                    (!inBreakRoom &&
                      hostNewRoom === memberBreakRoom &&
                      memberBreakRoom !== -1)
                  ) {
                    addHostAudio = true;
                  }
                }
              }

              for (let participant of room) {
                let streams = await allAudioStreams.filter((stream) => {
                  if (
                    (stream.hasOwnProperty("producerId") &&
                      stream.producerId != null &&
                      stream.producerId !== "") ||
                    (stream.hasOwnProperty("audioID") &&
                      stream.audioID != null &&
                      stream.audioID !== "")
                  ) {
                    let producerId = stream.producerId || stream.audioID;
                    let matchingParticipant = ref_participants.find(
                      (obj) => obj.audioID === producerId
                    );
                    return (
                      matchingParticipant &&
                      matchingParticipant.name === participant.name
                    );
                  }
                });

                for (let stream of streams) {
                  currentStreams.push(stream);
                }
              }

              //if webinar, add the host audio stream if it is not in the currentStreams
              if (islevel != "2" && (eventType == "webinar" || addHostAudio)) {
                let host = participants.find((obj) => obj.islevel == "2");
                let hostStream = allAudioStreams.find(
                  (obj) => obj.producerId == host.audioID
                );
                if (hostStream && !currentStreams.includes(hostStream)) {
                  currentStreams.push(hostStream);
                  // if host not in limitedBreakRoom, add it
                  if (
                    !limitedBreakRoom.map((obj) => obj.name).includes(host.name)
                  ) {
                    limitedBreakRoom.push({ name: host.name, breakRoom: -1 });
                  }
                }
              }

              await processConsumerTransportsAudio(
                consumerTransports,
                currentStreams
              );
            } catch (error) {}
          }

          async function resumePauseStreams() {
            //function to resume or pause streams

            //get the videoID of host(islevel=2), names in dispActiveNames and screenproducerId

            let host = participants.find((obj) => {
              return obj.islevel === "2";
            });

            let hostVideoID = host.videoID;

            let videosIDs = dispActiveNames.map(async (name) => {
              try {
                let participant = participants.find((obj) => {
                  return obj.name === name;
                });
                return participant.videoID;
              } catch (error) {}
            });

            let screenproducerId = remoteScreenStream.map((stream) => {
              return stream.producerId;
            });

            //now put all non-empty and non-null videoIDs in an array
            let allVideoIDs = videosIDs.filter((videoID) => {
              return videoID != null && videoID != "";
            });

            //if screenproducerId is not null or empty, add it to allVideoIDs
            if (screenId != null && screenId != "") {
              allVideoIDs.push(screenId);
            }

            //if hostVideoID is not null or empty, add it to allVideoIDs
            if (islevel != "2") {
              if (hostVideoID != null && hostVideoID != "") {
                allVideoIDs.push(hostVideoID);
              }
            }

            if (allVideoIDs.length > 0) {
              //get the transport with producerId in allVideoIDs and assign them to const consumerTransportsToResume
              const consumerTransportsToResume = consumerTransports.filter(
                (transport) =>
                  allVideoIDs.includes(transport.producerId) &&
                  transport.consumer.kind !== "audio"
              );

              //resume all consumerTransportsToResume
              // Emit consumer.pause() for each filtered transport
              for (const transport of consumerTransportsToResume) {
                try {
                  await transport.socket_.emit(
                    "consumer-resume",
                    { serverConsumerId: transport.serverConsumerTransportId },
                    async ({ resumed }) => {
                      if (resumed) {
                        await transport.consumer.resume();
                      }
                    }
                  );
                } catch (error) {}
              }
            }
          }

          async function processConsumerTransportsAudio(
            consumerTransports,
            lStreams_
          ) {
            //function to process consumer transports; pause or resume the ones that ar enot on active page and are audio

            //get paused consumer transports that are not audio
            const consumerTransportsToResume = await consumerTransports.filter(
              (transport) =>
                isValidProducerId(transport.producerId, lStreams_) &&
                transport.consumer?.paused == true &&
                transport.consumer.kind === "audio"
            );

            //get unpaused consumer transports that are not audio
            const consumerTransportsToPause = await consumerTransports.filter(
              (transport) =>
                transport.producerId &&
                transport.producerId !== null &&
                transport.producerId !== "" &&
                !lStreams_.some(
                  (stream) => stream.producerId === transport.producerId
                ) &&
                transport.consumer &&
                transport.consumer.kind &&
                transport.consumer.paused !== true &&
                transport.consumer.kind === "audio"
            );

            await sleep(100);

            // Emit consumer.pause() for each filtered transport
            for (const transport of consumerTransportsToPause) {
              // Assuming the consumer object is accessible in this scope
              await transport.consumer.pause();
              await transport.socket_.emit(
                "consumer-pause",
                { serverConsumerId: transport.serverConsumerTransportId },
                async ({ paused }) => {}
              );
            }

            function isValidProducerId(producerId, ...streamArrays) {
              return (
                producerId !== null &&
                producerId !== "" &&
                streamArrays.some((streamArray) => {
                  return (
                    streamArray.length > 0 &&
                    streamArray.some(
                      (stream) => stream?.producerId === producerId
                    )
                  );
                })
              );
            }

            // Emit consumer.pause() for each filtered transport
            for (const transport of consumerTransportsToResume) {
              await transport.socket_.emit(
                "consumer-resume",
                { serverConsumerId: transport.serverConsumerTransportId },
                async ({ resumed }) => {
                  if (resumed) {
                    await transport.consumer.resume();
                  }
                }
              );
            }
          }

          async function processConsumerTransports(
            consumerTransports,
            lStreams_
          ) {
            //function to process consumer transports; pause or resume the ones that ar enot on active page

            //get paused consumer transports that are not audio
            const consumerTransportsToResume = await consumerTransports.filter(
              (transport) =>
                isValidProducerId(
                  transport.producerId,
                  lStreams_,
                  remoteScreenStream,
                  oldAllStreams,
                  newLimitedStreams
                ) &&
                transport.consumer?.paused == true &&
                transport.consumer.kind !== "audio"
            );

            //get unpaused consumer transports that are not audio
            const consumerTransportsToPause = await consumerTransports.filter(
              (transport) =>
                transport.producerId &&
                transport.producerId !== null &&
                transport.producerId !== "" &&
                !lStreams_.some(
                  (stream) => stream.producerId === transport.producerId
                ) &&
                transport.consumer &&
                transport.consumer.kind &&
                transport.consumer.paused !== true &&
                transport.consumer.kind !== "audio" &&
                !remoteScreenStream.some(
                  (stream) => stream.producerId === transport.producerId
                ) &&
                !oldAllStreams.some(
                  (stream) => stream.producerId === transport.producerId
                ) &&
                !newLimitedStreams.some(
                  (stream) => stream.producerId === transport.producerId
                )
            );

            await sleep(100);

            // Emit consumer.pause() for each filtered transport
            for (const transport of consumerTransportsToPause) {
              // Assuming the consumer object is accessible in this scope
              await transport.consumer.pause();
              await transport.socket_.emit(
                "consumer-pause",
                { serverConsumerId: transport.serverConsumerTransportId },
                async ({ paused }) => {}
              );
            }

            function isValidProducerId(producerId, ...streamArrays) {
              return (
                producerId !== null &&
                producerId !== "" &&
                streamArrays.some((streamArray) => {
                  return (
                    streamArray.length > 0 &&
                    streamArray.some(
                      (stream) => stream?.producerId === producerId
                    )
                  );
                })
              );
            }

            // Emit consumer.pause() for each filtered transport
            for (const transport of consumerTransportsToResume) {
              await transport.socket_.emit(
                "consumer-resume",
                { serverConsumerId: transport.serverConsumerTransportId },
                async ({ resumed }) => {
                  if (resumed) {
                    await transport.consumer.resume();
                  }
                }
              );
            }
          }

          async function dispStreams(
            lStreams,
            ind,
            auto = false,
            ChatSkip = false,
            forChatCard = null,
            forChatID = null,
            breakRoom = -1,
            inBreakRoom = false
          ) {
            //function to display streams

            let proceed = true;

            let lStreams_ = await lStreams.filter((stream) => {
              return (
                stream.producerId != "youyou" &&
                stream.producerId != "youyouyou"
              );
            });

            lStreams_ = await lStreams_.filter((stream) => {
              return (
                stream.id != "youyou" &&
                stream.id != "youyouyou" &&
                stream.name != "youyou" &&
                stream.name != "youyouyou"
              );
            });

            if (eventType == "chat") {
              proceed = true;
            } else if (ind == 0 || (islevel != "2" && currentUserPage == ind)) {
              proceed = false;

              //get the name of every participant in lStreams if stream !null and assign it to activeNames
              await lStreams_.forEach((stream) => {
                let checker = false;
                let check_level = 0;

                if (recordingDisplayType === "video") {
                  if (recordingVideoOptimized) {
                    if (
                      stream.hasOwnProperty("producerId") &&
                      stream.producerId != null &&
                      stream.producerId !== ""
                    ) {
                      checker = true;
                      check_level = 0;
                    }
                  } else {
                    if (
                      (stream.hasOwnProperty("producerId") &&
                        stream.producerId != null &&
                        stream.producerId !== "") ||
                      (stream.hasOwnProperty("audioID") &&
                        stream.audioID != null &&
                        stream.audioID !== "")
                    ) {
                      checker = true;
                      check_level = 1;
                    }
                  }
                } else if (recordingDisplayType === "media") {
                  if (
                    (stream.hasOwnProperty("producerId") &&
                      stream.producerId != null &&
                      stream.producerId !== "") ||
                    (stream.hasOwnProperty("audioID") &&
                      stream.audioID != null &&
                      stream.audioID !== "")
                  ) {
                    checker = true;
                    check_level = 1;
                  }
                } else {
                  if (
                    (stream.hasOwnProperty("producerId") &&
                      stream.producerId != null &&
                      stream.producerId !== "") ||
                    (stream.hasOwnProperty("audioID") &&
                      stream.audioID != null &&
                      stream.audioID !== "") ||
                    (stream.hasOwnProperty("name") &&
                      stream.name !== null &&
                      stream.name != "")
                  ) {
                    checker = true;
                    check_level = 2;
                  }
                }

                let participant;

                if (checker) {
                  // find the participant with the same videoID as the stream
                  if (check_level == 0) {
                    if (
                      stream.hasOwnProperty("producerId") &&
                      stream.producerId != null &&
                      stream.producerId !== ""
                    ) {
                      participant = streamNames.find(
                        (obj) => obj.producerId === stream.producerId
                      );
                    }
                  } else if (check_level == 1) {
                    // find for either producerId or name
                    if (
                      stream.hasOwnProperty("producerId") &&
                      stream.producerId != null &&
                      stream.producerId !== ""
                    ) {
                      participant = streamNames.find(
                        (obj) => obj.producerId === stream.producerId
                      );
                    }
                    if (!participant) {
                      if (
                        stream.hasOwnProperty("audioID") &&
                        stream.audioID != null &&
                        stream.audioID !== ""
                      ) {
                        participant = audStreamNames.find(
                          (obj) => obj.producerId === stream.audioID
                        );
                        if (!participant) {
                          participant = ref_participants.find(
                            (obj) => obj.audioID === stream.audioID
                          );
                        }
                      }
                    }
                  } else if (check_level == 2) {
                    if (
                      stream.hasOwnProperty("producerId") &&
                      stream.producerId != null &&
                      stream.producerId !== ""
                    ) {
                      participant = streamNames.find(
                        (obj) => obj.producerId === stream.producerId
                      );
                    }
                    if (!participant) {
                      if (
                        stream.hasOwnProperty("audioID") &&
                        stream.audioID != null &&
                        stream.audioID !== ""
                      ) {
                        participant = audStreamNames.find(
                          (obj) => obj.producerId === stream.audioID
                        );
                        if (!participant) {
                          participant = ref_participants.find(
                            (obj) => obj.audioID === stream.audioID
                          );
                        }
                      }
                    }
                    if (!participant) {
                      if (
                        stream.hasOwnProperty("name") &&
                        stream.name !== null &&
                        stream.name != ""
                      ) {
                        participant = ref_participants.find(
                          (obj) => obj.name === stream.name
                        );
                      }
                    }
                  }

                  // push the name of the participant to activeNames
                  if (participant) {
                    // if activeNames does not include the name of the participant, push it
                    if (!activeNames.includes(participant.name)) {
                      activeNames.push(participant.name);
                    }
                  }
                }
              });

              await lStreams_.forEach((stream) => {
                let disp_checker = false;
                let disp_check_level = 0;

                if (meetingDisplayType == "video") {
                  if (meetingVideoOptimized) {
                    if (
                      stream.hasOwnProperty("producerId") &&
                      stream.producerId != null &&
                      stream.producerId !== ""
                    ) {
                      disp_checker = true;
                      disp_check_level = 0;
                    }
                  } else {
                    if (
                      (stream.hasOwnProperty("producerId") &&
                        stream.producerId != null &&
                        stream.producerId !== "") ||
                      (stream.hasOwnProperty("audioID") &&
                        stream.audioID != null &&
                        stream.audioID !== "")
                    ) {
                      disp_checker = true;
                      disp_check_level = 1;
                    }
                  }
                } else if (meetingDisplayType == "media") {
                  if (
                    (stream.hasOwnProperty("producerId") &&
                      stream.producerId != null &&
                      stream.producerId !== "") ||
                    (stream.hasOwnProperty("audioID") &&
                      stream.audioID != null &&
                      stream.audioID !== "")
                  ) {
                    disp_checker = true;
                    disp_check_level = 1;
                  }
                } else {
                  if (
                    (stream.hasOwnProperty("producerId") &&
                      stream.producerId != null &&
                      stream.producerId !== "") ||
                    (stream.hasOwnProperty("audioID") &&
                      stream.audioID != null &&
                      stream.audioID !== "") ||
                    (stream.hasOwnProperty("name") &&
                      stream.name !== null &&
                      stream.name != "")
                  ) {
                    disp_checker = true;
                    disp_check_level = 2;
                  }
                }

                let participant_;

                if (disp_checker) {
                  if (disp_check_level == 0) {
                    if (
                      stream.hasOwnProperty("producerId") &&
                      stream.producerId != null &&
                      stream.producerId !== ""
                    ) {
                      participant_ = streamNames.find(
                        (obj) => obj.producerId === stream.producerId
                      );
                    }
                  } else if (disp_check_level == 1) {
                    // find for either producerId or name
                    if (
                      stream.hasOwnProperty("producerId") &&
                      stream.producerId != null &&
                      stream.producerId !== ""
                    ) {
                      participant_ = streamNames.find(
                        (obj) => obj.producerId === stream.producerId
                      );
                    }
                    if (!participant_) {
                      if (
                        stream.hasOwnProperty("audioID") &&
                        stream.audioID != null &&
                        stream.audioID !== ""
                      ) {
                        participant_ = audStreamNames.find(
                          (obj) => obj.producerId === stream.audioID
                        );
                        if (!participant_) {
                          participant_ = ref_participants.find(
                            (obj) => obj.audioID === stream.audioID
                          );
                        }
                      }
                    }
                  } else if (disp_check_level == 2) {
                    if (
                      stream.hasOwnProperty("producerId") &&
                      stream.producerId != null &&
                      stream.producerId !== ""
                    ) {
                      participant_ = streamNames.find(
                        (obj) => obj.producerId === stream.producerId
                      );
                    }
                    if (!participant_) {
                      if (
                        stream.hasOwnProperty("audioID") &&
                        stream.audioID != null &&
                        stream.audioID !== ""
                      ) {
                        participant_ = audStreamNames.find(
                          (obj) => obj.producerId === stream.audioID
                        );
                        if (!participant_) {
                          participant_ = ref_participants.find(
                            (obj) => obj.audioID === stream.audioID
                          );
                        }
                      }
                    }
                    if (!participant_) {
                      if (
                        stream.hasOwnProperty("name") &&
                        stream.name !== null &&
                        stream.name != ""
                      ) {
                        participant_ = ref_participants.find(
                          (obj) => obj.name === stream.name
                        );
                      }
                    }
                  }
                }

                // push the name of the participant to activeNames
                if (participant_) {
                  // if dispActiveNames does not include the name of the participant, push it
                  if (!dispActiveNames.includes(participant_.name)) {
                    dispActiveNames.push(participant_.name);
                    if (!p_dispActiveNames.includes(participant_.name)) {
                      proceed = true;
                    }
                  }
                }
              });

              if (lStreams_.length < 1) {
                if (shareScreenStarted || shared) {
                  proceed = true;
                } else if (!firstAll) {
                  proceed = true;
                }
              }

              if (shareScreenStarted || shared) {
              } else {
                if (prevMainHeightWidth != mainHeightWidth) {
                  updateMainWindow = true;
                }
              }

              nForReadjustRecord = await activeNames.length;
            }

            if (!proceed && auto) {
              if (updateMainWindow) {
                if (!lock_screen && !shared) {
                  await prepopulateUserMedia(hostLabel);
                } else {
                  if (!first_round) {
                    await prepopulateUserMedia(hostLabel);
                  }
                }
              }

              if (ind == 0) {
                await rePort();
              }
              return;
            }

            if (eventType == "broadcast") {
              lStreams = lStreams_;
            } else if (eventType == "chat") {
              if (forChatID != null) {
                lStreams = chatRefStreams;
              } else {
                $(".videoModal").remove();
                if (islevel != "2") {
                  let host = await participants.find((obj) => {
                    return obj.islevel === "2";
                  });

                  if (host) {
                    remoteProducerId = await host.videoID;
                    // get the stream from allvideostream with the same id as remoteProducerId

                    if (islevel == "2") {
                      host.stream =
                        (await keepBackground) && virtualStream
                          ? virtualStream
                          : await localStreamVideo;
                    } else {
                      streame = await oldAllStreams.find(
                        (streame) => streame.producerId == remoteProducerId
                      );
                      // add streame to lStreams
                      if (streame) {
                        //remove any stream with name of host.name
                        lStreams = await lStreams.filter((stream) => {
                          return stream.name != host.name;
                        });

                        lStreams.push(streame);
                      }
                    }
                  }
                }

                //remove youyou and youyouyou from lStreams and then put it at the end
                let youyou = await lStreams.find((obj) => {
                  return (
                    obj.producerId === "youyou" ||
                    obj.producerId === "youyouyou"
                  );
                });

                lStreams = await lStreams.filter((stream) => {
                  return (
                    stream.producerId != "youyou" &&
                    stream.producerId != "youyouyou"
                  );
                });

                if (youyou) {
                  await lStreams.push(youyou);
                }

                chatRefStreams = await lStreams;
              }
            }

            let refLength = await lStreams.length;

            const [numtoadd, rows, cols] = await GetEstimate(refLength);
            let [
              removeAltGrid,
              numtoaddd,
              numRows,
              numCols,
              remainingVideos,
              actualRows,
            ] = await checkGrid(rows, cols, refLength);

            if (ChatSkip && eventType == "chat") {
              numRows = await 1;
              numCols = await 1;
              actualRows = await 1;
            }

            //if removeAltGrid is true then remove everyting from altGrid and add to mainGrid,check for streams on alvideoStreams and add to mainGrid that are not on mainGrid and add switching to true
            if (removeAltGrid) {
              // get minigrid1 and destroy it
              let allMiniGrid1;
              if (ind == 0) {
                allMiniGrid1 = await document.querySelectorAll(
                  `#minigrid-home .mini-grid-1`
                );
              } else {
                allMiniGrid1 = await document.querySelectorAll(
                  `#minigrid-${ind} .mini-grid-1`
                );
              }

              if (allMiniGrid1) {
                allMiniGrid1.forEach((grid) => {
                  grid.remove();
                });
              }
            }

            await readjust(lStreams.length, ind);

            // split the streams into two arrays, one for mainGrid and one for altGrid
            // take up to numtoadd from the lStreams and add to mainGridStreams
            let mainGridStreams = await lStreams.slice(0, numtoaddd);
            // take the rest of the streams and add to altGridStreams
            let altGridStreams = await lStreams.slice(
              numtoaddd,
              lStreams.length
            );
            //add to grids

            if (
              doPaginate == true ||
              prevDoPaginate != doPaginate ||
              shared ||
              shareScreenStarted ||
              shareEnded
            ) {
              let lStreams_alt = await lStreams_;
              await processConsumerTransports(consumerTransports, lStreams_alt);

              try {
                if (breakOutRoomStarted && !breakOutRoomEnded) {
                  await resumePauseAudioStreams(breakRoom, inBreakRoom);
                }
              } catch (error) {}

              try {
                if (
                  !breakOutRoomStarted ||
                  (breakOutRoomStarted && breakOutRoomEnded)
                ) {
                  await resumePauseStreams();
                }
              } catch (error) {}

              if (shareEnded) {
                shareEnded = false;
              }
            }

            if (ChatSkip && eventType == "chat") {
              await addVideosGrid(
                mainGridStreams,
                altGridStreams,
                numtoaddd - 1,
                numRows,
                numCols,
                remainingVideos,
                actualRows,
                removeAltGrid,
                ind,
                true,
                true,
                forChatCard,
                forChatID
              );
            } else {
              await addVideosGrid(
                mainGridStreams,
                altGridStreams,
                numtoaddd,
                numRows,
                numCols,
                remainingVideos,
                actualRows,
                removeAltGrid,
                ind
              );
            }

            if (updateMainWindow) {
              if (!lock_screen && !shared) {
                await prepopulateUserMedia(hostLabel);
              } else {
                if (!first_round) {
                  await prepopulateUserMedia(hostLabel);
                }
              }
            }

            if (ind == 0) {
              await rePort();
            }
          }

          async function checkMinigridHome() {
            // Function to check if the element is present

            const interval = 3000; //
            const maxChecks = 2; // Maximum number of checks

            // Function to check if the element is present
            function isMinigridHomePresent() {
              const minigridHomeElement = document.querySelector(
                "#minigrid-home .minigrid"
              );
              return !!minigridHomeElement; // Returns true if the element is found, false otherwise
            }

            // Function to delay execution by the specified time
            function delay(ms) {
              return new Promise((resolve) => setTimeout(resolve, ms));
            }

            // Function to find the minigrid element if #minigrid-home is not present
            function findMinigridElement() {
              const minigridNumberElements =
                document.querySelectorAll('[id^="minigrid-"]');
              const minigridNumberRegex = /^minigrid-\d+$/;

              for (const element of minigridNumberElements) {
                if (minigridNumberRegex.test(element.id)) {
                  return element;
                }
              }

              return null;
            }

            // Loop to continuously check for the element
            while (true) {
              let count = 0;

              while (!isMinigridHomePresent() && count < maxChecks) {
                count++;
                await delay(interval);
              }

              if (!isMinigridHomePresent()) {
                // Element is not present after the maximum number of checks, fill the page

                const minigridHomeElement = findMinigridElement();
                if (minigridHomeElement) {
                } else {
                  await reorderStreams();
                }
              }

              // Delay before checking again
              await delay(interval);
            }
          }

          // Call the function to start checking for mainGrid
          if (eventType != "broadcast") {
            checkMinigridHome();
          }

          function autoAdjust(n) {
            //function to auto adjust the grid

            let val1 = 6;
            let val2 = 12 - val1;
            let cal1 = Math.floor((val1 / 12) * 100);
            let cal2 = 100 - cal1;

            if (eventType == "broadcast") {
              val1 = 0;
              val2 = 12 - val1;
            } else if (
              eventType == "chat" ||
              (eventType == "conference" && !(shareScreenStarted || shared))
            ) {
              val1 = 12;
              val2 = 12 - val1;
            } else {
              if (shareScreenStarted || shareScreen) {
                val2 = 10;
                val1 = 12 - val2;
              } else {
                if (n == 0) {
                  val1 = 1;
                  val2 = 12 - val1;
                } else if (n >= 1 && n < 4) {
                  val1 = 4;
                  val2 = 12 - val1;
                } else if (n >= 4 && n < 6) {
                  val1 = 6;
                  val2 = 12 - val1;
                } else if (n >= 6 && n < 9) {
                  val1 = 6;
                  val2 = 12 - val1;
                } else if (n >= 9 && n < 12) {
                  val1 = 6;
                  val2 = 12 - val1;
                } else if (n >= 12 && n < 20) {
                  val1 = 8;
                  val2 = 12 - val1;
                } else if (n >= 20 && n < 50) {
                  val1 = 8;
                  val2 = 12 - val1;
                } else {
                  val1 = 10;
                  val2 = 12 - val1;
                }
              }
            }

            return [val1, val2];
          }

          async function readjust(n, state) {
            //function to readjust the grid sizes

            if (state == 0) {
              nForReadjust = n;
              prevMainHeightWidth = mainHeightWidth;
            }

            let val1 = 6;
            let val2 = 12 - val1;
            let cal1 = Math.floor((val1 / 12) * 100);
            let cal2 = 100 - cal1;

            if (eventType == "broadcast") {
              val1 = 0;
              val2 = 12 - val1;

              if (n == 0) {
                val1 = 0;
                val2 = 12 - val1;
              }
            } else if (
              eventType == "chat" ||
              (eventType == "conference" && !(shareScreenStarted || shared))
            ) {
              val1 = 12;
              val2 = 12 - val1;
            } else {
              if (shareScreenStarted || shareScreen) {
                val2 = 10;
                val1 = 12 - val2;
              } else {
                if (n == 0) {
                  val1 = 1;
                  val2 = 12 - val1;
                } else if (n >= 1 && n < 4) {
                  val1 = 4;
                  val2 = 12 - val1;
                } else if (n >= 4 && n < 6) {
                  val1 = 6;
                  val2 = 12 - val1;
                } else if (n >= 6 && n < 9) {
                  val1 = 6;
                  val2 = 12 - val1;
                } else if (n >= 9 && n < 12) {
                  val1 = 6;
                  val2 = 12 - val1;
                } else if (n >= 12 && n < 20) {
                  val1 = 8;
                  val2 = 12 - val1;
                } else if (n >= 20 && n < 50) {
                  val1 = 8;
                  val2 = 12 - val1;
                } else {
                  val1 = 10;
                  val2 = 12 - val1;
                }
              }
            }

            if (state == 0) {
              mainHeightWidth = val2;
            }

            //MAIN GRID TAKES val2 and othergrid takes val1 interms of width
            let maingrid = $(".maingrid");
            var othergrid = $(".othergrid");

            // Remove all classes that start with "col-md-"
            maingrid.removeClass(function (index, className) {
              return (className.match(/\bcol-lg-\S+/g) || []).join(" ");
            });
            maingrid.removeClass(function (index, className) {
              return (className.match(/\bcol-md-\S+/g) || []).join(" ");
            });

            maingrid.removeClass(function (index, className) {
              return (className.match(/\bcol-sm-\S+/g) || []).join(" ");
            });

            othergrid.removeClass(function (index, className) {
              return (className.match(/\bcol-lg-\S+/g) || []).join(" ");
            });
            othergrid.removeClass(function (index, className) {
              return (className.match(/\bcol-md-\S+/g) || []).join(" ");
            });

            othergrid.removeClass(function (index, className) {
              return (className.match(/\bcol-sm-\S+/g) || []).join(" ");
            });

            // Add new classes with updated widths
            maingrid
              .addClass("col-lg-" + val2)
              .addClass("col-md-" + val2)
              .addClass("col-sm-" + val2);
            othergrid
              .addClass("col-lg-" + val1)
              .addClass("col-md-" + val1)
              .addClass("col-sm-" + val1);

            if (window.matchMedia("(max-width: 576px)").matches) {
              // Calculate new grid heights based on screen size

              let screenHeight = $(window).innerHeight();
              if (isBrowserBarHidden()) {
                screenHeight = $(document).height();
              }
              cal1 = Math.floor((val1 / 12) * 100);
              cal2 = 100 - cal1;

              let maxHeightMain = screenHeight * 0.95;
              if (eventType == "broadcast" || eventType == "chat") {
                maxHeightMain = screenHeight;
              }

              let mainHeight = maxHeightMain * (cal2 / 100);
              let otherHeight = maxHeightMain * (cal1 / 100);

              // Set new heights
              let maingrid = $(".maingrid");
              let othergrid = $(".othergrid");
              maingrid.css("height", `${mainHeight}px`);
              othergrid.css("height", `${otherHeight}px`);
            } else {
              let maingrid = $(".maingrid");
              let othergrid = $(".othergrid");
              maingrid.css("height", "100%");
              othergrid.css("height", "100%");
            }

            if (prevMainHeightWidth != mainHeightWidth) {
              if (!lock_screen && !shared) {
                await prepopulateUserMedia(hostLabel);
              } else {
                if (!first_round) {
                  await prepopulateUserMedia(hostLabel);
                }
              }
            }
          }

          async function showConfirmModal(islevel) {
            // Function to show the confirmation modal to exit the event
            const modal = $("#confirmModal");
            const modalTitle = modal.find("#confirmModalLabel");
            const modalMessage = modal.find(".modal-body");
            const cancelButton = modal.find('[data-dismiss="modal"]');
            const confirmButton = modal.find("#confirmExit");

            if (islevel === "2") {
              modalTitle.text("Confirm Exit");
              modalMessage.text(
                "This will end the event for all. Confirm exit."
              );
              confirmButton.text("End Event");
            } else {
              modalTitle.text("Confirm Exit");
              modalMessage.text("Are you sure you want to exit?");
              confirmButton.text("Exit");
            }
            await modal.modal("show");
          }

          var endStateButton = document.getElementById("endState");
          endStateButton.addEventListener("click", function () {
            // Show confirmation modal
            showConfirmModal(islevel);

            // Handle confirm exit button click
            var confirmExitButton = document.getElementById("confirmExit");
            confirmExitButton.addEventListener("click", async function () {
              await socket.emit("disconnectUser", {
                member: member,
                roomName: roomName,
                ban: false,
              });
              if (p_sockets.length > 0) {
                p_sockets[0].emit("disconnectUser", {
                  member: member,
                  roomName: roomName,
                  ban: false,
                });
              }
              // Handle exit logic here
              $("#confirmModal").modal("hide");
            });
          });

          // Redirect to home page if the event has ended
          socket.on("disconnect", async function () {
            //update that the socket has disconnected

            window.location.href = await redirectURL;
          });

          socket.on("meetingEnded", function () {
            //update that the meeting(event) has ended

            //show alert that meeting has ended and wait for 3 seconds before redirecting to home page
            if (eventType != "chat") {
              showAlert(
                "Event has ended. Redirecting to home page in 2 seconds."
              );
            }

            setTimeout(async function () {
              window.location.href = await redirectURL;
            }, 2000);
          });

          socket.on("disconnectUserSelf", async function () {
            //update that the user needs to be disconnected; this is initiated by the host when banning a user
            await socket.emit("disconnectUser", {
              member: member,
              roomName: roomName,
              ban: true,
            });
            if (p_sockets.length > 0) {
              p_sockets[0].emit("disconnectUser", {
                member: member,
                roomName: roomName,
                ban: true,
              });
            }
          });

          // Copy event ID to clipboard
          $("#shareMeetingModal").on("show.bs.modal", async function (event) {
            let button = await $(event.relatedTarget); // Button that triggered the modal
            let meetingID = await roomName; // Extract info from data-* attributes

            let modal = $(this);

            // Set the meeting ID and shareable link values in the modal fields
            let shareLink =
              await `${window.location.origin}/meeting/${meetingID}`;
            await modal.find("#meetingIdCopy").val(meetingID);
            await modal.find("#shareLink").val(shareLink);

            // Add functionality to the email, Facebook, and WhatsApp buttons
            modal.find("#shareEmailButton").click(async function () {
              await window.open(
                `mailto:?subject=Join my meeting&body=Here's the link to the meeting: ${shareLink}`
              );
            });

            modal.find("#shareFacebookButton").click(async function () {
              await window.open(
                `https://www.facebook.com/sharer/sharer.php?u=${encodeURIComponent(
                  shareLink
                )}`
              );
            });

            modal.find("#shareWhatsappButton").click(async function () {
              await window.open(
                `https://wa.me/?text=${encodeURIComponent(shareLink)}`
              );
            });

            $("#copyMeetingIdButton").click(async function () {
              $("#meetingIdCopy").select();
              document.execCommand("copy");
              await $("#copyMeetingIdButton")
                .attr("data-original-title", "Copied!")
                .tooltip("show");
            });

            $("#copyMeetingPasscodeButton").click(async function () {
              $("#meetingPasscodeCopy").select();
              document.execCommand("copy");
              await $("#copyMeetingPasscodeButton")
                .attr("data-original-title", "Copied!")
                .tooltip("show");
            });

            // Copy Shareable Link to clipboard
            $("#copyShareLinkButton").click(async function () {
              $("#shareLink").select();
              document.execCommand("copy");
              await $("#copyShareLinkButton")
                .attr("data-original-title", "Copied!")
                .tooltip("show");
            });
          });

          function loadBroadcastModal(formattedName, formattedNameCap) {
            // Function to load the broadcast/chat modal

            $("#shareEventModal").on("show.bs.modal", async function (event) {
              if (eventType == "chat") {
                formattedName = "chat";
                formattedNameCap = "Chat";
              }

              let button = await $(event.relatedTarget); // Button that triggered the modal
              let broadcastID = await roomName; // Extract info from data-* attributes

              let modal = $(this);

              // Set the broadcast ID and shareable link values in the modal fields
              let shareLink =
                await `${window.location.origin}/${formattedName}/${broadcastID}`;
              modal.find("#broadcastIdCopy2").val(broadcastID);
              modal.find("#shareLinkBroadcast2").val(shareLink);

              // Add functionality to the email, Facebook, and WhatsApp buttons
              modal
                .find("#shareEmailBroadcastButton2")
                .click(async function () {
                  await window.open(
                    `mailto:?subject=Join my ${formattedNameCap}&body=Here's the link to the ${formattedName}: ${shareLink}`
                  );
                });

              modal
                .find("#shareFacebookBroadcastButton2")
                .click(async function () {
                  await window.open(
                    `https://www.facebook.com/sharer/sharer.php?u=${encodeURIComponent(
                      shareLink
                    )}`
                  );
                });

              modal
                .find("#shareWhatsappBroadcastButton2")
                .click(async function () {
                  await window.open(
                    `https://wa.me/?text=${encodeURIComponent(shareLink)}`
                  );
                });

              if (islevel == "2") {
                modal.find("#broadcastPasscodeCopy2").val(adminPasscode);
              }

              $("#copyBroadcastIdButton2").click(function () {
                $("#broadcastIdCopy2").select();
                document.execCommand("copy");
                $("#copyBroadcastIdButton2")
                  .attr("data-original-title", "Copied!")
                  .tooltip("show");
              });

              $("#copyBroadcastPasscodeButton2").click(function () {
                $("#broadcastPasscodeCopy2").select();
                document.execCommand("copy");
                $("#copyBroadcastPasscodeButton2")
                  .attr("data-original-title", "Copied!")
                  .tooltip("show");
              });

              // Copy Shareable Link to clipboard
              $("#copyShareLinkBroadcastButton2").click(function () {
                $("#shareLinkBroadcast2").select();
                document.execCommand("copy");
                $("#copyShareLinkBroadcastButton2")
                  .attr("data-original-title", "Copied!")
                  .tooltip("show");
              });
            });
          }

          async function addTimer() {
            //function to add the timer to the screen

            //first check if timer exists
            let timer = document.getElementById("meetingProgressTimer");
            if (timer) {
              return;
            }

            const badgeContainer = $('<div class="badge-container" ></div>');
            const progressTimer = $(
              '<div id="meetingProgressTimer" class="progress-timer badge bg-success"></div>'
            );
            badgeContainer.append(progressTimer);

            ///add the badge container to the top of the mainAspect

            //first check if mainAspect exists
            let maingrid = $(".maingrid");
            if (maingrid.length > 0) {
              //append to the top of the maingrid
              maingrid.prepend(badgeContainer);
            } else {
              $(".othergrid").prepend(badgeContainer);
            }

            await sleep(1000);

            //find the progress timer
            let progressTimer_ = document.getElementById(
              "meetingProgressTimer"
            );
            if (progressTimer_) {
            }
          }

          function addMainGrid() {
            //function to add the main grid to the screen
            let maingrid = `
  
    <div class="col-lg-10 col-md-10 col-sm-10 col-xs-12 p_dcard maingrid">
                  
  
    <div class="maingrid-container" style="height: 100%;">
  
      <div class="maingrids" style="display: grid; grid-gap: 0px; justify-content: center;width: 100%;margin: 0%;padding: 0%;margin-top: 0%;padding-top:0px">
  
      </div>
    </div>
  
  </div> `;

            //add main grid to screencontainer before othergrid
            let othergrid = $(".othergrid");
            let height84 = othergrid.height() * 0.84;
            $(".maingrid").css("height", height84);

            if (othergrid.length > 0) {
              othergrid.before(maingrid);
            } else {
              //add to screencontainer
              let screencontainer = $(".screencontainer");
              screencontainer.append(maingrid);
            }
          }

          // Copy event ID to clipboard
          $("#menuModal").on("show.bs.modal", function (event) {
            //get the record button
            let recordButtons = document.getElementsByClassName("recordStated");
            let recordButton = recordButtons[0];
            if (islevel != "2") {
              //hide the record button
              recordButton.classList.add("d-none");
            } else {
              //show the record button
              recordButton.classList.remove("d-none");
            }

            //get the addCoHostBtn
            let addCoHostBtn = document.getElementById("addCoHostBtn");
            if (islevel != "2") {
              //hide the addCoHostBtn
              addCoHostBtn.classList.add("d-none");
            } else {
              //show the addCoHostBtn
              addCoHostBtn.classList.remove("d-none");
            }

            //hide adminpasscode if not admin
            let adminPasscodeDiv = document.getElementById("adminPasscodeDiv");
            if (islevel != "2") {
              //hide the adminPasscodeDiv
              adminPasscodeDiv.classList.add("d-none");
            } else {
              //show the adminPasscodeDiv
              adminPasscodeDiv.classList.remove("d-none");
            }

            //get the settings button
            let settingsButton = document.getElementById("addSettingsID");
            if (islevel != "2") {
              //hide the settings button
              settingsButton.classList.add("d-none");
            } else {
              //show the settings button
              settingsButton.classList.remove("d-none");
            }

            //get requests button
            let requestsButton = document.getElementById("addRequestsID");
            if (islevel != "2") {
              // hide the requests button id mediaValue = false
              let mediaValue = false;
              try {
                mediaValue = coHostResponsibility.find(
                  (item) => item.name === "media"
                ).value;
              } catch (err) {}

              if (mediaValue == false) {
                requestsButton.classList.add("d-none");
              } else {
                requestsButton.classList.remove("d-none");
              }
            } else {
              //show the requests button
              requestsButton.classList.remove("d-none");
            }

            //get the waiting room button id = addWaitingID
            let waitingRoomButton = document.getElementById("addWaitingID");
            if (islevel != "2") {
              // hide the waiting room button id mediaValue = false
              let participantValue = false;
              try {
                participantValue = coHostResponsibility.find(
                  (item) => item.name === "waiting"
                ).value;
              } catch (err) {}

              if (participantValue == false) {
                waitingRoomButton.classList.add("d-none");
              } else {
                waitingRoomButton.classList.remove("d-none");
              }
            } else {
              //show the waiting room button
              waitingRoomButton.classList.remove("d-none");
            }

            let button = $(event.relatedTarget); // Button that triggered the modal
            let meetingID = roomName; // Extract info from data-* attributes

            let modal = $(this);

            // Set the meeting ID and shareable link values in the modal fields
            let shareLink = `${window.location.origin}/meeting/${meetingID}`;
            modal.find("#meetingIdCopy2").val(meetingID);
            modal.find("#shareLink2").val(shareLink);

            if (islevel == "2") {
              modal.find("#meetingPasscodeCopy").val(adminPasscode);
            }

            // Add functionality to the email, Facebook, and WhatsApp buttons
            modal.find("#shareEmailButton2").click(async function () {
              window.open(
                `mailto:?subject=Join my meeting&body=Here's the link to the meeting: ${shareLink}`
              );
            });

            modal.find("#shareFacebookButton2").click(async function () {
              window.open(
                `https://www.facebook.com/sharer/sharer.php?u=${encodeURIComponent(
                  shareLink
                )}`
              );
            });

            modal.find("#shareWhatsappButton2").click(async function () {
              window.open(
                `https://wa.me/?text=${encodeURIComponent(shareLink)}`
              );
            });

            $("#copyMeetingIdButton2").click(function () {
              $("#meetingIdCopy2").select();
              document.execCommand("copy");
              $("#copyMeetingIdButton2")
                .attr("data-original-title", "Copied!")
                .tooltip("show");
            });

            $("#copyMeetingPasscodeButton").click(async function () {
              $("#meetingPasscodeCopy").select();
              document.execCommand("copy");
              $("#copyMeetingPasscodeButton")
                .attr("data-original-title", "Copied!")
                .tooltip("show");
            });

            // Copy Shareable Link to clipboard
            $("#copyShareLinkButton2").click(function () {
              $("#shareLink2").select();
              document.execCommand("copy");
              $("#copyShareLinkButton2")
                .attr("data-original-title", "Copied!")
                .tooltip("show");
            });
          });

          $("#menuAccess").click(function () {
            // Function to show the access modal
            if (islevel === "2" || coHost == member) {
              $("#menuModal").modal("show");
            } else {
              $("#shareMeetingModal").modal("show");
            }
          });

          hideSpanned = function (islevel) {
            //function to hide/show the spanned button
            if (islevel !== "2") {
              if (coHost != member) {
                $(".request-count").hide();
              } else {
                $(".request-count").show();
              }
            }
          };

          //hide/show message-count
          hideSpannedMessages = function (mode) {
            if (!mode) {
              $(".message-count").show();
            } else {
              $(".message-count").hide();
            }
          };

          async function renderMessages(messages, type, username) {
            // Function to render messages in the chat panel

            if (eventType != "broadcast" && eventType != "chat") {
              messages = await messages.filter((message) =>
                participantsAll.some(
                  (participant) =>
                    participant.name == message.sender &&
                    participant.isBanned == false
                )
              );
            } else {
              messages = messages.filter((message) => {
                const participant = participantsAll.find(
                  (participant) => participant.name === message.sender
                );
                return !participant || !participant.isBanned;
              });
            }

            let messagePanel;
            let contentContainerId;
            let inputContainerId;
            let inputId;
            let sendBtnId;

            if (type == "group") {
              if (eventType == "broadcast" || eventType == "chat") {
                messagePanel = await document.getElementById("reactChatPanel");
                contentContainerId = "groupChatContent";
                inputContainerId = "groupChatInputContainer";
                inputId = "groupChatInput";
                sendBtnId = "groupChatSendBtn";
              } else {
                messagePanel = await document.getElementById("groupChatPanel");
                contentContainerId = "groupChatContent";
                inputContainerId = "groupChatInputContainer";
                inputId = "groupChatInput";
                sendBtnId = "groupChatSendBtn";
              }
            } else {
              messagePanel = await document.getElementById(
                "directMessagePanel"
              );
              contentContainerId = "directMessageContent";
              inputContainerId = "directMessageInputContainer";
              inputId = "directMessageInput";
              sendBtnId = "directMessageSendBtn";
            }
            messagePanel.innerHTML = "";
            await messages.forEach((message) => {
              const {
                sender,
                receivers,
                message: content,
                timestamp,
                group,
              } = message;

              const messageCard = document.createElement("div");
              messageCard.classList.add("message-card");
              messageCard.classList.add(sender === username ? "self" : "other");

              const messageInfo = document.createElement("div");
              messageInfo.classList.add(
                sender === username ? "message-info-self" : "message-info-other"
              );

              const usernameElement = document.createElement("span");
              usernameElement.classList.add("username");

              //check if sender is host
              usernameElement.textContent = sender;

              const timestampElement = document.createElement("span");
              if (eventType == "broadcast" || eventType == "chat") {
                timestampElement.classList.add("time-basic");
              } else {
                timestampElement.classList.add("time");
              }
              timestampElement.textContent = timestamp;

              const contentElement = document.createElement("p");
              contentElement.classList.add("content");
              contentElement.textContent = content;

              if (!group && youAreHost && sender === username) {
                if (receivers.length > 0) {
                  const receiversText = document.createElement("span");
                  receiversText.classList.add("receivers");
                  receiversText.textContent = "To: " + receivers.join(", ");
                  messageInfo.appendChild(receiversText);
                }
              }

              messageInfo.appendChild(usernameElement);
              messageInfo.appendChild(timestampElement);

              if (!group && youAreHost && sender != username) {
                const replyButton = document.createElement("button");
                replyButton.classList.add("reply-button");
                replyButton.setAttribute("id", sender);

                const replyIcon = document.createElement("i");
                replyIcon.classList.add("fas", "fa-reply");

                replyButton.appendChild(replyIcon);

                replyButton.addEventListener("click", (event) => {
                  const senderId = event.target.getAttribute("id");
                  openReplyInput(sender);
                });

                messageInfo.appendChild(replyButton);
              }

              messageCard.appendChild(messageInfo);
              messageCard.appendChild(contentElement);

              if (
                !group &&
                (youAreHost ||
                  sender === username ||
                  receivers.includes(username))
              ) {
                messagePanel.appendChild(messageCard);
              } else if (group) {
                messagePanel.appendChild(messageCard);
              }
            });

            // Append the message input field and send button
            const contentContainer = document.createElement("div");
            contentContainer.id = contentContainerId;

            const messageContainer = document.createElement("div");
            messageContainer.id = `${type}MessageMessages`;
            messageContainer.classList.add("message-container");

            const inputContainer = document.createElement("div");
            inputContainer.id = inputContainerId;
            inputContainer.classList.add("input-container");

            const inputGroup = document.createElement("div");
            inputGroup.classList.add("input-group");

            const inputTextarea = document.createElement("textarea");
            inputTextarea.id = inputId;
            inputTextarea.classList.add("form-control");
            inputTextarea.setAttribute("rows", "1");
            inputTextarea.setAttribute("placeholder", "Type your message...");
            inputTextarea.setAttribute("maxlength", "350");

            const inputAppend = document.createElement("div");
            inputAppend.classList.add("input-group-append");

            const sendBtn = document.createElement("button");
            sendBtn.id = sendBtnId;
            sendBtn.classList.add("btn", "btn-info");
            sendBtn.setAttribute("type", "button");

            const sendIcon = document.createElement("i");
            sendIcon.classList.add("fas", "fa-paper-plane");

            sendBtn.appendChild(sendIcon);

            //add click event to send button
            sendBtn.addEventListener("click", (event) => {
              const message = document.getElementById(inputId).value;
              let typedd;
              //check they are allowed to chat
              if (
                !(chatSetting == "allow") &&
                !(eventType == "chat" || eventType == "broadcast")
              ) {
                //check if they are host
                if (!youAreHost) {
                  showAlert(
                    "You are not allowed to chat in this event.",
                    "danger"
                  );
                  return;
                }
              }

              if (message) {
                if (inputId != "groupChatInput") {
                  const replyInfo = document.querySelector(".reply-info");
                  sendGroup = false;
                  typedd = "direct";
                  if (replyInfo) {
                    replyInfo.remove(); // Remove the previous reply information if it exists
                  } else {
                    if (youAreHost) {
                      const messageInputTextarea =
                        document.getElementById("directMessageInput");
                      const replyInfoContainer = document.createElement("div");
                      replyInfoContainer.classList.add("reply-info");
                      const replyText = document.createElement("span");
                      replyText.textContent = "Select a message to reply to: ";
                      replyInfoContainer.appendChild(replyText);
                      const messageInputContainer = document.getElementById(
                        "directMessageInputContainer"
                      );
                      messageInputContainer.prepend(replyInfoContainer);
                      return;
                    }
                  }
                } else {
                  typedd = "group";
                  sendGroup = true;
                }
                document.getElementById(inputId).value = "";

                const messageObject = {
                  sender: username,
                  receivers: [messageReceiver],
                  message: message,
                  timestamp: new Date().toLocaleTimeString(),
                  group: sendGroup,
                };

                //first check messages length

                socket.emit("sendMessage", { messageObject, roomName });
              }
            });

            inputAppend.appendChild(sendBtn);
            inputGroup.appendChild(inputTextarea);
            inputGroup.appendChild(inputAppend);
            inputContainer.appendChild(inputGroup);
            contentContainer.appendChild(messageContainer);
            contentContainer.appendChild(inputContainer);
            messagePanel.appendChild(contentContainer);
          }

          function openReplyInput(senderId) {
            // Function to open the reply input field

            const messageInputTextarea =
              document.getElementById("directMessageInput");
            messageInputTextarea.value = ""; // Clear the existing input content

            const replyInfo = document.querySelector(".reply-info");
            if (replyInfo) {
              replyInfo.remove(); // Remove the previous reply information if it exists
            }

            //check if replying to self
            if (senderId === member) {
              showAlert("You cannot send direct message to yourself", "danger");
              return;
            }

            const replyInfoContainer = document.createElement("div");
            replyInfoContainer.classList.add("reply-info");

            const replyText = document.createElement("span");
            replyText.textContent = "Replying to: ";

            const replyUsername = document.createElement("span");
            replyUsername.classList.add("reply-username");
            replyUsername.textContent = senderId;

            messageReceiver = senderId;

            replyInfoContainer.appendChild(replyText);
            replyInfoContainer.appendChild(replyUsername);

            const messageInputContainer = document.getElementById(
              "directMessageInputContainer"
            );
            messageInputContainer.prepend(replyInfoContainer);

            //focus the tab on the directMessageInputContainer
            const directMessageInputContainer = document.getElementById(
              "directMessageInputContainer"
            );

            // Set focus to the message input textarea
            messageInputTextarea.focus();
          }

          async function tuneMessages() {
            //function get all messages
            await socket.emit(
              "getMessage",
              { roomName },
              async ({ messages_ }) => {
                messages = await messages_;
              }
            );
          }

          //messageModal onshow
          $("#messageModal").on("show.bs.modal", async function (event) {
            // get all messages with group true

            //get and render group messages
            const messagess = await messages.filter(
              (message) => message.group == true
            );
            await renderMessages(messagess, "group", member);

            //get and render direct messages
            const directMessages = await messages.filter(
              (message) => message.group == false
            );
            await renderMessages(directMessages, "direct", member);
          });

          //messageModal onhide
          $("#messageModal").on("hide.bs.modal", function (event) {
            //clear all messages in the messageModal
            const groupMessageMessages = document.getElementById(
              "groupMessageMessages"
            );
            const directMessageMessages = document.getElementById(
              "directMessageMessages"
            );
            groupMessageMessages.innerHTML = "";
            directMessageMessages.innerHTML = "";

            hideSpannedMessages(true);
          });

          socket.on("receiveMessage", async ({ message }) => {
            // add the message to the messages array
            const {
              sender,
              receivers,
              message: content,
              timestamp,
              group,
            } = message;

            let oldMessages = await messages;

            messages = await [
              ...messages,
              { sender, receivers, message: content, timestamp, group },
            ];

            //filter out messages with banned senders in the participants array; keep others that are not a and not in participants array

            if (eventType != "broadcast" && eventType != "chat") {
              messages = await messages.filter((message) =>
                participantsAll.some(
                  (participant) =>
                    participant.name == message.sender &&
                    participant.isBanned == false
                )
              );
            } else {
              messages = messages.filter((message) => {
                const participant = participantsAll.find(
                  (participant) => participant.name === message.sender
                );
                return !participant || !participant.isBanned;
              });
            }

            const oldmessagess = await oldMessages.filter(
              (message) => message.group == true
            );
            const olddirectMessages = await oldMessages.filter(
              (message) => message.group == false
            );

            // render the message and update the message count
            const messagess = await messages.filter(
              (message) => message.group == true
            );
            await renderMessages(messagess, "group", member);

            if (eventType != "broadcast" && eventType != "chat") {
              //check if oldmessagess is the same length as messagess
              if (oldmessagess.length != messagess.length) {
                //check if the new message sender === member || receivers.includes(member)
                //first remove the oldmessagess from messagess
                const newMessages = await messagess.filter((message) => {
                  const isDuplicate = oldmessagess.some(
                    (oldMessage) => oldMessage.timestamp === message.timestamp
                  );
                  return !isDuplicate;
                });
                //check if the newMessages sender === member || receivers.includes(member)
                const newMessages2 = await newMessages.filter(
                  (message) =>
                    message.sender === member ||
                    message.receivers.includes(member)
                );
                //check if you are the sender of any of the newMessages, that is check message.sender === member

                let newMessages3 = await newMessages2.filter(
                  (message) => message.sender === member
                );
                //check if you are the receiver of any of the newMessages, that is check message.receivers.includes(member)

                if (newMessages.length > 0) {
                  if (newMessages.length != newMessages3.length) {
                    //show the message-count
                    hideSpannedMessages(false);
                  }
                }
              }
            }

            const directMessages = await messages.filter(
              (message) => message.group == false
            );
            await renderMessages(directMessages, "direct", member);

            if (eventType != "broadcast" && eventType != "chat") {
              //differece between olddirectMessages and directMessages
              if (olddirectMessages.length != directMessages.length) {
                //show the message-count
                //check the new message sender === member || receivers.includes(member)
                //first remove the olddirectMessages from directMessage by making sure no 2 timestamps in the message are the same
                const newDirectMessages = directMessages.filter((message) => {
                  const isDuplicate = olddirectMessages.some(
                    (oldMessage) => oldMessage.timestamp === message.timestamp
                  );
                  return !isDuplicate;
                });

                //check if the newDirectMessages sender === member || receivers.includes(member)
                const newDirectMessages2 = await newDirectMessages.filter(
                  (message) =>
                    message.sender === member ||
                    message.receivers.includes(member)
                );
                //check if you are the sender of any of the newDirectMessages, that is check message.sender === member
                const newDirectMessages3 = await newDirectMessages2.filter(
                  (message) => message.sender === member
                );

                if (
                  (newDirectMessages.length > 0 &&
                    newDirectMessages2.length > 0) ||
                  (newDirectMessages.length > 0 && islevel == "2") ||
                  coHost == member
                ) {
                  if (islevel == "2" || coHost == member) {
                    if (newDirectMessages.length != newDirectMessages3.length) {
                      //show the message-count
                      hideSpannedMessages(false);
                    }
                  } else {
                    if (newDirectMessages2.length > 0) {
                      if (
                        newDirectMessages.length != newDirectMessages3.length
                      ) {
                        //show the message-count
                        hideSpannedMessages(false);
                      }
                    }
                  }
                }
              }
            }
          });

          socket.on("meetingTimeRemaining", async ({ timeRemaining }) => {
            //update the meeting time remaining

            // convert time from milliseconds to readable format of minutes and seconds
            const minutes = Math.floor(timeRemaining / 60000);
            const seconds = ((timeRemaining % 60000) / 1000).toFixed(0);
            const timeRemainingString = `${minutes}:${
              seconds < 10 ? "0" : ""
            }${seconds}`;

            //showalert with time remaining
            if (eventType != "chat") {
              showAlert(
                `You have ${timeRemainingString} minutes left in the event.`,
                "danger",
                3000
              );
            }
          });

          function startCountdown(duration) {
            // Function to start the countdown timer
            const modalHere = document.getElementById("confirmationHereModal");
            const closeBtn = modalHere.querySelector(".close-here");
            const counterElement = document.getElementById("here-counter");

            document
              .getElementById("confirmButtonHere")
              .addEventListener("click", function () {
                // Perform the action when the user clicks "Yes"
                $("#confirmationHereModal").modal("hide");
                // stop the countdown
                clearInterval(countdownInterval);
              });

            let countdownInterval;
            let timeRemaining;

            timeRemaining = duration;
            counterElement.textContent = timeRemaining;

            countdownInterval = setInterval(() => {
              timeRemaining--;
              counterElement.textContent = timeRemaining;

              if (timeRemaining <= 0) {
                clearInterval(countdownInterval);
                socket.emit("disconnectUser", {
                  member: member,
                  roomName: roomName,
                  ban: false,
                });
                // redirect to home page
                window.location.href = redirectURL;
              }
            }, 1000);
          }

          function showConfirmationHereModal() {
            // Function to show the confirmation modal
            const countdownDuration = 120; // Duration in seconds
            startCountdown(countdownDuration);
            $("#confirmationHereModal").modal({
              backdrop: "static", // Prevent dismissing the modal by clicking outside or pressing the Esc key
              keyboard: false, // Disable keyboard events
            });
          }

          function updateCounter(timeRemaining) {
            // Function to update the counter in the confirmation modal
            const counterElement = document.getElementById("here-counter");
            counterElement.textContent = timeRemaining;
          }

          socket.on("meetingStillThere", async ({ timeRemaining }) => {
            // Function to handle the "still there?" event
            //check if the user is still there and if not, disconnect them
            showConfirmationHereModal();
            updateCounter(timeRemaining);
          });

          // Enable draggability using interact.js for chat window
          interact(".floating-button").draggable({
            inertia: true,
            modifiers: [
              interact.modifiers.restrictRect({
                restriction: "parent",
                endOnly: true,
              }),
            ],
            autoScroll: true,
            listeners: {
              start(event) {
                event.interactable.draggable(false);
              },
              move(event) {
                const target = event.target;
                const x =
                  (parseFloat(target.getAttribute("data-x")) || 0) + event.dx;
                const y =
                  (parseFloat(target.getAttribute("data-y")) || 0) + event.dy;

                target.style.transform = `translate(${x}px, ${y}px)`;
                target.setAttribute("data-x", x);
                target.setAttribute("data-y", y);
              },
              end(event) {
                event.interactable.draggable(true);
              },
            },
          });

          function addMiniAudio(stream, remoteProducerId, consumer) {
            // Function to add the audio element and monitor audio loudness

            // Create new audio element for the new user
            const miniAudio = document.createElement("audio");
            miniAudio.setAttribute("id", `AudioOnly_${remoteProducerId}`);
            miniAudio.srcObject = stream;
            miniAudio.autoplay = true;
            miniAudio.style.display = "none";

            if (eventType == "chat") {
              return;
            }

            // Create AnalyserNode to monitor audio loudness
            let consLow = false;
            let averageLoudness = 128;

            setInterval(() => {
              try {
                const receiver = consumer.rtpReceiver;
                receiver?.getStats().then((stats) => {
                  stats.forEach((report) => {
                    if (
                      report.type === "inbound-rtp" &&
                      report.kind === "audio" &&
                      report.audioLevel
                    ) {
                      averageLoudness = 127.5 + report.audioLevel * 127.5;
                    }
                  });
                });
              } catch {
                console.error("Error getting audio level", error);
              }

              // Find the participant with the audio ID matching the given ID
              let participant = participants.find(
                (obj) => obj.audioID === remoteProducerId
              );
              let audioActiveInRoom = true;
              if (participant) {
                if (breakOutRoomStarted && !breakOutRoomEnded) {
                  //participant name must be in limitedBreakRoom
                  if (
                    !limitedBreakRoom
                      .map((obj) => obj.name)
                      .includes(participant.name)
                  ) {
                    audioActiveInRoom = false;
                    averageLoudness = 127;
                  }
                }
              }

              let autoWaveCheck = false;
              if (meetingDisplayType != "video") {
                autoWaveCheck = true;
              }
              if (shared || shareScreenStarted) {
                autoWaveCheck = false;
              }

              if (participant) {
                //check if participant name is in displayNames array
                if (!dispActiveNames.includes(participant.name)) {
                  autoWaveCheck = false;

                  if (!adminNameStream) {
                    //find host name
                    adminNameStream = participants.find(
                      (obj) => obj.islevel == "2"
                    ).name;
                  }

                  if (participant.name == adminNameStream) {
                    autoWaveCheck = true;
                  }
                } else {
                  autoWaveCheck = true;
                }

                // Check if the participant has a video ID
                if (
                  participant.videoID ||
                  autoWaveCheck ||
                  (breakOutRoomStarted &&
                    !breakOutRoomEnded &&
                    audioActiveInRoom)
                ) {
                  // Find the video element by the video ID
                  //user allows audio only display as well

                  let waveformOverlay = $("#" + "wave" + participant.name);

                  //check if there is an audio modal for this participant and remove it
                  let audioModal = $("#audioModal" + participant.name);
                  if (audioModal.length) {
                    audioModal.hide();
                  }

                  updateAudioDecibels(participant.name, averageLoudness);

                  // Update waveform visibility based on audio level
                  if (averageLoudness > 127.5) {
                    waveformOverlay.show();
                    //add to activeSounds array, the name of the participant, IF it is not already there
                    // add the name and averageLoudness to the array audioDecibels if not there else update it

                    if (!activeSounds.includes(participant.name)) {
                      activeSounds.push(participant.name);
                      consLow = false;
                      //reupdate
                      if (
                        (shareScreenStarted || shared) &&
                        !participant.videoID
                      ) {
                      } else {
                        reUpdateInter(
                          participant.name,
                          true,
                          false,
                          averageLoudness
                        );
                      }
                    }
                  } else {
                    waveformOverlay.hide();
                    //remove from activeSounds array, the name of the participant, IF it is there
                    if (activeSounds.includes(participant.name) && consLow) {
                      activeSounds.splice(
                        activeSounds.indexOf(participant.name),
                        1
                      );
                      //
                      if (
                        (shareScreenStarted || shared) &&
                        !participant.videoID
                      ) {
                      } else {
                        reUpdateInter(
                          participant.name,
                          false,
                          false,
                          averageLoudness
                        );
                      }
                    } else {
                      consLow = true;
                    }
                  }
                } else {
                  //no video && user does not allow audio only display
                  let audioModal = $("#audioModal" + participant.name);
                  let waveformOverlay = $("#" + "wave" + participant.name);
                  if (audioModal.length) {
                    // The audio modal exists

                    if (averageLoudness > 127.5) {
                      if (!autoWave) {
                        audioModal.hide();
                      } else {
                        audioModal.show();
                        waveformOverlay.show();
                      }

                      // add to activeSounds array, the name of the participant, IF it is not already there
                      if (!activeSounds.includes(participant.name)) {
                        activeSounds.push(participant.name);

                        if (
                          (shareScreenStarted || shared) &&
                          !participant.videoID
                        ) {
                        } else {
                          reUpdateInter(
                            participant.name,
                            true,
                            false,
                            averageLoudness
                          );
                        }
                      }
                    } else {
                      audioModal.hide(); // Hide the waveform
                      // remove from activeSounds array, the name of the participant, IF it is there
                      if (activeSounds.includes(participant.name)) {
                        activeSounds.splice(
                          activeSounds.indexOf(participant.name),
                          1
                        );
                        if (
                          (shareScreenStarted || shared) &&
                          !participant.videoID
                        ) {
                        } else {
                          reUpdateInter(
                            participant.name,
                            false,
                            false,
                            averageLoudness
                          );
                        }
                      }
                    }
                  } else {
                    // Create the audio modal for audio-only participants
                    let audioModal = $('<div class="audioModal"></div>');
                    audioModal.attr("id", "audioModal" + participant.name); // Add ID to modal
                    let audioModalContent = $(
                      '<div class="audio-modal-content"></div>'
                    );
                    let audioModalName = $(
                      '<p class="audio-modal-name"></p>'
                    ).text(participant.name);
                    let waveform = $('<div class="waveform sound"></div>');
                    waveform.attr("id", "wave" + participant.name); // Add ID to waveform
                    waveform.css({
                      display: "flex",
                      "justify-content": "center",
                      "align-items": "center",
                      "background-color": "transparent",
                      padding: "2px",
                      color: "black",
                    });

                    // Add individual bars to the waveform
                    for (let i = 0; i < 9; i++) {
                      let bar = $('<div class="bar"></div>');
                      waveform.append(bar);
                    }

                    const initials = participant.name; //.toUpperCase();
                    let miniCard = $('<div class="mini-carded firste"></div>');
                    miniCard.attr("data-initials", initials);
                    let fontSize = "1.35em";
                    if (window.matchMedia("(max-width: 576px)").matches) {
                      if (dispActiveNames.length > 8) {
                        fontSize = "1.1em";
                      } else if (dispActiveNames.length > 12) {
                        fontSize = "0.85em";
                      }
                    }
                    miniCard.css("--font-size", fontSize);

                    audioModalContent.append(miniCard);
                    audioModalContent.append(waveform);
                    audioModal.append(audioModalContent);

                    $("body").append(audioModal);

                    audioModal.draggable();

                    if (averageLoudness > 127.5) {
                      if (!autoWave) {
                        audioModal.hide();
                      } else {
                        audioModal.show();
                        waveformOverlay.show();
                      }
                      // add to activeSounds array, the name of the participant, IF it is not already there
                      if (!activeSounds.includes(participant.name)) {
                        activeSounds.push(participant.name);
                      }
                    } else {
                      audioModal.hide();
                      // remove from activeSounds array, the name of the participant, IF it is there
                      if (activeSounds.includes(participant.name)) {
                        activeSounds.splice(
                          activeSounds.indexOf(participant.name),
                          1
                        );
                      }
                    }
                  }
                }
              }
            }, 2000);
          }

          // Function to set the current co-host name
          function setCurrentCoHost(coHostName) {
            const currentCohostField = document.getElementById("currentCohost");
            currentCohostField.value = coHostName ? coHostName : "No coHost";
          }

          function populateParticipantsForCoHost() {
            // Function to populate the participants in the select dropdown
            const selectParticipant =
              document.getElementById("selectParticipant");

            // Clear existing options
            selectParticipant.innerHTML = "";

            // Create and append the default option
            const defaultOption = document.createElement("option");
            defaultOption.textContent = "Select a participant";
            defaultOption.value = "";
            selectParticipant.appendChild(defaultOption);

            // Iterate through the participants array and create option elements
            participants.forEach((participant) => {
              if (participant.islevel != "2" && participant.name != coHost) {
                const option = document.createElement("option");
                option.value = participant.name;
                option.textContent = participant.name;
                selectParticipant.appendChild(option);
              }
            });
          }

          $(document).on("show.bs.modal", "#cohostModal", function () {
            // Get the checkboxes for responsibility, manage participants, manage media, waiting room, and chat

            // Populate participants in the select dropdown
            populateParticipantsForCoHost();

            // Assume you have the co-host name in the variable coHost.name
            const coHostName = coHost;
            setCurrentCoHost(coHostName);

            let manageMediaToggle;
            let manageParticipantsToggle;
            let manageWaitingRoomToggle;
            let manageChatToggle;

            // Get the dedicated checkboxes
            const dedicateToManageParticipantsToggle = document.getElementById(
              "dedicateToManageParticipantsToggle"
            );
            const dedicateToManageMediaToggle = document.getElementById(
              "dedicateToManageMediaToggle"
            );
            const dedicateToManageWaitingRoomToggle = document.getElementById(
              "dedicateToManageWaitingRoomToggle"
            );
            const dedicateToManageChatToggle = document.getElementById(
              "dedicateToManageChatToggle"
            );

            // Get the checkboxes for responsibility, manage participants, manage media, waiting room, and chat
            const manageParticipantsToggled = document.getElementById(
              "manageParticipantsToggle"
            );
            const manageMediaToggled =
              document.getElementById("manageMediaToggle");
            const manageWaitingRoomToggled = document.getElementById(
              "manageWaitingRoomToggle"
            );
            const manageChatToggled =
              document.getElementById("manageChatToggle");

            let participantsValue = false;
            let participantsDedicatedValue = false;
            let mediaValue = false;
            let mediaDedicatedValue = false;
            let waitingRoomValue = false;
            let waitingRoomDedicatedValue = false;
            let chatValue = false;
            let chatDedicatedValue = false;

            try {
              participantsValue = coHostResponsibility.find(
                (item) => item.name === "participants"
              ).value;
              participantsDedicatedValue = coHostResponsibility.find(
                (item) => item.name === "participants"
              ).dedicated;
            } catch (error) {}

            try {
              mediaValue = coHostResponsibility.find(
                (item) => item.name === "media"
              ).value;
              mediaDedicatedValue = coHostResponsibility.find(
                (item) => item.name === "media"
              ).dedicated;
            } catch (error) {}

            try {
              waitingRoomValue = coHostResponsibility.find(
                (item) => item.name === "waiting"
              ).value;
              waitingRoomDedicatedValue = coHostResponsibility.find(
                (item) => item.name === "waiting"
              ).dedicated;
            } catch (error) {}

            try {
              chatValue = coHostResponsibility.find(
                (item) => item.name === "chat"
              ).value;
              chatDedicatedValue = coHostResponsibility.find(
                (item) => item.name === "chat"
              ).dedicated;
            } catch (error) {}

            // Set the values of the checkboxes
            manageParticipantsToggled.checked = participantsValue;
            manageMediaToggled.checked = mediaValue;
            manageWaitingRoomToggled.checked = waitingRoomValue;
            manageChatToggled.checked = chatValue;

            dedicateToManageParticipantsToggle.checked =
              participantsDedicatedValue;
            dedicateToManageMediaToggle.checked = mediaDedicatedValue;
            dedicateToManageWaitingRoomToggle.checked =
              waitingRoomDedicatedValue;
            dedicateToManageChatToggle.checked = chatDedicatedValue;

            // Add event listeners to manage toggles
            manageParticipantsToggled.addEventListener("change", function () {
              if (manageParticipantsToggled.checked) {
                dedicateToManageParticipantsToggle.disabled = false;
              } else {
                dedicateToManageParticipantsToggle.checked = false;
              }
            });

            manageMediaToggled.addEventListener("change", function () {
              if (manageMediaToggled.checked) {
                dedicateToManageMediaToggle.disabled = false;
              } else {
                dedicateToManageMediaToggle.checked = false;
              }
            });

            manageWaitingRoomToggled.addEventListener("change", function () {
              if (manageWaitingRoomToggled.checked) {
                dedicateToManageWaitingRoomToggle.disabled = false;
              } else {
                dedicateToManageWaitingRoomToggle.checked = false;
              }
            });

            manageChatToggled.addEventListener("change", function () {
              if (manageChatToggled.checked) {
                dedicateToManageChatToggle.disabled = false;
              } else {
                dedicateToManageChatToggle.checked = false;
              }
            });

            // Add event listeners to manage toggles
            dedicateToManageParticipantsToggle.addEventListener(
              "change",
              function () {
                manageParticipantsToggle = document.getElementById(
                  "manageParticipantsToggle"
                );
                if (manageParticipantsToggle.checked) {
                  dedicateToManageParticipantsToggle.disabled = false;
                } else {
                  dedicateToManageParticipantsToggle.checked = false;
                }
              }
            );

            dedicateToManageMediaToggle.addEventListener("change", function () {
              manageMediaToggle = document.getElementById("manageMediaToggle");
              if (manageMediaToggle.checked) {
                dedicateToManageMediaToggle.disabled = false;
              } else {
                dedicateToManageMediaToggle.checked = false;
              }
            });

            dedicateToManageWaitingRoomToggle.addEventListener(
              "change",
              function () {
                manageWaitingRoomToggle = document.getElementById(
                  "manageWaitingRoomToggle"
                );
                if (manageWaitingRoomToggle.checked) {
                  dedicateToManageWaitingRoomToggle.disabled = false;
                } else {
                  dedicateToManageWaitingRoomToggle.checked = false;
                }
              }
            );

            dedicateToManageChatToggle.addEventListener("change", function () {
              manageChatToggle = document.getElementById("manageChatToggle");

              if (manageChatToggle.checked) {
                dedicateToManageChatToggle.disabled = false;
              } else {
                dedicateToManageChatToggle.checked = false;
              }
            });
          });

          // Get the save button element for the co-host modal
          const saveCohostBtn = document.getElementById("saveCohostBtn");

          // Add event listener to the save button for the co-host modal
          saveCohostBtn.addEventListener("click", function () {
            // Get the selected participant
            const selectParticipant =
              document.getElementById("selectParticipant");
            const selectedParticipant = selectParticipant.value;

            // Get the checkboxes for responsibility, manage participants, manage media, waiting room, and chat
            const manageParticipantsToggle = document.getElementById(
              "manageParticipantsToggle"
            );
            const manageMediaToggle =
              document.getElementById("manageMediaToggle");
            const manageWaitingRoomToggle = document.getElementById(
              "manageWaitingRoomToggle"
            );
            const manageChatToggle =
              document.getElementById("manageChatToggle");

            // Get the dedicated checkboxes
            const dedicateToManageParticipantsToggle = document.getElementById(
              "dedicateToManageParticipantsToggle"
            );
            const dedicateToManageMediaToggle = document.getElementById(
              "dedicateToManageMediaToggle"
            );
            const dedicateToManageWaitingRoomToggle = document.getElementById(
              "dedicateToManageWaitingRoomToggle"
            );
            const dedicateToManageChatToggle = document.getElementById(
              "dedicateToManageChatToggle"
            );

            // Add event listeners to manage toggles
            manageParticipantsToggle.addEventListener("change", function () {
              if (manageParticipantsToggle.checked) {
                dedicateToManageParticipantsToggle.disabled = false;
              } else {
                dedicateToManageParticipantsToggle.checked = false;
              }
            });

            manageMediaToggle.addEventListener("change", function () {
              if (manageMediaToggle.checked) {
                dedicateToManageMediaToggle.disabled = false;
              } else {
                dedicateToManageMediaToggle.checked = false;
              }
            });

            manageWaitingRoomToggle.addEventListener("change", function () {
              if (manageWaitingRoomToggle.checked) {
                dedicateToManageWaitingRoomToggle.disabled = false;
              } else {
                dedicateToManageWaitingRoomToggle.checked = false;
              }
            });

            manageChatToggle.addEventListener("change", function () {
              if (manageChatToggle.checked) {
                dedicateToManageChatToggle.disabled = false;
              } else {
                dedicateToManageChatToggle.checked = false;
              }
            });

            // Get the checkbox values
            const isManageParticipants = manageParticipantsToggle.checked;
            const isManageMedia = manageMediaToggle.checked;
            const isManageWaitingRoom = manageWaitingRoomToggle.checked;
            const isManageChat = manageChatToggle.checked;

            // Get the dedicated checkbox values
            const isDedicateToManageParticipants =
              dedicateToManageParticipantsToggle.checked;
            const isDedicateToManageMedia = dedicateToManageMediaToggle.checked;
            const isDedicateToManageWaitingRoom =
              dedicateToManageWaitingRoomToggle.checked;
            const isDedicateToManageChat = dedicateToManageChatToggle.checked;

            if (selectedParticipant || coHost) {
              if (selectedParticipant) {
                coHost = selectedParticipant;
              }

              coHostResponsibility = [
                {
                  name: "participants",
                  value: isManageParticipants,
                  dedicated: isDedicateToManageParticipants,
                },
                {
                  name: "waiting",
                  value: isManageWaitingRoom,
                  dedicated: isDedicateToManageWaitingRoom,
                },
                {
                  name: "chat",
                  value: isManageChat,
                  dedicated: isDedicateToManageChat,
                },
                {
                  name: "media",
                  value: isManageMedia,
                  dedicated: isDedicateToManageMedia,
                },
              ];

              socket.emit("updateCoHost", {
                roomName,
                coHostResponsibility,
                coHost,
              });
            }

            // Perform actions based on the selected options and checkbox values
            // Reset the modal fields
            selectParticipant.value = "Select a participant";
            manageParticipantsToggle.checked = false;
            manageMediaToggle.checked = false;
            manageWaitingRoomToggle.checked = false;
            manageChatToggle.checked = false;
            dedicateToManageParticipantsToggle.checked = false;
            dedicateToManageMediaToggle.checked = false;
            dedicateToManageWaitingRoomToggle.checked = false;
            dedicateToManageChatToggle.checked = false;

            // Close the modal
            $("#cohostModal").modal("hide");
          });

          //get all videos to be displayed
          async function getVideos() {
            let admin = await participants.filter(
              (participant) => participant.islevel == "2"
            );
            // remove video stream with producerId == admin.id
            // get the videoID of the admin

            if (admin.length > 0) {
              adminVidID = await admin[0].videoID;

              if (adminVidID != null && adminVidID != "") {
                let oldAllStreams_ = [];
                //check if len of allVideoStreams is > 0
                if (oldAllStreams.length > 0) {
                  oldAllStreams_ = await oldAllStreams;
                }

                oldAllStreams = await allVideoStreams.filter(
                  (streame) => streame.producerId == adminVidID
                );

                if (oldAllStreams.length < 1) {
                  oldAllStreams = await oldAllStreams_;
                }

                allVideoStreams = await allVideoStreams.filter(
                  (streame) => streame.producerId != adminVidID
                );
              }
            }
          }

          async function trigger(ref_ActiveNames, t_stamp, deff = false) {
            //function to trigger the updateScreen event
            let personOnMainScreen = screenStates[0].mainScreenPerson;
            let adminName = "";
            const admin = await participants.filter(
              (participant) => participant.islevel == "2"
            );
            if (admin.length > 0) {
              adminName = await admin[0].name;
            }
            if (personOnMainScreen == "WhiteboardActive") {
              personOnMainScreen = adminName;
            }

            let mainfilled = screenStates[0].mainScreenFilled;
            let adminOnMain = screenStates[0].adminOnMainScreen;
            let mainScreenID = screenStates[0].mainScreenProducerId;
            let nForReadjust_;
            let val1;
            let val2;

            let noww = new Date().getTime();
            //get now in seconds
            let timestamp = Math.floor(noww / 1000);

            let eventPass = false;
            let mainPercent = 0;
            if (eventType == "conference" && !(shared || shareScreenStarted)) {
              eventPass = true;

              personOnMainScreen = await adminName;

              if (!ref_ActiveNames.includes(adminName)) {
                ref_ActiveNames.unshift(adminName);
              }
            }

            if (
              (mainfilled && personOnMainScreen != null && adminOnMain) ||
              eventPass
            ) {
              //check if the person on main screen is still in the room

              //   ss = false

              if (eventType == "conference") {
                nForReadjust = nForReadjust + 1;
              }

              if (
                !ref_ActiveNames.includes(adminName) &&
                whiteboardStarted &&
                !whiteboardEnded
              ) {
                ref_ActiveNames.unshift(adminName);
              }

              nForReadjust_ = ref_ActiveNames.length;

              if (nForReadjust_ == 0 && eventType == "webinar") {
                val1 = 0;
                val2 = 12; //main
              } else {
                const [val11, val22] = await autoAdjust({ n: nForReadjust_ });

                val1 = val11;
                val2 = val22;
              }

              let calc1 = await Math.floor((val1 / 12) * 100);
              let calc2 = (await 100) - calc1;

              //check if lastUpdate is not null and at least same seconds
              if (lastUpdate == null || updateDateState != timestamp) {
                let now = await new Date();

                await p_sockets[0].emit(
                  "updateScreenClient",
                  {
                    roomName,
                    names: ref_ActiveNames,
                    mainPercent: calc2,
                    mainScreenPerson: personOnMainScreen,
                    viewType: eventType,
                  },
                  ({ success, reason }) => {
                    updateDateState = timestamp;
                    lastUpdate = now;
                    if (success) {
                    } else {
                      console.log(reason, "updateScreenClient failed");
                    }
                  }
                );
              }
            } else if (
              mainfilled &&
              personOnMainScreen != null &&
              !adminOnMain
            ) {
              //check if the person on main screen is still in the room
              const admin = await participants.filter(
                (participant) => participant.islevel == "2"
              );
              let adminName = "";
              if (admin.length > 0) {
                adminName = await admin[0].name;
              }

              //   ss = true

              nForReadjust_ = ref_ActiveNames.length;

              if (!ref_ActiveNames.includes(adminName)) {
                ref_ActiveNames.unshift(adminName);
                nForReadjust_ = ref_ActiveNames.length;
              }

              const [val11, val22] = await autoAdjust({ n: nForReadjust_ });
              val1 = val11;
              val2 = val22;

              const calc1 = await Math.floor((val1 / 12) * 100);
              const calc2 = (await 100) - calc1;

              if (lastUpdate == null || updateDateState != timestamp) {
                let now = await new Date();

                await p_sockets[0].emit(
                  "updateScreenClient",
                  {
                    roomName,
                    names: ref_ActiveNames,
                    mainPercent: calc2,
                    mainScreenPerson: personOnMainScreen,
                    viewType: eventType,
                  },
                  ({ success, reason }) => {
                    updateDateState = timestamp;
                    lastUpdate = now;
                    if (success) {
                    } else {
                      console.log(reason, "updateScreenClient failed");
                    }
                  }
                );
              }
            } else {
              //stop recording
              console.log("trigger stopRecording");
            }
          }

          // Function to compare activeNames
          async function compareActiveNames(t_stamp, restart = false) {
            // function to compare activeNames and prevActiveNames

            if (restart) {
              await trigger(activeNames, t_stamp);
              return;
            }

            let nameChanged = [];

            // Compare each name in activeNames
            for (let i = 0; i < activeNames.length; i++) {
              const currentName = await activeNames[i];

              // Check if the name is present in prevActiveNames
              const hasNameChanged = await !prevActiveNames.includes(
                currentName
              );

              if (hasNameChanged) {
                await nameChanged.push(true);

                trigger(activeNames, t_stamp);
              }
            }

            // count the number of true in nameChanged
            let count = 0;

            for (let i = 0; i < nameChanged.length; i++) {
              if (nameChanged[i] == true) {
                count += 1;
              }
            }

            if (count < 1) {
              for (let i = 0; i < prevActiveNames.length; i++) {
                const currentName = await prevActiveNames[i];

                // Check if the name is present in prevActiveNames
                const hasNameChanged = await !activeNames.includes(currentName);
                // Signal change if the name is new
                if (hasNameChanged) {
                  trigger(activeNames, t_stamp);
                }
              }
            }

            // Update prevActiveNames with current activeNames
            prevActiveNames = await [...activeNames];
          }

          function compareScreenStates(t_stamp, restart = false) {
            // Function to compare screenStates and prevScreenStates

            // Check if prevScreenStates is empty (initial case)

            // Compare each key-value pair in the screenStates objects
            for (let i = 0; i < screenStates.length; i++) {
              const currentScreenState = screenStates[i];
              const prevScreenState = prevScreenStates[i];

              // Check if any value has changed
              const hasChanged = Object.keys(currentScreenState).some(
                (key) => currentScreenState[key] !== prevScreenState[key]
              );

              // Signal change if any value has changed
              if (hasChanged) {
                // Perform actions or trigger events based on the change
                if (recordingDisplayType == "video") {
                  if (recordingVideoOptimized) {
                    trigger(activeNames, t_stamp, true);
                  }
                }
                trigger(activeNames, t_stamp, true);
              }
            }
          }

          async function rePort(restart = false) {
            //function to rePort the activeNames and screenStates

            if (recordStarted || recordResumed) {
              if (recordStopped || recordPaused) {
              } else {
                if (islevel == "2") {
                  prevScreenStates = await screenStates;
                  screenStates = [
                    {
                      mainScreenPerson: mainScreenPerson,
                      adminOnMainScreen: adminOnMainScreen,
                      mainScreenFilled: mainScreenFilled,
                    },
                  ];

                  let noww = await new Date();
                  let t_stamp =
                    noww.toISOString().replace(/[-T:]/g, "").slice(0, 8) +
                    "_" +
                    noww.toISOString().replace(/[-T:]/g, "").slice(8, 14);

                  if (restart) {
                    await compareActiveNames(t_stamp, restart);
                    return;
                  }
                  await compareActiveNames(t_stamp, restart);
                  await compareScreenStates(t_stamp, restart);
                }
              }
            }
          }

          $("#recordingModal").on("hide.bs.modal", async function (event) {
            //clear all messages
            if (clearedToRecord && clearedToResume) {
              let rowHTML;

              if (eventType != "broadcast") {
                rowHTML = await `<div class="row">
  
  <div class="col-2">
  <button id="Rec_btnPause" class="btn-pause" style="background-color: transparent; border: 0; padding: 0;"><i class="fas fa-pause-circle fa-lg"></i></button>
  </div>
  <div class="col-2">
  <button id="Rec_btnStop" class="btn-stop" style="background-color: transparent; border: 0; padding: 0;"><i class="fas fa-stop-circle fa-lg"></i></button>
  </div>
  <div class="col-3">
  <div id="Rec_progressTimer" class="progress-timer Rec_progressTimer" style="background-color: transparent; border: 0; padding: 0;">00:00:00</div>
  </div>
  <div class="col-2">
  <div id="Rec_statusIndicator" class="status-indicator Rec_statusIndicator"><i class="fas fa-dot-circle-o text-success fa-lg id="Rec_statusIcon"></i></div>
  </div>
  <div class="col-2">
  <div id="Rec_Settings" class="recsettings-indicator Rec_Settings"><i class="fas fa-gear fa-lg id="Rec_settingsIcon"></i></div>
  </div>
  <div class="col-1">
  
  </div>
  
  </div>`;
              } else {
                rowHTML =
                  await `<div class="row" style="white-space: nowrap; overflow-x: auto; flex-wrap: nowrap;margin: 0 10%;">
  
  <div class="col-2">
  <button id="Rec_btnPause" class="btn-pause" style="background-color: transparent; border: 0; padding: 0;"><i class="fas fa-pause-circle fa-md"></i></button>
  </div>
  <div class="col-2">
    <button id="Rec_btnStop" class="btn-stop" style="background-color: transparent; border: 0; padding: 0;"><i class="fas fa-stop-circle fa-md"></i></button>
  </div>
  <div class="col-4">
    <div id="Rec_progressTimer" class="progress-timer Rec_progressTimer" style="background-color: transparent; border: 0; padding: 0;">00:00:00</div>
  </div>
  <div class="col-2">
    <div id="Rec_statusIndicator" class="status-indicator Rec_statusIndicator"><i class="fas fa-dot-circle-o text-success fa-sm id="Rec_statusIcon"></i></div>
  </div>
  <div class="col-2">
  <div id="Rec_Settings" class="recsettings-indicator Rec_Settings"><i class="fas fa-gear fa-md id="Rec_settingsIcon"></i></div>
  </div>
  
  </div>`;
              }

              let start;

              start = await startRecording();

              if (!start) {
                return;
              }

              recordStarted = true;
              launchRecording = false;

              await rePort(true);

              let rowElement = await $(rowHTML);

              // Append the rowElement to the desired container
              $(".recordStated").empty().append(rowElement);

              await recordStartTimer();
              await updateRecordingStateIndicator("recording", rowElement);

              rowElement.find("#Rec_Settings").on("click", async function () {
                //check if recording is paused
                if (recordPaused) {
                  //show the recording settings modal
                  $("#startRecButton").hide();
                  clearedToResume = false;
                  $("#recordingModal").modal("show");
                } else {
                  showAlert(
                    "You can only change recording settings when recording is paused.",
                    "danger"
                  );
                }
              });

              // Add event listeners to the buttons within the rowElement
              rowElement.find("#Rec_btnPause").on("click", async function () {
                //handle the pause button click event
                if (recordStopped) {
                  showAlert(
                    "Recording has been stopped. You cannot start it again.",
                    "danger"
                  );
                  return;
                }

                if (recordStarted && !recordPaused && !recordStopped) {
                  let proceed = false;

                  proceed = await checkPauseState();

                  if (!proceed) {
                    return;
                  }

                  let record = recordPauseTimer();
                  if (record) {
                    let pause = await pauseRecording();

                    if (!pause) {
                      return;
                    }

                    recordPaused = true;
                    updateRecordingStateIndicator("pause", rowElement);
                    $(this)
                      .find("i")
                      .removeClass("fa-pause-circle")
                      .addClass("fa-play-circle");

                    setTimeout(() => {
                      canPauseResume = true;
                    }, recordChangeSeconds);
                  }
                } else if (recordStarted && recordPaused && !recordStopped) {
                  if (!confirmedToRecord) {
                    showAlert(
                      "You must confirm your recording settings before you can resume recording.",
                      "danger"
                    );
                    return;
                  }

                  let proceed = false;

                  proceed = await checkResumeState();

                  if (!proceed) {
                    return;
                  }

                  let resume = recordResumeTimer();
                  if (resume) {
                    let res = await startRecording();

                    if (!res) {
                      isTimerRunning = true;
                      canPauseResume = true;
                      await recordPauseTimer();
                      isTimerRunning = false;
                      canPauseResume = true;
                      return;
                    }

                    recordPaused = false;
                    recordResumed = true;

                    await rePort(true);
                    updateRecordingStateIndicator("recording", rowElement);
                    $(this)
                      .find("i")
                      .removeClass("fa-play-circle")
                      .addClass("fa-pause-circle");

                    setTimeout(() => {
                      canPauseResume = true;
                    }, recordChangeSeconds);
                  }
                }
              });

              rowElement.find("#Rec_btnStop").on("click", async function () {
                // handle the stop button click event
                if (recordStarted && !recordStopped) {
                  let stop = recordPauseTimer(true); // Pause the timer
                  let stopped = false;
                  if (stop) {
                    stopped = await stopRecording();
                  } else {
                    return;
                  }

                  if (stopped) {
                    recordStopped = true;
                    recordPaused = false;
                    recordResumed = false;
                    recordStarted = false;

                    updateRecordingStateIndicator("stop", rowElement);

                    rowElement
                      .find("#Rec_btnPause")
                      .find("i")
                      .removeClass("fa-pause-circle")
                      .addClass("fa-play-circle");
                  }
                } else {
                  showAlert(
                    "Recording has not started yet or already stopped",
                    "warning"
                  );
                }
              });
            }
          });

          const checkResumeState = async function () {
            // function to check if the user can resume recording
            let ref_limit = 0;
            if (recordingMediaOptions == "video") {
              ref_limit = recordingVideoPausesLimit;
            } else {
              ref_limit = recordingAudioPausesLimit;
            }

            if (pauseRecordCount > ref_limit) {
              return false;
            } else {
              return true;
            }
          };

          const checkPauseState = async function () {
            // function to check if the user can pause recording
            let ref_limit = 0;
            if (recordingMediaOptions == "video") {
              ref_limit = recordingVideoPausesLimit;
            } else {
              ref_limit = recordingAudioPausesLimit;
            }

            if (pauseRecordCount < ref_limit) {
              return true;
            } else {
              showAlert(
                "You have reached the maximum number of pauses allowed.",
                "warning"
              );
              return false;
            }
          };

          function sleep(ms) {
            return new Promise((resolve) => setTimeout(resolve, ms));
          }

          const streamSuccessAudioSwitch = async (stream) => {
            // function to handle the success of switching audio devices

            let newDefAudioID = await stream.getAudioTracks()[0].getSettings()
              .deviceId;

            if (newDefAudioID != defAudioID) {
              await audioProducer.close();

              if (p_sockets.length > 0) {
                try {
                  await audioProducerMediaSFU.close();
                  await p_sockets[0].emit("pauseProducerMedia", {
                    mediaTag: "audio",
                    roomName: roomName,
                    force: true,
                  });
                } catch (error) {}
              }

              await socket.emit("pauseProducerMedia", {
                mediaTag: "audio",
                roomName: roomName,
                force: true,
              });

              localStreamAudio = await stream;

              if (localStream == null) {
                localStream = await new MediaStream([
                  localStreamAudio.getAudioTracks()[0],
                ]);
              } else {
                // Remove all audio tracks that are currently in the localStream
                await localStream.getAudioTracks().forEach((track) => {
                  localStream.removeTrack(track);
                });
                // Add the new audio track to the localStream
                await localStream.addTrack(
                  localStreamAudio.getAudioTracks()[0]
                );
              }

              const audioTracked = await localStream.getAudioTracks()[0];
              defAudioID = await audioTracked.getSettings().deviceId;

              userDefaultAudioInputDevice = await defAudioID;

              audioParams = await {
                track: localStream.getAudioTracks()[0],
                ...audioParamse,
              };

              await sleep(500);

              if (!transportCreated) {
                await createSendTransport("audio");
                if (p_sockets.length > 0) {
                  try {
                    await createSendTransportMediaSFU("audio");
                  } catch (error) {}
                }
              } else {
                await connectSendTransportAudio(audioParams);
                if (p_sockets.length > 0) {
                  try {
                    await connectSendTransportAudio(audioParams, true);
                  } catch (error) {}
                }
              }

              if (audioPaused == true && !audioAlreadyOn) {
                await audioProducer.pause();
                await socket.emit("pauseProducerMedia", {
                  mediaTag: "audio",
                  roomName: roomName,
                });

                if (p_sockets.length > 0) {
                  try {
                    await audioProducerMediaSFU.pause();
                    await p_sockets[0].emit("pauseProducerMedia", {
                      mediaTag: "audio",
                      roomName: roomName,
                    });
                  } catch (error) {}
                }
              }
            }

            if (videoAlreadyOn == false && islevel == "2") {
              if (!lock_screen && !shared) {
                updateMainWindow = true;
                await prepopulateUserMedia(hostLabel);
                updateMainWindow = false;
              }
            }
          };

          const streamSuccessVideoSwitch = async (stream) => {
            // function to handle the success of switching video devices

            localStreamVideo = await stream;

            if (localStream == null) {
              localStream = await new MediaStream([
                localStreamVideo.getVideoTracks()[0],
              ]);
            } else {
              // remove all video tracks that are currently in the localStream
              await localStream.getVideoTracks().forEach((track) => {
                localStream.removeTrack(track);
              });
              // add the new video track to the localStream
              await localStream.addTrack(localStreamVideo.getVideoTracks()[0]);
            }

            const videoTracked = await localStream.getVideoTracks()[0];
            defVideoID = await videoTracked.getSettings().deviceId;
            userDefaultVideoInputDevice = await defVideoID;
            currentFacingMode = await videoTracked.getSettings().facingMode;

            let codecs = device.rtpCapabilities.codecs.filter(
              (codec) =>
                codec.mimeType.toLowerCase() !== "video/vp9" &&
                codec.kind === "video"
            );
            let codec = codecs[0];

            videoParams = await {
              track: localStream.getVideoTracks()[0],
              ...videoParamse,
              codec,
            };

            videoAlreadyOn = await true;

            if (!transportCreated) {
              await createSendTransport("video");
              if (p_sockets.length > 0) {
                try {
                  await createSendTransportMediaSFU("video");
                } catch (error) {}
              }
            } else {
              await connectSendTransportVideo(videoParams);
              if (p_sockets.length > 0) {
                try {
                  await connectSendTransportVideo(videoParams, true);
                } catch (error) {}
              }
            }

            if (islevel == "2") {
              updateMainWindow = true;
            }

            if (lock_screen) {
              await reorderStreams(true, true);
            } else {
              await reorderStreams(false, true);
            }
          };

          async function switchUserVideoAlt(videoPreference, checkoff) {
            try {
              if (audioOnlyRoom) {
                showAlert(
                  "You cannot turn on your camera in an audio only event.",
                  "danger"
                );
                return;
              }

              if (!checkoff) {
                //trigger click on the video button

                await $(".videoStated").trigger("click");

                //wait for 0.5 seconds

                await $(".videoStated").prop("disabled", true);
                await sleep(500);
                await $(".videoStated").prop("disabled", false);
              }

              // enumerate the devices and select the ones with 'front' in the label
              const videoDevices =
                await navigator.mediaDevices.enumerateDevices();
              //check for string 'front' in the labels

              await navigator.mediaDevices
                .getUserMedia({
                  video: {
                    facingMode: { exact: videoPreference },
                    ...vidCons,
                    frameRate: { ideal: frameRate },
                  },
                  audio: false,
                })
                .then(streamSuccessVideo)
                .catch((error) => {
                  let videoDevicesFront = [];
                  if (videoPreference === "user") {
                    videoDevicesFront = videoDevices.filter(
                      (device) =>
                        device.label.includes("front") &&
                        device.kind === "videoinput"
                    );
                  } else {
                    videoDevicesFront = videoDevices.filter(
                      (device) =>
                        device.label.includes("back") &&
                        device.kind === "videoinput"
                    );
                  }

                  if (videoDevicesFront.length > 0) {
                    videoDevicesFront.forEach((device) => {
                      if (device.kind === "videoinput") {
                        let videoDeviceId = device.deviceId;

                        navigator.mediaDevices
                          .getUserMedia({
                            video: {
                              deviceId: { exact: videoDeviceId },
                              ...vidCons,
                              frameRate: { ideal: frameRate },
                            },
                            audio: false,
                          })
                          .then(streamSuccessVideo)
                          .catch((error) => {
                            // if current video device is the last one in the list, show the error else try next device
                            if (
                              videoDeviceId ===
                              videoDevicesFront[videoDevicesFront.length - 1]
                                .deviceId
                            ) {
                              currentFacingMode = prevFacingMode;

                              showAlert(
                                "Error switching; not accessible, might need to turn off your video and turn it back on after switching.",
                                "danger"
                              );
                            }
                          });
                      }
                    });
                  } else {
                    currentFacingMode = prevFacingMode;

                    showAlert(
                      "Error switching; not accessible, might need to turn off your video and turn it back on after switching.",
                      "danger"
                    );
                  }
                });
            } catch (error) {
              let videoDevicesFront = [];
              if (videoPreference === "user") {
                videoDevicesFront = videoDevices.filter((device) =>
                  device.label.includes("front")
                );
              } else {
                videoDevicesFront = videoDevices.filter((device) =>
                  device.label.includes("back")
                );
              }

              if (videoDevicesFront.length > 0) {
                videoDevicesFront.forEach((device) => {
                  if (device.kind === "videoinput") {
                    let videoDeviceId = device.deviceId;

                    navigator.mediaDevices
                      .getUserMedia({
                        video: {
                          deviceId: { exact: videoDeviceId },
                          ...vidCons,
                          frameRate: { ideal: frameRate },
                        },
                        audio: false,
                      })
                      .then(streamSuccessVideo)
                      .catch((error) => {
                        // if current video device is the last one in the list, show the error else try next device
                        if (
                          videoDeviceId ===
                          videoDevicesFront[videoDevicesFront.length - 1]
                            .deviceId
                        ) {
                          currentFacingMode = prevFacingMode;

                          showAlert(
                            "Error switching; not accessible, might need to turn off your video and turn it back on after switching.",
                            "danger"
                          );
                        }
                      });
                  }
                });
              } else {
                currentFacingMode = prevFacingMode;

                showAlert(
                  "Error switching; not accessible, might need to turn off your video and turn it back on after switching.",
                  "danger"
                );
              }
            }
          }

          async function switchUserVideo(videoPreference, checkoff) {
            // function to switch the user's video device
            try {
              if (audioOnlyRoom) {
                showAlert(
                  "You cannot turn on your camera in an audio only event.",
                  "danger"
                );
                return;
              }

              if (!checkoff) {
                //trigger click on the video button
                $("body")
                  .find(".videoStated")
                  .each(async function () {
                    await $(this).trigger("click");
                  });

                //wait for 0.5 seconds
                $("body")
                  .find(".videoStated")
                  .each(async function () {
                    await $(this).prop("disabled", true);
                    await sleep(500);
                    await $(this).prop("disabled", false);
                  });
              }

              await navigator.mediaDevices
                .getUserMedia({
                  video: {
                    deviceId: { exact: videoPreference },
                    ...vidCons,
                    frameRate: { ideal: frameRate },
                  },
                  audio: false,
                })
                .then(streamSuccessVideo)
                .catch((error) => {
                  userDefaultVideoInputDevice = prevVideoInputDevice;

                  showAlert(
                    "Error switching; not accessible, might need to turn off your video and turn it back on after switching.",
                    "danger"
                  );
                });
            } catch (error) {
              userDefaultVideoInputDevice = prevVideoInputDevice;
              showAlert(
                "Error switching; not accessible, might need to turn off your video and turn it back on after switching.",
                "danger"
              );
            }
          }

          async function switchUserAudio(audioPreference) {
            // function to switch the user's audio device

            try {
              await navigator.mediaDevices
                .getUserMedia({
                  video: false,
                  audio: { deviceId: { exact: audioPreference } },
                })
                .then(streamSuccessAudioSwitch)
                .catch((error) => {
                  userDefaultAudioInputDevice = prevAudioInputDevice;

                  showAlert(
                    "Error switching; the specified microphone could not be accessed.",
                    "danger"
                  );
                });
            } catch (error) {
              userDefaultAudioInputDevice = prevAudioInputDevice;
              showAlert(
                "Error switching; the specified microphone could not be accessed.",
                "danger"
              );
            }
          }

          $("#mediaSettingsModal").on("shown.bs.modal", async function () {
            // hide the parent modal
            if (islevel == "2" || coHost == member) {
              $("#menuModal").modal("hide");
            } else {
              $("#shareMeetingModal").modal("hide");
            }

            try {
              const devices = await navigator.mediaDevices.enumerateDevices();
              // Filter the list to get only audio and video input devices
              const videoInputs = await devices.filter(
                (device) => device.kind === "videoinput"
              );
              const audioInputs = await devices.filter(
                (device) => device.kind === "audioinput"
              );

              const videoDropdown = $("#cameraList");
              const audioInputDropdown = $("#microphoneList");

              // Clear the previous options
              videoDropdown.empty();
              audioInputDropdown.empty();

              // Populate the video dropdown with camera options
              await videoInputs.forEach((input) => {
                const option = $("<option></option>")
                  .attr("value", input.deviceId)
                  .text(input.label);

                videoDropdown.append(option);
                // videoDropdown.trigger('change');
                if (input.deviceId == userDefaultVideoInputDevice) {
                  option.attr("selected", true);
                }
              });

              // Populate the audio input dropdown with microphone options
              await audioInputs.forEach((input) => {
                const option = $("<option></option>")
                  .attr("value", input.deviceId)
                  .text(input.label);
                audioInputDropdown.append(option);

                if (input.deviceId == userDefaultAudioInputDevice) {
                  option.attr("selected", true);
                }
              });

              if (userDefaultVideoInputDevice) {
                videoDropdown.val(userDefaultVideoInputDevice);
              }

              if (userDefaultAudioInputDevice) {
                audioInputDropdown.val(userDefaultAudioInputDevice);
              }

              if (userDefaultVideoInputDevice) {
                videoDropdown
                  .find(`option[value='${userDefaultVideoInputDevice}']`)
                  .prop("selected", true);
              }

              if (userDefaultAudioInputDevice) {
                audioInputDropdown
                  .find(`option[value='${userDefaultAudioInputDevice}']`)
                  .prop("selected", true);
              }

              // Limit the width of the select element's parent div
              audioInputDropdown.parent().css("max-width", "100%");
              videoDropdown.parent().css("max-width", "100%");

              // Update the video and audio sources when the user selects a new device
              videoDropdown.on("change", async () => {
                let checkoff = false;

                if (
                  (recordStarted || recordResumed) &&
                  !recordStopped &&
                  !recordPaused
                ) {
                  if (recordingMediaOptions == "video") {
                    checkoff = true;
                  }
                }

                if (!allowed) {
                  showAlert(
                    "Allow access to your camera by starting it for the first time.",
                    "danger"
                  );
                  return;
                }

                if (checkoff) {
                  if (videoAlreadyOn) {
                    showAlert(
                      "Please turn off your video before switching.",
                      "danger"
                    );

                    if (userDefaultVideoInputDevice) {
                      videoDropdown
                        .find(`option[value='${userDefaultVideoInputDevice}']`)
                        .prop("selected", true);
                    } else {
                      videoDropdown.prop("selectedIndex", 0);
                    }

                    return;
                  }
                } else {
                  if (!videoAlreadyOn) {
                    showAlert(
                      "Please turn on your video before switching.",
                      "danger"
                    );

                    if (userDefaultVideoInputDevice) {
                      videoDropdown
                        .find(`option[value='${userDefaultVideoInputDevice}']`)
                        .prop("selected", true);
                    } else {
                      videoDropdown.prop("selectedIndex", 0);
                    }

                    return;
                  }
                }

                let videoPreference = await videoDropdown.val();

                if (defVideoID) {
                } else {
                  if (userDefaultVideoInputDevice) {
                    defVideoID = userDefaultVideoInputDevice;
                  } else {
                    defVideoID = "default";
                  }
                }

                if (videoPreference !== defVideoID) {
                  prevVideoInputDevice = userDefaultAudioInputDevice;
                  userDefaultVideoInputDevice = videoPreference;

                  //get the current video deviceid
                  if (defVideoID) {
                    $("#mediaSettingsModal").modal("hide");
                    await switchUserVideo(videoPreference, checkoff);
                  }
                }
              });

              audioInputDropdown.on("change", async () => {
                let audioPreference = await audioInputDropdown.val();

                if (audioPreference !== defAudioID) {
                  prevAudioInputDevice = userDefaultAudioInputDevice;
                  userDefaultAudioInputDevice = audioPreference;

                  if (defAudioID) {
                    switchUserAudio(audioPreference);
                  }
                  //
                }
              });
            } catch (error) {}
          });

          function loadReactStandardPanelContent() {
            // function to load the standard panel content for the react panel

            if (!clearedToResume) {
              prevRecordingMediaOptions = recordingMediaOptions;
            }

            $("#standardReactPanel").html(`
  <div class="form-group">
  <label for="mediaOptions">Media Options:</label>
  <select class="form-control" id="mediaOptions">
  <option value="video">Record Video</option>
  <option value="audio">Record Audio Only</option>
  </select>
  </div>
  
  <br>
  
  <div class="form-group">
  <label for="nameTags">Include Name Tags:</label>
  <select class="form-control" id="nameTags">
  <option value=true>True</option>
  <option value=false>False</option>
  </select>
  </div>
  
  <br>
  
  <div class="form-group">
  <label for="displayType">Video Type:</label>
  <select class="form-control" id="displayType">
  <option value='fullDisplay'>Full Display (no background)</option>
  <option value='bestDisplay'>Full Video</option>
  <option value='all'>All</option>
  </select>
  </div>
  
  <br>
  
  <div class="form-group">
  <label for="backgroundColor">Background Color:</label>
  <input type="color" class="form-control" id="backgroundColor" value="#e8eaec">
  </div>
  
  <br>
  
  <div class="form-group">
  <label for="nameTagsColor">Name Tags Color:</label>
  <input type="color" class="form-control" id="nameTagsColor" value="#ffffff">
  </div>
  
  <br>
  
  <div class="form-group">
  <label for="orientationVideo">Orientation (Video):</label>
  <select class="form-control" id="orientationVideo">
  <option value='landscape' >Landscape</option>
  <option value='portrait' >Portrait</option>
  <option value='all'>All</option>
  </select>
  </div>
  
  <br>
  
  <div class="form-group" id="addHLSPart">
  <label for="addHLS">Add HLS:</label>
  <select class="form-control" id="addHLS">
  <option value=true>True</option>
  <option value=false>False</option>
  </select>
  </div> 
  
  <br>
  <hr>
  
  `);

            let backgroundColorInput =
              document.getElementById("backgroundColor");
            let nameTagsColorInput = document.getElementById("nameTagsColor");

            // Function to convert RGB color value to hexadecimal
            function rgbToHex(rgb) {
              let hex = rgb.match(/^rgb\((\d+),\s*(\d+),\s*(\d+)\)$/);
              if (hex) {
                return (
                  "#" +
                  ("0" + parseInt(hex[1], 10).toString(16)).slice(-2) +
                  ("0" + parseInt(hex[2], 10).toString(16)).slice(-2) +
                  ("0" + parseInt(hex[3], 10).toString(16)).slice(-2)
                );
              }
              return rgb;
            }

            // Add event listeners to retrieve the color values
            backgroundColorInput.addEventListener("input", function (event) {
              var backgroundColor = rgbToHex(event.target.value);
            });

            nameTagsColorInput.addEventListener("input", function (event) {
              var nameTagsColor = rgbToHex(event.target.value);
            });
          }

          function loadRecordText() {
            const addTextSelectInput = document.getElementById("addText");
            let customTextInput = document.getElementById("customText");
            const customTextPositionInput =
              document.getElementById("customTextPosition");
            let customTextColorInput =
              document.getElementById("customTextColor");

            let customTextPart = document.getElementById("customTextPart");
            let customTextPositionPart = document.getElementById(
              "customTextPositionPart"
            );
            let customTextColorPart = document.getElementById(
              "customTextColorPart"
            );

            // Function to hide elements if addText is false
            function hideElementsIfTextNotAdded() {
              // Get the value of the addText select element
              const addTextValue = addTextSelectInput.value;

              // Hide or show elements based on the value of addText
              if (addTextValue == "false" || addTextValue == false) {
                customTextPart.style.display = "none";
                customTextPositionPart.style.display = "none";
                customTextColorPart.style.display = "none";
              } else {
                customTextPart.style.display = "";
                customTextPositionPart.style.display = "";
                customTextColorPart.style.display = "";
              }
            }

            // Function to convert RGB color value to hexadecimal
            function rgbToHex(rgb) {
              var hex = rgb.match(/^rgb\((\d+),\s*(\d+),\s*(\d+)\)$/);
              if (hex) {
                return (
                  "#" +
                  ("0" + parseInt(hex[1], 10).toString(16)).slice(-2) +
                  ("0" + parseInt(hex[2], 10).toString(16)).slice(-2) +
                  ("0" + parseInt(hex[3], 10).toString(16)).slice(-2)
                );
              }
              return rgb;
            }

            // Add event listeners to retrieve the color values
            customTextColorInput.addEventListener("input", function (event) {
              var customTextColor = rgbToHex(event.target.value);
            });

            // Add an event listener to the customText input field
            customTextInput.addEventListener("input", function (event) {
              // Get the input value
              let inputValue = event.target.value;

              // Replace non-alphanumeric characters and non-space characters with empty string
              inputValue = inputValue.replace(/[^a-zA-Z0-9\s]/g, "");

              // Limit the input length to 40 characters
              if (inputValue.length > 40) {
                inputValue = inputValue.slice(0, 40);
              }

              // Update the input value
              event.target.value = inputValue;
            });

            // Call the function initially
            hideElementsIfTextNotAdded();

            // Add event listener to the addText select element to detect changes
            addTextSelectInput.addEventListener(
              "change",
              hideElementsIfTextNotAdded
            );
          }

          function loadStandardPanelContent() {
            // function to load the standard panel content for the standard panel

            if (!clearedToResume) {
              prevRecordingMediaOptions = recordingMediaOptions;
            }

            $("#standardPanel").html(`
  <div class="form-group">
  <label for="mediaOptions">Media Options:</label>
  <select class="form-control" id="mediaOptions">
    <option value="video">Record Video</option>
    <option value="audio">Record Audio Only</option>
  </select>
  </div>
  
  <br>
  
  <div class="form-group">
  <label for="audioOptions">Specific Audios:</label>
  <select class="form-control" id="audioOptions">
    <option value="all">Add All</option>
    <option value="onScreen">Add All On Screen</option>
    <option value="host">Add Host Only</option>
  </select>
  </div>
  
  <br>
  
  <div class="form-group" id="conditionalConference">
  <label for="videoOptions">Specific Videos:</label>
  <select class="form-control" id="videoOptions">
  <option value="all">Add All </option>
    <option value="mainScreen">Big Screen Only (includes screenshare)</option>
  </select>
  </div>
  
  <div class="form-group" id="addHLSPart">
  <label for="addHLS">Add HLS:</label>
  <select class="form-control" id="addHLS">
    <option value=true>True</option>
    <option value=false>False</option>
  </select>
  </div>
  
  <div class="form-group" id="addTextPart">
  <label for="addText">Add Custom Text:</label>
  <select class="form-control" id="addText">
  <option value=true>True</option>
  <option value=false>False</option>
  </select>
  </div>
  
  <div class="form-group" id="customTextPart">
  <label for="customText">Custom Text:</label>
  <input type="text" class="form-control" id="customText" placeholder="Enter custom text">
  </div>
  
  <div class="form-group" id="customTextPositionPart">
  <label for="customTextPosition">Custom Text Position:</label>
  <select class="form-control" id="customTextPosition">
  <option value="top">Top</option>
  <option value="middle">Middle</option>
  <option value="bottom">Bottom</option>
  </select>
  </div>
  
  <br/>
  
  <div class="form-group" id="customTextColorPart">
  <label for="customTextColor">Custom Text Color:</label>
  <input type="color" class="form-control" id="customTextColor" value="#ffffff">
  </div>
  
  <br>
  <hr>
  
  `);
          }

          function loadAdvancedPanelContent() {
            // function to load the advanced panel content

            $("#advancedPanel").html(`
  <div class="form-group">
  <label for="displayType">Video Type:</label>
  <select class="form-control" id="displayType">
  <option value='fullDisplay'>Full Display (no background)</option>
  <option value='bestDisplay'>Full Video</option>
  <option value='all'>All</option>
  </select>
  </div>
  
  <br>
  
  <div class="form-group">
  <label for="recordDisplayOptions">Display Type:</label>
  <select class="form-control" id="recordDisplayOptions">
  <option value="video">Only Video Participants</option>
  <option value="videoOpt">Only Video Participants (optimized) </option>
  <option value="media">Participants with media</option>
  <option value="all">All Participants</option>
  </select>
  </div>
  
  <br>
  
  <div class="form-group">
  <label for="nameTags">Include Name Tags:</label>
  <select class="form-control" id="nameTags">
  <option value='true'>True</option>
  <option value='false'>False</option>
  </select>
  </div>
  
  <br>
  
  <div class="form-group">
  <label for="backgroundColor">Background Color:</label>
  <input type="color" class="form-control" id="backgroundColor" value="#e8eaec">
  </div>
  
  <br>
  
  <div class="form-group">
  <label for="nameTagsColor">Name Tags Color:</label>
  <input type="color" class="form-control" id="nameTagsColor" value="#ffffff">
  </div>
  
  <br>
  
  <div class="form-group">
  <label for="orientationVideo">Orientation (Video):</label>
  <select class="form-control" id="orientationVideo">
  <option value='landscape' >Landscape</option>
  <option value='portrait' >Portrait</option>
  <option value='all'>All</option>
  </select>
  </div>
  
  <br>
  <hr>
  `);

            var backgroundColorInput =
              document.getElementById("backgroundColor");
            var nameTagsColorInput = document.getElementById("nameTagsColor");

            // Function to convert RGB color value to hexadecimal
            function rgbToHex(rgb) {
              var hex = rgb.match(/^rgb\((\d+),\s*(\d+),\s*(\d+)\)$/);
              if (hex) {
                return (
                  "#" +
                  ("0" + parseInt(hex[1], 10).toString(16)).slice(-2) +
                  ("0" + parseInt(hex[2], 10).toString(16)).slice(-2) +
                  ("0" + parseInt(hex[3], 10).toString(16)).slice(-2)
                );
              }
              return rgb;
            }

            // Add event listeners to retrieve the color values
            backgroundColorInput.addEventListener("input", function (event) {
              var backgroundColor = rgbToHex(event.target.value);
            });

            nameTagsColorInput.addEventListener("input", function (event) {
              var nameTagsColor = rgbToHex(event.target.value);
            });
          }

          // Event listener for the "Recording Modal" show event
          $("#recordingModal").on("show.bs.modal", async function () {
            // Load the content of the "Standard" panel
            confirmedToRecord = false;

            if (eventType != "broadcast") {
              await loadStandardPanelContent();
              await loadRecordText();
              await loadAdvancedPanelContent();

              if (eventType == "conference") {
                $("#conditionalConference").hide();
              }
            } else {
              await loadReactStandardPanelContent();
            }

            let recordingDisplayTypeShow = recordingDisplayType;

            if (
              recordingVideoOptimized == true &&
              recordingDisplayType == "video"
            ) {
              recordingDisplayTypeShow = "videoOpt";
            }

            // Check if the variable exists before populating the "displayType" select element
            if (recordingVideoType) {
              $("#displayType").val(recordingVideoType);
            }

            // Check if the variable exists before populating the "recordDisplayOptions" select element
            if (recordingDisplayTypeShow) {
              $("#recordDisplayOptions").val(recordingDisplayTypeShow);
            }

            // Check if the variable exists before populating the "nameTags" select element
            let recordingNameTags_ = `${recordingNameTags}`;
            if (recordingNameTags_) {
              $("#nameTags").val(recordingNameTags_);
            }

            // Check if the variable exists before populating the "backgroundColor" input element
            if (recordingBackgroundColor) {
              $("#backgroundColor").val(recordingBackgroundColor);
            }

            // Check if the variable exists before populating the "nameTagsColor" input element
            if (recordingNameTagsColor) {
              $("#nameTagsColor").val(recordingNameTagsColor);
            }

            // Check if the variable exists before populating the "orientationVideo" select element
            if (recordingOrientationVideo) {
              $("#orientationVideo").val(recordingOrientationVideo);
            }

            // Check if the variable exists before populating the "mediaOptions" select element
            if (recordingMediaOptions) {
              $("#mediaOptions").val(recordingMediaOptions);
            }

            // Check if the variable exists before populating the "audioOptions" select element
            if (recordingAudioOptions) {
              $("#audioOptions").val(recordingAudioOptions);
            }

            //addHLS part
            if (recordingAddHLS) {
              $("#addHLS").val(recordingAddHLS);
            }

            //add text part
            if (recordingAddText) {
              $("#addText").val(recordingAddText);
            }

            //custom text part
            if (recordingCustomText) {
              $("#customText").val(recordingCustomText);
            }

            //custom text position part
            if (recordingCustomTextPosition) {
              $("#customTextPosition").val(recordingCustomTextPosition);
            }

            //custom text color part
            if (recordingCustomTextColor) {
              $("#customTextColor").val(recordingCustomTextColor);
            }

            // Check if the variable exists before populating the "videoOptions" select element
            if (eventType != "conference") {
              if (recordingVideoOptions) {
                $("#videoOptions").val(recordingVideoOptions);
              }
            }

            $(
              "#displayType, #nameTags, #backgroundColor, #nameTagsColor, #orientationVideo, #mediaOptions, #audioOptions, #videoOptions, #recordDisplayOptions"
            ).on("change", function () {
              // Set confirmedToRecord to false
              confirmedToRecord = false;
            });
          });

          // Function to generate the content for each page
          async function generatePageContent(
            page,
            breakRoom = -1,
            inBreakRoom = false
          ) {
            let page_ = await page;
            if (page === 0 || page === "0") {
              page = "home";
            }

            const tabContentId = await `minigrid-${page}`;
            const tabLinkId = await `minigrid-${page}-tab`;

            await $(`${tabContentId}`).remove();

            // Generate the content for the current page
            const pageContent = await `
  <div class="tab-pane fade" id="${tabContentId}" role="tabpanel" aria-labelledby="${tabLinkId}" style="height: 100%; width: 100%;">
  <div class="minigrid" style="display: grid; grid-gap: 3px; justify-content: center; width: 100%; margin: 0; padding: 0; margin-top: 0%; padding-top: 0px;"></div>
  </div>
  `;

            await $("#minigrid-tabContent").append(pageContent);
            if (page_ === 0 || page_ === "0") {
              page = await page_;
            }
            page = parseInt(page);
            currentUserPage = page;
            updateMainWindow = true;

            await dispStreams(
              paginatedStreams[page],
              page,
              false,
              false,
              null,
              null,
              breakRoom,
              inBreakRoom
            );
          }

          async function handlePageChange(page, offSet = 0) {
            // Generate the content for the current page

            if (breakOutRoomStarted && !breakOutRoomEnded && page != "0") {
              //check if you are part of the breakout room

              const roomMember = breakoutRooms.find((r) =>
                r.find((p) => p.name == member)
              );
              const pageInt = parseInt(page) - offSet;
              let memberBreakRoom = -1;
              if (roomMember) {
                memberBreakRoom = breakoutRooms.indexOf(roomMember);
              }

              if (
                (memberBreakRoom == -1 || memberBreakRoom != pageInt) &&
                pageInt >= 0
              ) {
                if (islevel != "2") {
                  showAlert(
                    `You are not part of the breakout room ${pageInt + 1}.`,
                    "danger"
                  );
                  //generate the page content for the memberBreakRoom
                  if (memberBreakRoom != -1) {
                    page = `${memberBreakRoom}`;
                    await generatePageContent(page, pageInt, true);
                    await onScreenChanges(true);
                  }
                  return;
                }

                await generatePageContent(page, pageInt, true);
                if (hostNewRoom != pageInt) {
                  //update the breakout room by moving the user to the breakout room
                  await socket.emit(
                    "updateHostBreakout",
                    { newRoom: pageInt, roomName },
                    async (response) => {}
                  );
                }
              } else {
                await generatePageContent(page, pageInt, pageInt >= 0);
                //if host; update the breakout room for moving out
                if (islevel == "2" && hostNewRoom != -1) {
                  await socket.emit(
                    "updateHostBreakout",
                    { prevRoom: hostNewRoom, newRoom: -1, roomName },
                    async (response) => {}
                  );
                }
              }
            } else {
              await generatePageContent(page, 0, false);
              //if host; update the breakout room for moving out
              if (islevel == "2" && hostNewRoom != -1) {
                await socket.emit(
                  "updateHostBreakout",
                  { prevRoom: hostNewRoom, newRoom: -1, roomName },
                  async (response) => {}
                );
              }
            }
          }

          async function generatePagination(
            totalPages,
            addClass = false,
            mainLength = 0,
            targetPage = -1
          ) {
            // Function to generate the pagination links

            let paginationElement = await $("#minigrid-tab");

            // Loop through each page and add the page links
            for (let page = 1; page <= totalPages; page++) {
              const tabContentId = await `minigrid-${page}`;
              const tabLinkId = await `minigrid-${page}-tab`;

              let activeClass = "";

              if (addClass) {
                if (page === currentUserPage) {
                  activeClass = "active";
                }
              }

              // pages for breakout rooms are named 'Room 1', 'Room 2', etc.
              // we name so if the breakout room is started and not ended and the page is greater than or equal to the mainLength, for those,
              // we add a padlock icon to the page name if the user (targetPage) is not part of the breakout room && is not a co-host or islevel is not 2

              let page_ = page;
              if (
                breakOutRoomStarted &&
                !breakOutRoomEnded &&
                page >= mainLength
              ) {
                if (targetPage != page - mainLength) {
                  if (islevel != "2") {
                    page_ = `Room ${
                      page - (mainLength - 1)
                    } <i class="fas fa-lock"></i>`;
                  } else {
                    page_ = `Room ${page - (mainLength - 1)}`;
                  }
                } else {
                  page_ = `Room ${page - (mainLength - 1)}`;
                }
              }

              await paginationElement.append(`
      <li class="nav-item flex-fill" style="margin: 0 auto; padding: 0 auto; border-radius: 0;" >
          <a class="nav-link custom-link ${activeClass}" style="margin: 0 auto; padding: 0 auto"
           id="${tabLinkId}" data-toggle="tab" href="#${tabContentId}" role="tab" aria-controls="${tabContentId}" aria-selected="false">${page_}</a>
      </li>
      `);
            }
            // Add click or change event listeners to the page links
            await paginationElement
              .find(".custom-link")
              .on("click", async function (event) {
                // Get the ID of the clicked tab
                const clickedTabId = await $(this).attr("href");
                // Get the ID of the currently active tab
                const activeTabId = await $(".custom-link.active").attr("href");

                // Compare the IDs to check if they are the same
                if (clickedTabId === activeTabId) {
                  return; // Do nothing if they are the same
                }

                // if its a locked room, do nothing
                if (
                  $(this).html().includes("Room") &&
                  $(this).html().includes("fa-lock")
                ) {
                  showAlert(
                    "You are not part of this breakout room.",
                    "danger"
                  );
                  //prevent the default action
                  event.preventDefault();
                  return;
                }

                // Get the previously active tab
                const previousTab = await $(event.relatedTarget);

                // Hide the content of the previously active tab
                const previousTabContent = await $(previousTab.attr("href"));

                await previousTabContent.remove();
                await $("#minigrid-home").remove();
                await $('[id^="minigrid-"]')
                  .filter(function () {
                    return /\d$/.test(this.id);
                  })
                  .remove();

                //get and split the `minigrid-${page}-tab` to get the page number
                let selectedPage = $(this).attr("id").split("-")[1];
                if (selectedPage == "home") {
                  selectedPage = "0";
                }

                await handlePageChange(selectedPage, mainLength);
              });
          }

          $("#displaySettingsModal").on("show.bs.modal", async function () {
            $(
              'input[name="displayOption"][value="' + meetingDisplayType + '"]'
            ).prop("checked", true);
            $("#displayOptionOverlay").prop("checked", autoWave);
            $("#displayOptionFull").prop("checked", forceFullDisplay);
            $("#displayOptionForce").prop("checked", meetingVideoOptimized);

            $("#applyDisplaySettings").on("click", async function () {
              const selectedOption = $(
                'input[name="displayOption"]:checked'
              ).val();
              const showOverlay = $("#displayOptionOverlay").prop("checked");
              const forceFullDisplayed =
                $("#displayOptionFull").prop("checked");
              const meetingVideoOpt = $("#displayOptionForce").prop("checked");

              autoWave = await showOverlay;
              prevForceFullDisplay = await forceFullDisplay;

              // Close the modal
              prevMeetingDisplayType = await meetingDisplayType;
              forceFullDisplay = await forceFullDisplayed;

              meetingDisplayType = await selectedOption;

              meetingVideoOptimized = await meetingVideoOpt;

              if (
                islevel == "2" &&
                (recordStarted || recordResumed) &&
                !recordStopped &&
                !recordPaused
              ) {
                if (recordingDisplayType == "video") {
                  if (
                    meetingDisplayType == "video" &&
                    meetingVideoOptimized &&
                    !recordingVideoOptimized
                  ) {
                    showAlert(
                      "Meeting display type can be either video, media or all when recording display type is non-optmized video."
                    );
                    meetingDisplayType = recordingDisplayType;
                    meetingVideoOptimized = recordingVideoOptimized;
                  }
                } else if (recordingDisplayType == "media") {
                  if (meetingDisplayType == "video") {
                    showAlert(
                      "Meeting display type can be either media or all when recording display type is media."
                    );
                    meetingDisplayType = recordingDisplayType;
                  }
                } else if (recordingDisplayType === "all") {
                  if (
                    meetingDisplayType == "video" ||
                    meetingDisplayType == "media"
                  ) {
                    showAlert(
                      "Meeting display type can be only all when recording display type is all."
                    );
                    meetingDisplayType = recordingDisplayType;
                  }
                }
              }

              $("#displaySettingsModal").modal("hide");
            });
          });

          $("#displaySettingsModal").on("hide.bs.modal", async function () {
            if (
              prevMeetingDisplayType !== meetingDisplayType ||
              prevForceFullDisplay !== forceFullDisplay
            ) {
              if (
                breakOutRoomStarted &&
                !breakOutRoomEnded &&
                meetingDisplayType != "all"
              ) {
                showAlert(
                  "Breakout room is active. Display type can only be all.",
                  "danger"
                );
                meetingDisplayType = prevMeetingDisplayType;
                return;
              }

              if (meetingDisplayType != "all") {
                firstAll = true;
              } else {
                firstAll = false;
              }
              updateMainWindow = true;
              await onScreenChanges(true);
            }
          });

          function updateAudioDecibels(name, averageLoudness) {
            // Function to update the audioDecibels array
            // Check if the entry already exists in audioDecibels
            const existingEntry = audioDecibels.find(
              (entry) => entry.name === name
            );

            if (existingEntry) {
              // Entry exists, update the averageLoudness
              existingEntry.averageLoudness = averageLoudness;
            } else {
              // Entry doesn't exist, add a new entry to audioDecibels
              audioDecibels.push({ name, averageLoudness });
            }
          }

          async function mixStreams(_alVideoStreams, _non_alVideoStreams) {
            // Function to mix the audio and video streams

            const mixedStreams = [];
            const youyouStream = _alVideoStreams.find(
              (obj) =>
                obj.producerId === "youyou" || obj.producerId === "youyouyou"
            );
            _alVideoStreams = _alVideoStreams.filter(
              (obj) =>
                obj.producerId !== "youyou" && obj.producerId !== "youyouyou"
            );
            const unmutedAlVideoStreams = _alVideoStreams.filter((obj) => {
              const participant = ref_participants.find(
                (p) => p.videoID === obj.producerId
              );
              return !obj.muted && participant && participant.muted === false;
            });
            const mutedAlVideoStreams = _alVideoStreams.filter((obj) => {
              const participant = ref_participants.find(
                (p) => p.videoID === obj.producerId
              );
              return obj.muted || (participant && participant.muted === true);
            });
            const nonAlVideoStreams = _non_alVideoStreams.slice(); // Create a copy of _non_alVideoStreams

            // Add unmutedAlVideoStreams to mixedStreams
            mixedStreams.push(...unmutedAlVideoStreams);

            // Interleave the mutedAlVideoStreams and nonAlVideoStreams
            let nonAlIndex = 0;
            for (let i = 0; i < mutedAlVideoStreams.length; i++) {
              if (nonAlIndex < nonAlVideoStreams.length) {
                mixedStreams.push(nonAlVideoStreams[nonAlIndex]);
                nonAlIndex++;
              }
              mixedStreams.push(mutedAlVideoStreams[i]);
            }

            // Handle remaining mutedAlVideoStreams (if any)
            for (let i = nonAlIndex; i < nonAlVideoStreams.length; i++) {
              mixedStreams.push(nonAlVideoStreams[i]);
            }

            // Unshift 'youyou' or 'youyouyou' stream to mixedStreams
            if (youyouStream) {
              mixedStreams.unshift(youyouStream);
            }
            return mixedStreams;
          }

          function checkOrientation() {
            // Function to check the orientation of the device

            if (window.orientation === undefined) {
              // Check using screen object
              if (
                screen.orientation &&
                (screen.orientation.type === "portrait-primary" ||
                  screen.orientation.type === "portrait-secondary")
              ) {
                // Portrait orientation
                return "portrait";
              } else {
                // Landscape orientation
                return "landscape";
              }
            } else {
              // Check using window.orientation
              if (window.orientation === 0 || window.orientation === 180) {
                // Portrait orientation
                return "portrait";
              } else {
                // Landscape orientation
                return "landscape";
              }
            }
          }

          // Start the timer
          function recordStartTimer() {
            if (!isTimerRunning) {
              recordStartTime = new Date().getTime(); // Get the current timestamp
              recordTimerInterval = setInterval(recordUpdateTimer, 1000); // Update the timer every second (1000 milliseconds)
              isTimerRunning = true;
              canPauseResume = false; // Disable pause/resume actions initially
              setTimeout(() => {
                canPauseResume = true; // Enable pause/resume actions after 30 seconds of elapsed time
              }, recordChangeSeconds);
            }
          }

          // Pause the timer
          function recordPauseTimer(stop = false) {
            let checker = isTimerRunning && canPauseResume;
            if (stop) {
              checker = canPauseResume;
            }
            if (checker) {
              clearInterval(recordTimerInterval); // Pause the timer
              isTimerRunning = false;
              canPauseResume = false; // Disable pause/resume actions until resumed
              return true;
            } else {
              if (stop) {
                showAlert(
                  "Can only stop after 15 seconds of start/pause/resume of recording",
                  "danger"
                );
              } else {
                showAlert(
                  "Can only pause/resume after 15 seconds of start/pause/resume of recording",
                  "danger"
                );
              }
              return false;
            }
          }

          // Resume the timer
          function recordResumeTimer() {
            if (!isTimerRunning && canPauseResume) {
              recordStartTime = new Date().getTime() - recordElapsedTime * 1000; // Calculate the starting time based on elapsed time
              recordTimerInterval = setInterval(recordUpdateTimer, 1000); // Update the timer every second (1000 milliseconds)
              isTimerRunning = true;
              canPauseResume = false; // Disable pause/resume actions until paused again
              return true;
            } else {
              showAlert(
                "Can only pause/resume after 15 seconds of start/pause/resume of recording",
                "danger"
              );
              return false;
            }
          }

          // Update the timer
          function recordUpdateTimer() {
            const currentTime = new Date().getTime(); // Get the current timestamp
            recordElapsedTime = Math.floor(
              (currentTime - recordStartTime) / 1000
            ); // Calculate the elapsed time in seconds

            // Format the time in HH:MM:SS format
            const hours = Math.floor(recordElapsedTime / 3600);
            const minutes = Math.floor((recordElapsedTime % 3600) / 60);
            const seconds = recordElapsedTime % 60;
            const formattedTime =
              padNumber(hours) +
              ":" +
              padNumber(minutes) +
              ":" +
              padNumber(seconds);

            // Update the content of Rec_progressTimer
            $(".Rec_progressTimer").text(formattedTime);
          }

          // Utility function to pad single-digit numbers with leading zeros
          function padNumber(number) {
            return number.toString().padStart(2, "0");
          }

          // Update the recording state indicator
          function updateRecordingStateIndicator(state, rowElement) {
            let statusIndicator = rowElement.find("#Rec_statusIndicator");
            const indicatorIcon = statusIndicator.find("i");
            const badge = $("#meetingProgressTimer");

            // Remove all previous color classes
            indicatorIcon.removeClass("text-success text-warning text-danger");

            badge.removeClass("bg-danger bg-success bg-warning");

            // Add the appropriate color class based on the state
            if (state == "recording") {
              indicatorIcon.addClass("text-danger");
              badge.addClass("bg-danger");
            } else if (state == "pause") {
              indicatorIcon.addClass("text-warning");
              badge.addClass("bg-warning");
            } else if (state == "stop") {
              indicatorIcon.addClass("text-success");
              badge.addClass("bg-success");
            }
          }
          function SoundPlayer(soundUrl) {
            function playSound(url) {
              const audio = new Audio(url);
              audio
                .play()
                .catch((error) => console.error("Error playing sound:", error));
            }

            if (soundUrl) {
              playSound(soundUrl);
            }
          }

          function updateRecordingStateIndicatorMember(state) {
            const badge = $("#meetingProgressTimer");

            badge.removeClass("bg-danger bg-success bg-warning");

            // Add the appropriate color class based on the state
            if (state == "recording") {
              badge.addClass("bg-danger");
              eventType != "broadcast" &&
                SoundPlayer(
                  "https://www.mediasfu.com/sounds/record-progress.mp3"
                );
            } else if (state == "pause") {
              badge.addClass("bg-warning");
              eventType != "broadcast" &&
                SoundPlayer(
                  "https://www.mediasfu.com/sounds/record-paused.mp3"
                );
            } else if (state == "stop") {
              badge.addClass("bg-success");
              eventType != "broadcast" &&
                SoundPlayer(
                  "https://www.mediasfu.com/sounds/record-stopped.mp3"
                );
            }
          }

          async function addPollsModal() {
            const pollModalBody = document.getElementById("pollModalBody");

            // Function to render polls
            function renderPolls() {
              const previousPolls = document.getElementById("previousPolls");
              const activePoll = document.getElementById("activePoll");

              if (previousPolls) {
                previousPolls.innerHTML = "";
              }
              activePoll.innerHTML = "";

              // Get count of active polls
              let activePollCount = 0;
              let inactivePollCount = 0;
              polls.forEach((polled) => {
                if (
                  polled.status === "active" &&
                  poll != null &&
                  polled.id === poll.id
                ) {
                  activePollCount++;
                } else {
                  inactivePollCount++;
                }
              });

              if (activePollCount < 1 || poll == null) {
                activePoll.innerHTML = "<div>No polls available</div>";
              }

              if (inactivePollCount < 1) {
                if (previousPolls) {
                  previousPolls.innerHTML = "<div>No previous polls</div>";
                }
              }

              if (islevel == "2") {
                // Host view

                polls.forEach((polled, index) => {
                  if (
                    polled.status == "active" &&
                    poll &&
                    poll.id === polled.id &&
                    poll.status == "active"
                  ) {
                    // Active poll
                    activePoll.innerHTML = `<h6>Question:</h6>
                  <textarea class="form-control" id="pollQuestion" rows="3" maxlength="300" required disabled>${polled.question}</textarea>
                  <br/>
              `;
                    activePoll.innerHTML += "<h6>Options:</h6>";
                    polled.options.forEach((option, i) => {
                      activePoll.innerHTML += `<div>${option}</div>`;
                    });
                    activePoll.innerHTML += "<h6>Results:</h6>";
                    polled.options.forEach((option, i) => {
                      const percentage = calculatePercentage(polled.votes, i);
                      activePoll.innerHTML += `<div>${option}: ${polled.votes[i]} votes (${percentage}%)</div>`;
                    });

                    // Voter view
                    activePoll.innerHTML = "";
                    if (poll) {
                      activePoll.innerHTML = `<h6>Question: </h6>
                  <textarea class="form-control" rows="3" disabled>${polled.question}</textarea>
                  <br/>
                  `;
                      activePoll.innerHTML += "<h6>Options:</h6>";
                      polled.options.forEach((option, i) => {
                        const isChecked =
                          polled.voters && polled.voters[member] == i;
                        activePoll.innerHTML += `
                          <div class="form-check">
                              <input class="form-check-input poll-option" type="radio" name="pollOption" value="${i}" data-poll-index="0" id="pollOption${i}" ${
                          isChecked ? "checked" : ""
                        }>
                              <label class="form-check-label" for="pollOption${i}">${option}</label>
                              <br/>
                          </div>`;
                      });
                      if (polled.status === "active") {
                        activePoll.innerHTML += `<button class="btn btn-danger btn-block end-poll-button" data-poll-id="${polled.id}">End Poll</button>`;
                      }
                    } else {
                      activePoll.innerHTML = "<div>No active poll</div>";
                    }
                  } else {
                    // Previous polls
                    let pollHtml = `<h6>Question:</h6>
              <textarea class="form-control" rows="3" disabled>${polled.question}</textarea>
              `;
                    pollHtml += "<h6>Options:</h6>";
                    polled.options.forEach((option, i) => {
                      pollHtml += `<div>${option}</div>`;
                    });
                    pollHtml += "<h6>Results:</h6>";
                    polled.options.forEach((option, i) => {
                      const percentage = calculatePercentage(polled.votes, i);
                      pollHtml += `<div>${option}: ${polled.votes[i]} votes (${percentage}%)</div>`;
                    });

                    if (polled.status === "active") {
                      pollHtml += `
                  <br/>
                  <button class="btn btn-danger btn-block end-poll-button" data-poll-id="${polled.id}">End Poll</button>`;
                    }
                    previousPolls.innerHTML += `<div class="previous-poll">${pollHtml}</div>`;
                  }
                });
              } else {
                // Voter view
                activePoll.innerHTML = "";
                if (poll) {
                  activePoll.innerHTML = `<h6>Question: </h6>
          <textarea class="form-control" rows="3" disabled>${poll.question}</textarea>
          <br/>
          `;
                  activePoll.innerHTML += "<h6>Options:</h6>";
                  poll.options.forEach((option, i) => {
                    const isChecked = poll.voters && poll.voters[member] == i;
                    activePoll.innerHTML += `
                  <div class="form-check">
                    <input class="form-check-input poll-option" type="radio" name="pollOption" value="${i}" data-poll-index="0" id="pollOption${i}" ${
                      isChecked ? "checked" : ""
                    }>
                    <label class="form-check-label" for="pollOption${i}">${option}</label>
                  </div>`;
                  });
                } else {
                  activePoll.innerHTML = "<div>No active poll</div>";
                }
              }
            }

            // Function to calculate vote percentage
            function calculatePercentage(votes, optionIndex) {
              const totalVotes = votes.reduce((a, b) => a + b, 0);
              return totalVotes > 0
                ? ((votes[optionIndex] / totalVotes) * 100).toFixed(2)
                : 0;
            }

            // Event listener for ending polls
            document.addEventListener("click", async function (event) {
              if (event.target.classList.contains("end-poll-button")) {
                const pollId = event.target.getAttribute("data-poll-id");
                await socket.emit("endPoll", {
                  roomName: roomName,
                  poll_id: pollId,
                });
              }
            });

            // Function to handle voting
            document.addEventListener("click", async function (event) {
              if (event.target.classList.contains("poll-option")) {
                if (event.target.classList.contains("poll-option")) {
                  const pollIndex =
                    event.target.getAttribute("data-poll-index");
                  const optionIndex = event.target.value;
                  const poll = polls[pollIndex];

                  // Emit votePoll event
                  await socket.emit(
                    "votePoll",
                    {
                      roomName: roomName,
                      poll_id: poll.id,
                      member: member,
                      choice: optionIndex,
                    },
                    (response) => {
                      if (response.success) {
                        showAlert("Vote submitted successfully", "success");
                      } else {
                        showAlert(response.message, "danger");
                      }
                    }
                  );
                }
              }
            });

            // Function to add host or voter view to the modal body
            function addView() {
              if (islevel == "2") {
                const hostView = `
  <div id="hostView">
    <h5>Previous Polls</h5>
    <div id="previousPolls"></div>
    <hr/>
    <h5>Create a New Poll</h5>
    <form id="pollForm">
      <div class="form-group">
        <label for="pollQuestion">Poll Question</label>
        <textarea class="form-control" id="pollQuestion" rows="3" maxlength="300" required></textarea>
      </div>
      <div class="form-group">
        <label for="pollType">Select Poll Answer Type</label>
        <select class="form-control" id="pollType" required>
          <option value="">Choose...</option>
          <option value="trueFalse">True/False</option>
          <option value="yesNo">Yes/No</option>
          <option value="custom">Custom</option>
        </select>
      </div>
      <div id="pollOptions" class="form-group"></div>
      <button type="submit" class="btn btn-primary btn-block">Create Poll</button>
    </form>
  </div>
  <hr/>
  <div id="voterView">
    <h5>Current Poll</h5>
    <div id="activePoll"></div>
  </div>`;
                pollModalBody.innerHTML = hostView;
              } else {
                const voterView = `
  <div id="voterView">
    <h5>Current Poll</h5>
    <div id="activePoll"></div>
  </div>`;
                pollModalBody.innerHTML = voterView;
              }
            }
            addView();

            if (islevel == "2") {
              const pollForm = document.getElementById("pollForm");
              const pollType = document.getElementById("pollType");
              const pollOptions = document.getElementById("pollOptions");
              let previousPolls = document.getElementById("previousPolls");
              let activePoll = document.getElementById("activePoll");

              pollType.addEventListener("change", function () {
                const type = this.value;
                pollOptions.innerHTML = ""; // Clear previous options
                if (type === "trueFalse") {
                  pollOptions.innerHTML = `
    <div class="form-check">
      <input class="form-check-input" type="radio" name="pollOption" value="true" id="optionTrue">
      <label class="form-check-label" for="optionTrue">True</label>
    </div>
    <div class="form-check">
      <input class="form-check-input" type="radio" name="pollOption" value="false" id="optionFalse">
      <label class="form-check-label" for="optionFalse">False</label>
    </div>`;
                } else if (type === "yesNo") {
                  pollOptions.innerHTML = `
    <div class="form-check">
      <input class="form-check-input" type="radio" name="pollOption" value="yes" id="optionYes">
      <label class="form-check-label" for="optionYes">Yes</label>
    </div>
    <div class="form-check">
      <input class="form-check-input" type="radio" name="pollOption" value="no" id="optionNo">
      <label class="form-check-label" for="optionNo">No</label>
    </div>`;
                } else if (type === "custom") {
                  for (let i = 1; i <= 5; i++) {
                    pollOptions.innerHTML += `
              <div class="form-group">
              <input type="text" class="form-control" id="customOption${i}" placeholder="Option ${i}" maxlength="50">
              </div>`;
                  }
                }
              });

              pollForm.addEventListener("submit", function (event) {
                event.preventDefault();
                const question = document.getElementById("pollQuestion").value;
                const type = pollType.value;
                let options = [];
                if (type === "trueFalse") {
                  options = ["True", "False"];
                } else if (type === "yesNo") {
                  options = ["Yes", "No"];
                } else if (type === "custom") {
                  for (let i = 1; i <= 5; i++) {
                    const option = document.getElementById(
                      `customOption${i}`
                    ).value;
                    if (option) {
                      options.push(option);
                    }
                  }
                }

                const poll = {
                  question,
                  type,
                  options,
                  votes: Array(options.length).fill(0),
                };
                // Emit createPoll event
                socket.emit(
                  "createPoll",
                  { roomName: roomName, poll: poll },
                  (response) => {
                    if (response.success) {
                      showAlert("Poll created successfully", "success");
                    } else {
                      showAlert(response.reason, "danger");
                    }
                  }
                );

                renderPolls();
                $("#pollModal").modal("hide");
              });
            }

            // Handle incoming updates to poll and poll results
            socket.on("pollUpdated", (data) => {
              // data = { poll, polls, status }
              // status = 'started', 'ended', 'voted'
              // polls array only sent to the host

              if (data.polls) {
                polls = data.polls;
              } else {
                polls = [data.poll];
              }

              let temp_poll = { id: "" };

              if (poll) {
                temp_poll = { ...poll };
              }

              if (data.status != "ended") {
                poll = data.poll;
              }

              renderPolls();

              if (data.status == "started" && islevel != "2") {
                //check if voters exist and user has not voted
                if (!poll.voters || (poll.voters && !poll.voters[member])) {
                  $("#pollModal").modal("show");
                  showAlert("New poll started", "success");
                }
              } else if (data.status === "ended") {
                if (temp_poll.id === data.poll.id) {
                  showAlert("Poll ended", "danger");
                  poll = data.poll;
                }
              }
            });

            renderPolls(); // Initial rendering
          }

          $("#pollModal").on("show.bs.modal", async function () {
            // Show the poll modal
            await addPollsModal();
          });

          addPollsModal();

          // background removal logic
          let customImage = null;
          let selectedImage = null;
          let segmentVideo = null;
          let selfieSegmentation = null;
          let pauseSegmentation = false;
          let processedStream = null;
          let keepBackground = false;
          let backgroundHasChanged = false;
          let virtualStream = null;
          let mainCanvas = null;
          let prevKeepBackground = false;
          let appliedBackground = false;

          async function addBackgroundModal() {
            // Example default images
            const defaultImages = [
              "wall",
              "wall2",
              "shelf",
              "clock",
              "desert",
              "flower",
            ];

            backgroundHasChanged = false;
            let clonedTrack = null;
            let clonedStream = null;

            const defaultImagesContainer =
              document.getElementById("defaultImages");
            const uploadImageInput = document.getElementById("uploadImage");
            const uploadedImagePreview = document.getElementById(
              "uploadedImagePreview"
            );
            const backgroundCanvas =
              document.getElementById("backgroundCanvas");
            const applyBackgroundButton = document.getElementById(
              "applyBackgroundButton"
            );
            const saveBackgroundButton = document.getElementById(
              "saveBackgroundButton"
            );
            const videoPreview = document.getElementById("previewVideo");

            // Load default images
            defaultImages.forEach((baseName) => {
              const thumb = `/images/backgrounds/${baseName}_thumbnail.jpg`;
              const small = `/images/backgrounds/${baseName}_small.jpg`;
              const large = `/images/backgrounds/${baseName}_large.jpg`;
              const full = `/images/backgrounds/${baseName}.jpg`;
              const img = document.createElement("img");
              img.src = thumb;
              img.classList.add("img-thumbnail", "m-1");
              img.style.width = "80px";
              img.style.cursor = "pointer";
              img.addEventListener("click", () => {
                if (targetResolution == "fhd" || targetResolution == "qhd") {
                  loadImageToCanvas(small, large);
                } else {
                  loadImageToCanvas(small, full);
                }
              });
              defaultImagesContainer.appendChild(img);
            });

            const loadingOverlay = document.getElementById("loadingOverlay");

            // Show loading indicator
            function showLoading() {
              loadingOverlay.classList.remove("d-none");
            }

            // Hide loading indicator
            function hideLoading() {
              loadingOverlay.classList.add("d-none");
            }

            async function preloadModel() {
              selfieSegmentation = new SelfieSegmentation({
                locateFile: (file) =>
                  `https://cdn.jsdelivr.net/npm/@mediapipe/selfie_segmentation/${file}`,
              });

              selfieSegmentation.setOptions({
                modelSelection: 1,
                selfieMode: false,
              });

              await selfieSegmentation.initialize();
            }

            // Initialize the model when the application starts
            preloadModel().catch((err) =>
              console.log("Error preloading model:", err)
            );

            // Clear canvas and write "No Background" text
            function clearCanvas() {
              const ctx = backgroundCanvas.getContext("2d");
              ctx.clearRect(
                0,
                0,
                backgroundCanvas.width,
                backgroundCanvas.height
              );
              ctx.font = "30px Arial";
              ctx.fillStyle = "#000";
              ctx.textAlign = "center";
              ctx.textBaseline = "middle";
              ctx.fillText(
                "No Background",
                backgroundCanvas.width / 2,
                backgroundCanvas.height / 2
              );

              saveBackgroundButton.classList.add("d-none");
              applyBackgroundButton.classList.remove("d-none");
              applyBackgroundButton.disabled = false;
              if (
                processedStream &&
                prevKeepBackground == keepBackground &&
                keepBackground &&
                appliedBackground
              ) {
                applyBackgroundButton.innerText = "Apply Background";
              } else {
                applyBackgroundButton.innerText = "Preview Background";
              }
            }

            // Add "No Background" option
            const noBackgroundImg = document.createElement("div");
            noBackgroundImg.classList.add(
              "img-thumbnail",
              "m-1",
              "d-flex",
              "align-items-center",
              "justify-content-center"
            );
            noBackgroundImg.style.width = "76px";
            noBackgroundImg.style.minHeight = "60px";
            noBackgroundImg.style.cursor = "pointer";
            noBackgroundImg.style.backgroundColor = "#f8f9fa";
            noBackgroundImg.style.border = "1px solid #dee2e6";
            noBackgroundImg.style.position = "relative";
            noBackgroundImg.innerHTML =
              '<span style="position:absolute; top:50%; left:50%; transform:translate(-50%, -50%); color:#000;">None</span>';
            noBackgroundImg.addEventListener("click", () => {
              selectedImage = null;
              customImage = null;

              showLoading(); // Show loading indicator
              videoPreview.classList.add("d-none");
              backgroundCanvas.classList.remove("d-none");
              clearCanvas();
              hideLoading(); // Hide loading indicator after loading
            });
            defaultImagesContainer.appendChild(noBackgroundImg);

            // Load custom image if it exists
            if (customImage) {
              const img = document.createElement("img");
              img.src = customImage;
              img.classList.add("img-thumbnail", "m-1");
              img.style.width = "80px";
              img.style.cursor = "pointer";
              img.addEventListener("click", () => {
                loadImageToCanvas(customImage, customImage);
              });
              defaultImagesContainer.appendChild(img);
            }

            // Handle image upload
            uploadImageInput.addEventListener("change", (event) => {
              try {
                const file = event.target.files[0];
                if (file) {
                  // Validate file size
                  if (file.size > 2048 * 2048) {
                    // 2MB
                    showAlert("File size must be less than 2MB.", "danger");
                    return;
                  }

                  let minWidth = 1280;
                  let minHeight = 1280;
                  let maxWidth = 2560;
                  let maxHeight = 2560;

                  if (targetResolution == "fhd") {
                    minWidth = 1920;
                    minHeight = 1920;
                  } else if (targetResolution == "qhd") {
                    minWidth = 2560;
                    minHeight = 2560;
                  } // For other resolutions, stick to the default 1280x1280

                  const img = new Image();
                  img.onload = () => {
                    // Validate image dimensions
                    // Check if the image dimensions meet the minimum requirements
                    if (
                      img.width < minWidth ||
                      img.height < minHeight ||
                      img.width > maxWidth ||
                      img.height > maxHeight
                    ) {
                      showAlert(
                        `Image dimensions must be at least ${minWidth}x${minHeight}.`,
                        "danger"
                      );
                      return;
                    }
                    // Load valid image to canvas and set as custom image
                    customImage = img.src;
                    loadImageToCanvas(img.src, img.src);
                  };

                  const reader = new FileReader();
                  reader.onload = (e) => {
                    img.src = e.target.result;
                  };
                  reader.readAsDataURL(file);
                }
              } catch (error) {
                // console.log('error Upload:', error);
              }
            });

            // Load image to canvas
            function loadImageToCanvas(src, fullSrc) {
              showLoading(); // Show loading indicator
              //remove the d-none class from the backgroundCanvas and apply it to the videoPreview
              backgroundCanvas.classList.remove("d-none");
              videoPreview.classList.add("d-none");

              const img = new Image();
              img.onload = () => {
                const ctx = backgroundCanvas.getContext("2d");
                backgroundCanvas.width = img.width;
                backgroundCanvas.height = img.height;
                ctx.drawImage(img, 0, 0);
                // Perform background removal
                removeBackground(img);
                hideLoading(); // Hide loading indicator after loading
              };
              img.src = src;
              selectedImage = fullSrc;

              saveBackgroundButton.classList.add("d-none");
              saveBackgroundButton.disabled = true;
              applyBackgroundButton.classList.remove("d-none");
              applyBackgroundButton.disabled = false;

              if (
                processedStream &&
                prevKeepBackground == keepBackground &&
                keepBackground &&
                appliedBackground
              ) {
                applyBackgroundButton.innerText = "Apply Background";
              } else {
                applyBackgroundButton.innerText = "Preview Background";
              }
            }

            // Background removal logic
            function removeBackground(img) {
              const ctx = backgroundCanvas.getContext("2d");
              //Just add the image to the canvas for now
              ctx.clearRect(
                0,
                0,
                backgroundCanvas.width,
                backgroundCanvas.height
              );
              ctx.drawImage(img, 0, 0);
            }

            // Placeholder function for background removal
            function performBackgroundRemoval(img) {
              return new Promise((resolve) => {
                const maskedImg = img; // Replace this with actual processed image
                resolve(maskedImg);
              });
            }

            async function segmentationPreview(videoRefID, doSegmentation) {
              if (!mainCanvas) {
                mainCanvas = new OffscreenCanvas(
                  vidCons.width.ideal,
                  vidCons.height.ideal
                );
              }

              const refVideo = document.querySelector(videoRefID);
              const virtualImage = new Image();
              virtualImage.src = selectedImage;
              const mediaCanvas = mainCanvas;
              const ctx = mediaCanvas.getContext("2d");

              backgroundHasChanged = true;
              prevKeepBackground = keepBackground;
              if (!doSegmentation) {
                // Just show the video
                processedStream = null;
                keepBackground = false;
              }

              if (videoAlreadyOn) {
                //pass the video element to the segmentation function
                if (
                  clonedTrack &&
                  clonedTrack.readyState === "live" &&
                  localStreamVideo.getVideoTracks()[0].label ===
                    clonedTrack.label
                ) {
                } else {
                  const localTracks = localStreamVideo.getVideoTracks()[0];
                  clonedTrack = localTracks.clone();
                  clonedStream = new MediaStream([clonedTrack]);
                  segmentVideo = clonedStream;
                }
                try {
                  doSegmentation
                    ? segmentImage(segmentVideo.getVideoTracks()[0])
                    : (refVideo.srcObject = clonedStream
                        ? clonedStream
                        : localStreamVideo);
                } catch (error) {}
              } else {
                // get video if not already on the page
                await navigator.mediaDevices
                  .getUserMedia({
                    video: { ...vidCons, frameRate: { ideal: frameRate } },
                    audio: false,
                  })
                  .then((stream) => {
                    segmentVideo = stream;
                    try {
                      doSegmentation
                        ? segmentImage(segmentVideo.getVideoTracks()[0])
                        : (refVideo.srcObject = segmentVideo);
                    } catch (error) {}
                  })
                  .catch(async (err) => {
                    await navigator.mediaDevices
                      .getUserMedia({
                        video: { ...vidCons },
                        audio: false,
                      })
                      .then((stream) => {
                        segmentVideo = stream;
                        try {
                          doSegmentation
                            ? segmentImage(segmentVideo.getVideoTracks()[0])
                            : (refVideo.srcObject = segmentVideo);
                        } catch (error) {}
                      })
                      .catch((err) => {
                        showAlert(
                          "Camera not accessible, might need to turn off your video and turn it back on after switching.",
                          "danger"
                        );
                      });
                  });
              }

              async function segmentImage(videoTrack) {
                if (!selfieSegmentation) {
                  await preloadModel(); // Ensure the model is preloaded
                }

                selfieSegmentation.onResults(onResults);

                const trackProcessor = new MediaStreamTrackProcessor({
                  track: videoTrack,
                });
                const trackGenerator = new MediaStreamTrackGenerator({
                  kind: "video",
                });

                const transformer = new TransformStream({
                  async transform(videoFrame, controller) {
                    if (selfieSegmentation && !pauseSegmentation) {
                      videoFrame.width = videoFrame.displayWidth;
                      videoFrame.height = videoFrame.displayHeight;
                      await selfieSegmentation.send({ image: videoFrame });

                      const timestamp = videoFrame.timestamp;
                      const newFrame = new VideoFrame(mediaCanvas, {
                        timestamp,
                      });

                      videoFrame.close();
                      controller.enqueue(newFrame);
                    }
                  },
                });

                trackProcessor.readable
                  .pipeThrough(transformer)
                  .pipeTo(trackGenerator.writable)
                  .catch(() => {});

                processedStream = new MediaStream();
                processedStream.addTrack(trackGenerator);
                refVideo.srcObject = processedStream;
                keepBackground = true;
              }

              let repeatPattern = "no-repeat";
              try {
                if (
                  virtualImage.width < mediaCanvas.width ||
                  virtualImage.height < mediaCanvas.height
                ) {
                  repeatPattern = "repeat";
                }
              } catch (error) {}

              function onResults(results) {
                ctx.save();
                ctx.clearRect(0, 0, mediaCanvas.width, mediaCanvas.height);
                ctx.drawImage(
                  results.segmentationMask,
                  0,
                  0,
                  mediaCanvas.width,
                  mediaCanvas.height
                );

                ctx.globalCompositeOperation = "source-out";
                const pat = ctx.createPattern(virtualImage, repeatPattern);
                ctx.fillStyle = pat;
                ctx.fillRect(0, 0, mediaCanvas.width, mediaCanvas.height);

                // Only overwrite missing pixels.
                ctx.globalCompositeOperation = "destination-atop";
                ctx.drawImage(
                  results.image,
                  0,
                  0,
                  mediaCanvas.width,
                  mediaCanvas.height
                );

                ctx.restore();
              }
            }

            async function stopSegmentation() {
              if (selfieSegmentation) {
                await selfieSegmentation.close();
                selfieSegmentation = null;
              }
            }

            // Apply background button handler
            applyBackgroundButton.addEventListener("click", async () => {
              // Apply the background and preview it

              if (audioOnlyRoom) {
                showAlert(
                  "You cannot turn on your camera in an audio only event.",
                  "danger"
                );
                return;
              }

              showLoading(); // Show loading indicator

              videoPreview.classList.remove("d-none");
              backgroundCanvas.classList.add("d-none");

              const doSegmentation = selectedImage ? true : false;
              pauseSegmentation = false;
              await segmentationPreview("#previewVideo", doSegmentation);
              hideLoading(); // Hide loading indicator after background applied

              applyBackgroundButton.classList.add("d-none");
              applyBackgroundButton.disabled = true;

              if (
                processedStream &&
                prevKeepBackground == keepBackground &&
                keepBackground &&
                appliedBackground
              ) {
                saveBackgroundButton.classList.add("d-none");
                saveBackgroundButton.disabled = true;
              } else {
                saveBackgroundButton.classList.remove("d-none");
                saveBackgroundButton.disabled = false;
              }
            });

            // Save background button handler
            saveBackgroundButton.addEventListener("click", async () => {
              // Save the selected changes and hide the modal

              if (audioOnlyRoom) {
                showAlert(
                  "You cannot use a background in an audio only event.",
                  "danger"
                );
                return;
              } else if (backgroundHasChanged) {
                if (videoAlreadyOn) {
                  // Replace the video stream with the processed stream
                  if (islevel == "2" && (recordStarted || recordResumed)) {
                    if (!(recordPaused || recordStopped)) {
                      if (recordingMediaOptions == "video") {
                        showAlert(
                          "Please pause the recording before changing the background.",
                          "danger"
                        );
                        return;
                      }
                    }
                  }

                  if (keepBackground && selectedImage && processedStream) {
                    const refVideo = document.querySelector("#previewVideo");
                    virtualStream = await processedStream;
                    videoParams = await {
                      ...videoParams,
                      track: virtualStream.getVideoTracks()[0],
                    };
                  } else {
                    if (
                      localStreamVideo &&
                      localStreamVideo.getVideoTracks()[0] &&
                      localStreamVideo.getVideoTracks()[0].readyState === "live"
                    ) {
                      videoParams = await {
                        ...videoParams,
                        track: localStreamVideo.getVideoTracks()[0],
                      };
                    } else {
                      try {
                        if (
                          localStreamVideo &&
                          localStreamVideo.getVideoTracks()[0] &&
                          localStreamVideo.getVideoTracks()[0].readyState !==
                            "live"
                        ) {
                          //replace the track with the cloned track
                          localStreamVideo.removeTrack(
                            localStreamVideo.getVideoTracks()[0]
                          );
                          localStreamVideo.addTrack(
                            clonedStream.getVideoTracks()[0].clone()
                          );
                        }
                      } catch (error) {}

                      videoParams = await {
                        ...videoParams,
                        track: clonedStream.getVideoTracks()[0].clone(),
                      };
                    }
                  }

                  if (!transportCreated) {
                    await createSendTransport("video");
                    if (p_sockets.length > 0) {
                      try {
                        await createSendTransportMediaSFU("video");
                      } catch (error) {}
                    }
                  } else {
                    try {
                      if (videoProducer && videoProducer.id) {
                        if (videoProducer.track.id != videoParams.track.id) {
                          await disconnectSendTransportVideo();
                          await sleep(500);

                          if (p_sockets.length > 0) {
                            try {
                              await disconnectSendTransportVideo(true);
                              await sleep(500);
                            } catch (error) {}
                          }
                        }
                      }
                      await connectSendTransportVideo(videoParams);
                      if (p_sockets.length > 0) {
                        try {
                          await connectSendTransportVideo(videoParams, true);
                        } catch (error) {}
                      }
                    } catch (error) {}
                  }
                  await onScreenChanges(true);
                }
              }

              if (keepBackground) {
                appliedBackground = true;
              } else {
                appliedBackground = false;
              }

              saveBackgroundButton.classList.add("d-none");
              saveBackgroundButton.disabled = true;
            });

            $("#changeBackground").on("click", function () {
              $("#backgroundRemovalModal").modal("show");
              // Load the selected image to canvas or clear it if none is selected
              videoPreview.classList.add("d-none");
              backgroundCanvas.classList.remove("d-none");
              if (selectedImage) {
                loadImageToCanvas(selectedImage, selectedImage);
              } else {
                clearCanvas();
              }
              saveBackgroundButton.classList.add("d-none");
              saveBackgroundButton.disabled = true;
              applyBackgroundButton.classList.remove("d-none");
              applyBackgroundButton.disabled = false;

              if (
                processedStream &&
                prevKeepBackground == keepBackground &&
                keepBackground &&
                appliedBackground
              ) {
                applyBackgroundButton.innerText = "Apply Background";
              } else {
                applyBackgroundButton.innerText = "Preview Background";
              }
            });

            $("#backgroundRemovalModal").on("hide.bs.modal", async function () {
              // Hide the background removal modal
              // stop the video stream
              try {
                if (
                  !appliedBackground ||
                  (appliedBackground && !keepBackground) ||
                  (appliedBackground && !videoAlreadyOn)
                ) {
                  const refVideo = document.querySelector("#previewVideo");
                  pauseSegmentation = true; //await stopSegmentation();
                  if (!videoAlreadyOn) {
                    try {
                      refVideo
                        ? await refVideo.srcObject
                            .getTracks()
                            .forEach((track) => track.stop())
                        : null;
                      segmentVideo
                        ? await segmentVideo
                            .getTracks()
                            .forEach((track) => track.stop())
                        : null;
                      virtualStream
                        ? await virtualStream
                            .getTracks()
                            .forEach((track) => track.stop())
                        : null;
                      //remove the video element
                      refVideo.srcObject = null;
                      segmentVideo = null;
                      virtualStream = null;
                    } catch (error) {}
                  } else {
                  }
                }
                //apply the d-none class to both
                videoPreview.classList.add("d-none");
                backgroundCanvas.classList.add("d-none");
              } catch (error) {
                // console.log(error, 'Error stopping the video stream');
              }
            });
          }

          addBackgroundModal();

          // break out rooms logic
          let breakoutRooms = [];
          let currentRoomIndex = null;
          let canStartBreakout = false;
          let breakOutRoomStarted = false;
          let breakOutRoomEnded = false;
          let hostNewRoom = -1;
          let limitedBreakRoom = [];

          async function addBreakoutRoomsModal() {
            let breakoutRoomsCopy = [];
            let participantsCopy = [];
            $("#breakoutRoomsModal").on("show.bs.modal", function () {
              breakoutRoomsCopy = [...breakoutRooms];
              participantsCopy = [...participants];
              //filter out the host
              participantsCopy = participantsCopy.filter(
                (participant) => participant.islevel != "2"
              );
              renderRooms();
              document.getElementById("numRooms").value = "";
              checkCanStartBreakout();
            });

            document
              .getElementById("randomAssign")
              .addEventListener("click", () => {
                const numRooms = parseInt(
                  document.getElementById("numRooms").value
                );
                if (!numRooms || numRooms <= 0) {
                  showAlert("Please enter a valid number of rooms", "danger");
                  return;
                }

                breakoutRoomsCopy = Array.from({ length: numRooms }, () => []);
                const shuffledParticipants = [...participantsCopy].sort(
                  () => 0.5 - Math.random()
                );

                shuffledParticipants.forEach((participant, index) => {
                  const roomIndex = index % numRooms;
                  if (breakoutRoomsCopy[roomIndex].length < itemPageLimit) {
                    breakoutRoomsCopy[roomIndex].push(participant);
                    participant.breakRoom = roomIndex;
                  } else {
                    for (let i = 0; i < numRooms; i++) {
                      if (breakoutRoomsCopy[i].length < itemPageLimit) {
                        breakoutRoomsCopy[i].push(participant);
                        participant.breakRoom = i;
                        break;
                      }
                    }
                  }
                });

                renderRooms();
                checkCanStartBreakout();
              });

            document
              .getElementById("manualAssign")
              .addEventListener("click", () => {
                const numRooms = parseInt(
                  document.getElementById("numRooms").value
                );
                if (!numRooms || numRooms <= 0) {
                  showAlert("Please enter a valid number of rooms", "danger");
                  return;
                }

                breakoutRoomsCopy = Array.from({ length: numRooms }, () => []);
                renderRooms();
                canStartBreakout = false;
                checkCanStartBreakout();
              });

            document.getElementById("addRoom").addEventListener("click", () => {
              breakoutRoomsCopy.push([]);
              renderRooms();
              canStartBreakout = false;
              checkCanStartBreakout();
            });

            document
              .getElementById("saveRooms")
              .addEventListener("click", () => {
                if (validateRooms()) {
                  canStartBreakout = true;
                  checkCanStartBreakout();
                  showAlert("Rooms saved successfully", "success");
                } else {
                  // showAlert('Rooms validation failed', 'danger');
                }
              });

            function renderRooms() {
              const roomsContainer = document.getElementById("roomsContainer");
              roomsContainer.innerHTML = "";

              breakoutRoomsCopy.forEach((room, roomIndex) => {
                const roomDiv = document.createElement("div");
                roomDiv.classList.add("card", "mb-3", "text-dark");
                roomDiv.innerHTML = `
                <div class="card-header d-flex justify-content-between align-items-center">
                    Room ${roomIndex + 1}
                    <div>
                        <button class="btn btn-secondary btn-sm" onclick="editRoom(${roomIndex})">
                            <i class="fas fa-pen"></i>
                        </button>
                        <button class="btn btn-danger btn-sm" onclick="deleteRoom(${roomIndex})">
                            <i class="fas fa-times"></i>
                        </button>
                    </div>
                </div>
                <div class="card-body">
                    <ul class="list-group" id="room${roomIndex}List"></ul>
                </div>
            `;

                roomsContainer.appendChild(roomDiv);

                const roomList = document.getElementById(
                  `room${roomIndex}List`
                );
                room.forEach((participant) => {
                  const listItem = document.createElement("li");
                  listItem.classList.add(
                    "list-group-item",
                    "d-flex",
                    "justify-content-between",
                    "align-items-center",
                    "text-dark"
                  );
                  listItem.innerText = participant.name;
                  const removeButton = document.createElement("button");
                  removeButton.classList.add("btn", "btn-danger", "btn-sm");
                  removeButton.innerHTML = '<i class="fas fa-times"></i>';
                  removeButton.addEventListener("click", () =>
                    removeParticipantFromRoom(roomIndex, participant)
                  );
                  listItem.appendChild(removeButton);
                  roomList.appendChild(listItem);
                });
              });
            }

            window.editRoom = function (roomIndex) {
              currentRoomIndex = roomIndex;
              const roomEditList = document.getElementById("roomEditList");
              const unassignedList = document.getElementById("unassignedList");
              roomEditList.innerHTML = "";
              unassignedList.innerHTML = "";

              const room = breakoutRoomsCopy[roomIndex];
              room.forEach((participant) => {
                const listItem = document.createElement("li");
                listItem.classList.add(
                  "list-group-item",
                  "d-flex",
                  "justify-content-between",
                  "align-items-center",
                  "text-dark"
                );
                listItem.innerText = participant.name;
                const removeButton = document.createElement("button");
                removeButton.classList.add("btn", "btn-danger", "btn-sm");
                removeButton.innerHTML = '<i class="fas fa-times"></i>';
                removeButton.addEventListener("click", () =>
                  removeParticipantFromRoom(roomIndex, participant)
                );
                listItem.appendChild(removeButton);
                roomEditList.appendChild(listItem);
              });

              const unassignedParticipants = participantsCopy.filter(
                (participant) => participant.breakRoom === null
              );
              unassignedParticipants.forEach((participant) => {
                const listItem = document.createElement("li");
                listItem.classList.add(
                  "list-group-item",
                  "d-flex",
                  "justify-content-between",
                  "align-items-center",
                  "text-dark"
                );
                listItem.innerText = participant.name;
                const addButton = document.createElement("button");
                addButton.classList.add("btn", "btn-primary", "btn-sm");
                addButton.innerHTML = '<i class="fas fa-plus"></i>';
                addButton.addEventListener("click", () =>
                  addParticipantToRoom(roomIndex, participant)
                );
                listItem.appendChild(addButton);
                unassignedList.appendChild(listItem);
              });

              $("#editRoomModal").modal("show");
              canStartBreakout = false;
              checkCanStartBreakout();
            };

            window.deleteRoom = function (roomIndex) {
              if (breakoutRoomsCopy.length > 0) {
                const room = breakoutRoomsCopy[roomIndex];
                room.forEach((participant) => (participant.breakRoom = null));
                breakoutRoomsCopy.splice(roomIndex, 1);

                //reassign the breakRoom property of the participants
                breakoutRoomsCopy.forEach((room, index) => {
                  room.forEach(
                    (participant) => (participant.breakRoom = index)
                  );
                });

                renderRooms();
                canStartBreakout = false;
                checkCanStartBreakout();
              }
            };

            function addParticipantToRoom(roomIndex, participant) {
              if (breakoutRoomsCopy[roomIndex].length < itemPageLimit) {
                breakoutRoomsCopy[roomIndex].push(participant);
                participant.breakRoom = roomIndex;
                renderRooms();
                if (currentRoomIndex !== null) {
                  editRoom(currentRoomIndex);
                }
              } else {
                showAlert("Room is full", "danger");
              }
            }

            function removeParticipantFromRoom(roomIndex, participant) {
              breakoutRoomsCopy[roomIndex] = breakoutRoomsCopy[
                roomIndex
              ].filter((p) => p !== participant);
              participant.breakRoom = null;
              renderRooms();
              if (currentRoomIndex !== null) {
                editRoom(currentRoomIndex);
              }
            }

            function validateRooms() {
              if (breakoutRoomsCopy.length === 0) {
                showAlert("There must be at least one room", "danger");
                return false;
              }

              for (let room of breakoutRoomsCopy) {
                if (room.length === 0) {
                  showAlert("Rooms must not be empty", "danger");
                  return false;
                }

                const participantNames = room.map((p) => p.name);
                const uniqueNames = new Set(participantNames);
                if (participantNames.length !== uniqueNames.size) {
                  showAlert("Duplicate participant names in a room", "danger");
                  return false;
                }

                if (room.length > itemPageLimit) {
                  showAlert("A room exceeds the participant limit", "danger");
                  return false;
                }
              }

              return true;
            }

            function checkCanStartBreakout() {
              const startBreakoutButton =
                document.getElementById("startBreakoutRooms");
              if (canStartBreakout) {
                startBreakoutButton.style.display = "block";
                startBreakoutButton.disabled = false;
                breakOutRoomStarted && !breakOutRoomEnded
                  ? (startBreakoutButton.innerHTML =
                      'Update Breakout <i class="fas fa-sync-alt"></i>')
                  : (startBreakoutButton.innerHTML =
                      'Start Breakout <i class="fas fa-play"></i>');
              } else {
                startBreakoutButton.style.display = "none";
                startBreakoutButton.disabled = true;
              }
              const stopBreakoutButton =
                document.getElementById("stopBreakoutRooms");
              if (breakOutRoomStarted && !breakOutRoomEnded) {
                stopBreakoutButton.style.display = "block";
                stopBreakoutButton.disabled = false;
              } else {
                stopBreakoutButton.style.display = "none";
                stopBreakoutButton.disabled = true;
              }
            }

            document
              .getElementById("startBreakoutRooms")
              .addEventListener("click", () => {
                //can't start if screen sharing is on
                if (shareScreenStarted || shared) {
                  // if (eventType == 'conference') {
                  showAlert(
                    "You cannot start breakout rooms while screen sharing is active",
                    "danger"
                  );
                  return;
                  // }
                }

                if (canStartBreakout) {
                  const emitName =
                    breakOutRoomStarted && !breakOutRoomEnded
                      ? "updateBreakout"
                      : "startBreakout";
                  const newParticipantAction = document.getElementById(
                    "newParticipantAction"
                  ).value;
                  //retain only name and breakRoom from breakoutRooms
                  const filteredBreakoutRooms = breakoutRoomsCopy.map((room) =>
                    room.map(({ name, breakRoom }) => ({ name, breakRoom }))
                  );
                  socket.emit(
                    emitName,
                    {
                      breakoutRooms: filteredBreakoutRooms,
                      newParticipantAction,
                      roomName,
                    },
                    async (response) => {
                      if (response.success) {
                        document.getElementById(
                          "stopBreakoutRooms"
                        ).style.display = "block";
                        showAlert("Breakout rooms active", "success");
                        breakOutRoomStarted = true;
                        breakOutRoomEnded = false;

                        document.getElementById(
                          "startBreakoutRooms"
                        ).innerText = "Update Breakout";
                        document.getElementById(
                          "startBreakoutRooms"
                        ).disabled = true;
                        document.getElementById(
                          "startBreakoutRooms"
                        ).style.display = "none";
                        $("#breakoutRoomsModal").modal("hide");
                        $("#editRoomModal").modal("hide");

                        if (p_sockets.length > 0) {
                          try {
                            p_sockets[0].emit(
                              emitName,
                              {
                                breakoutRooms: filteredBreakoutRooms,
                                newParticipantAction,
                                roomName,
                              },
                              async (response) => {
                                if (response.success) {
                                }
                              }
                            );
                          } catch (error) {}
                        }

                        if (meetingDisplayType != "all") {
                          prevMeetingDisplayType = meetingDisplayType;
                          meetingDisplayType = "all";
                        }
                      } else {
                        showAlert(response.reason, "danger");
                      }
                    }
                  );
                }
              });

            document
              .getElementById("stopBreakoutRooms")
              .addEventListener("click", () => {
                socket.emit("stopBreakout", { roomName }, (response) => {
                  if (response.success) {
                    document.getElementById("stopBreakoutRooms").style.display =
                      "none";
                    showAlert("Breakout rooms stopped", "success");
                    breakOutRoomEnded = true;

                    document.getElementById("startBreakoutRooms").innerHTML =
                      'Start Breakout <i class="fas fa-play"></i>';
                    document.getElementById(
                      "startBreakoutRooms"
                    ).disabled = false;
                    document.getElementById(
                      "startBreakoutRooms"
                    ).style.display = "block";
                    $("#breakoutRoomsModal").modal("hide");
                    $("#editRoomModal").modal("hide");

                    if (p_sockets.length > 0) {
                      try {
                        p_sockets[0].emit(
                          "stopBreakout",
                          { roomName },
                          (response) => {
                            if (response.success) {
                            }
                          }
                        );
                      } catch (error) {}
                    }

                    if (meetingDisplayType != prevMeetingDisplayType) {
                      meetingDisplayType = prevMeetingDisplayType;
                    }
                  } else {
                    showAlert(response.reason, "danger");
                  }
                });
              });
          }

          socket.on("breakoutRoomUpdated", async (data) => {
            // data = { breakoutRooms, status, members }
            // status = 'started', 'ended', 'updated'
            // breakoutRooms array
            // members (participants) array only sent to the host

            // forHost = true if the user is the emit is for host switching between breakout rooms
            // newRoom = number (room number joined by the host); only update if forHost is true

            try {
              if (data.forHost) {
                //update the room number joined by the host
                hostNewRoom = data.newRoom;
                onScreenChanges(true);
                return;
              }

              if (islevel == "2" && data.members) {
                //filter out the participant that isBanned == true
                participantsAll = await data.members;
                //remove every field other than isBanned and name from participantsAll
                participantsAll = await participantsAll.map((participant) => ({
                  isBanned: participant.isBanned,
                  name: participant.name,
                }));

                participants = await data.members.filter(
                  (participant) => participant.isBanned == false
                );
              }

              breakoutRooms = data.breakoutRooms;

              if (
                data.status == "started" &&
                (breakOutRoomStarted || !breakOutRoomEnded)
              ) {
                //starting the breakout rooms
                breakOutRoomStarted = true;
                breakOutRoomEnded = false;

                prevMeetingDisplayType = meetingDisplayType;
                if (meetingDisplayType != "all") {
                  meetingDisplayType = "all";
                }
                onScreenChanges(true);
                if (islevel == "2") {
                  rePort(true);
                }
              } else if (data.status == "ended") {
                //ending the breakout rooms
                breakOutRoomEnded = true;

                if (meetingDisplayType != prevMeetingDisplayType) {
                  meetingDisplayType = prevMeetingDisplayType;
                }
                onScreenChanges(true);
                if (islevel == "2") {
                  rePort(true);
                }
              } else if (data.status == "started" && breakOutRoomStarted) {
                //updating the breakout rooms
                breakOutRoomStarted = true;
                breakOutRoomEnded = false;

                onScreenChanges(true);
                if (islevel == "2") {
                  rePort(true);
                }
              }
            } catch (error) {}
          });

          // Function to initialize the modal for manual assignment
          function initializeManualAssignment() {
            const roomEditList = document.getElementById("roomEditList");
            const unassignedList = document.getElementById("unassignedList");

            roomEditList.innerHTML = "";
            unassignedList.innerHTML = "";

            if (currentRoomIndex !== null) {
              const room = breakoutRooms[currentRoomIndex];
              room.forEach((participant) => {
                const listItem = document.createElement("li");
                listItem.classList.add(
                  "list-group-item",
                  "d-flex",
                  "justify-content-between",
                  "align-items-center",
                  "text-dark"
                );
                listItem.innerText = participant.name;
                const removeButton = document.createElement("button");
                removeButton.classList.add("btn", "btn-danger", "btn-sm");
                removeButton.innerHTML = '<i class="fas fa-times"></i>';
                removeButton.addEventListener("click", () =>
                  removeParticipantFromRoom(currentRoomIndex, participant)
                );
                listItem.appendChild(removeButton);
                roomEditList.appendChild(listItem);
              });
            }

            const unassignedParticipants = participants.filter(
              (p) => p.breakRoom === null
            );
            unassignedParticipants.forEach((participant) => {
              const listItem = document.createElement("li");
              listItem.classList.add(
                "list-group-item",
                "d-flex",
                "justify-content-between",
                "align-items-center",
                "text-dark"
              );
              listItem.innerText = participant.name;
              const addButton = document.createElement("button");
              addButton.classList.add("btn", "btn-success", "btn-sm");
              addButton.innerHTML = '<i class="fas fa-plus"></i>';
              addButton.addEventListener("click", () =>
                addParticipantToRoom(currentRoomIndex, participant)
              );
              listItem.appendChild(addButton);
              unassignedList.appendChild(listItem);
            });
          }

          addBreakoutRoomsModal();

          // Whiteboard logic
          let whiteboardUsers = [];
          let currentWhiteboardIndex = null;
          let canStartWhiteboard = false;
          let whiteboardStarted = false;
          let whiteboardEnded = false;
          let whiteboardLimit = itemPageLimit;

          socket.on("whiteboardUpdated", async (data) => {
            // data = { whiteboardUsers, status}
            // status = 'started', 'ended', 'updated'
            // whiteboardUsers array
            // members (participants) array only sent to the host
            //whiteboardData = {shapes=[], useImageBackground=Boolean, redoStack=[], undoStack=[]} or {} or null

            try {
              if (islevel == "2" && data.members) {
                //filter out the participant that isBanned == true
                participantsAll = await data.members;
                //remove every field other than isBanned and name from participantsAll
                participantsAll = await participantsAll.map((participant) => ({
                  isBanned: participant.isBanned,
                  name: participant.name,
                }));

                participants = await data.members.filter(
                  (participant) => participant.isBanned == false
                );
              }

              whiteboardUsers = data.whiteboardUsers;

              //trigger click on panMode if the user is not part of the whiteboardUsers and not the host
              const useBoard = whiteboardUsers.find(
                (user) => user.name == member && user.useBoard
              )
                ? true
                : false;
              if (islevel != "2" && !useBoard && !whiteboardEnded) {
                document.getElementById("panMode").click();
              }

              if (
                data.whiteboardData &&
                Object.keys(data.whiteboardData).length > 0
              ) {
                //update the whiteboard data
                if (data.whiteboardData.shapes) {
                  const oldShapes = shapes.filter(
                    (shape) => shape.type === "image"
                  );
                  shapes = data.whiteboardData.shapes.map((shape) => {
                    if (shape.type === "image") {
                      const oldShape = oldShapes.find(
                        (oldShape) => oldShape.src === shape.src
                      );
                      if (oldShape) {
                        return { ...shape, img: oldShape.img };
                      } else {
                        //we load the image and return the new shape object
                        const img = new Image();
                        img.src = shape.src;
                        return { ...shape, img };
                      }
                    } else {
                      return shape;
                    }
                  });
                }
                data.whiteboardData.useImageBackground != null
                  ? (useImageBackground =
                      data.whiteboardData.useImageBackground)
                  : true;
                if (data.whiteboardData.redoStack) {
                  redoStack = data.whiteboardData.redoStack;
                }
                if (data.whiteboardData.undoStack) {
                  undoStack = data.whiteboardData.undoStack;
                }
              }

              if (data.status == "started" && !whiteboardStarted) {
                //starting the whiteboard
                whiteboardStarted = true;
                whiteboardEnded = false;
                screenId = `whiteboard-${roomName}`;

                //simulate screen sharing started
                if (islevel != "2") {
                  shareScreenStarted = true;
                  await onScreenChanges(true);
                }
              } else if (data.status == "ended") {
                //ending the whiteboard
                const prevWhiteboardEnded = whiteboardEnded;
                const prevWhiteboardStarted = whiteboardStarted;
                whiteboardEnded = true;
                whiteboardStarted = false;
                if (islevel == 2 && prevWhiteboardEnded) {
                } else {
                  if (eventType == "conference") {
                    await moveBoard();
                    $(".maingrid").remove();
                    //add timer
                    addTimer();
                    let height95 = window.innerHeight * 0.95;
                    $(".othergrid").css("height", height95 + "px");
                  }

                  //simulate screen sharing ended
                  shareScreenStarted = false;
                  screenId = null;
                  await onScreenChanges(true);
                }

                try {
                  if (
                    prevWhiteboardStarted &&
                    islevel == "2" &&
                    (recordStarted || recordResumed)
                  ) {
                    if (!(recordPaused || recordStopped)) {
                      if (recordingMediaOptions == "video") {
                        await captureCanvasStream(false);
                      }
                    }
                  }
                } catch (error) {}
              } else if (data.status == "started" && whiteboardStarted) {
                //updating the whiteboard
                whiteboardStarted = true;
                whiteboardEnded = false;

                if (eventType == "conference") {
                  await moveBoard();
                  $(".maingrid").remove();
                  //add timer
                  addTimer();
                  let height95 = window.innerHeight * 0.95;
                  $(".othergrid").css("height", height95 + "px");
                }

                //simulate screen sharing started
                shareScreenStarted = true;
                screenId = `whiteboard-${roomName}`;
                await onScreenChanges(true);
              }
            } catch (error) {}
          });

          async function addWhiteboardModal() {
            let whiteboardUsersCopy = [];
            let participantsCopy = [];
            let currentWhiteboardIndex = null;

            $("#whiteboardModal").on("show.bs.modal", function () {
              whiteboardUsersCopy = [...whiteboardUsers];
              participantsCopy = participants.filter(
                (participant) => participant.islevel != "2"
              );
              renderWhiteboard();
              checkCanStartWhiteboard();
            });

            document
              .getElementById("saveWhiteboard")
              .addEventListener("click", () => {
                if (validateWhiteboard()) {
                  canStartWhiteboard = true;
                  checkCanStartWhiteboard();
                  showAlert("Whiteboard saved successfully", "success");
                } else {
                  showAlert("Whiteboard validation failed", "danger");
                }
              });

            function renderWhiteboard() {
              const whiteboardContainer = document.getElementById(
                "whiteboardContainer"
              );
              whiteboardContainer.innerHTML = "";

              const userDiv = document.createElement("div");
              userDiv.classList.add("card", "mb-3", "text-dark");
              userDiv.innerHTML = `
            <div class="card-header">Whiteboard Participants</div>
            <div class="card-body">
                <div class="row">
                    <div class="col-md-6 mb-3">
                        <h6>Assigned</h6>
                        <ul class="list-group" id="assignedListBoard" style="max-height: 200px; overflow-y: auto; border: 1px solid #ccc;"></ul>
                    </div>
                    <div class="col-md-6 mt-xs-3 mb-3">
                        <h6>Pending</h6>
                        <ul class="list-group" id="unassignedListBoard" style="max-height: 200px; overflow-y: auto; border: 1px solid #ccc;"></ul>
                    </div>
                </div>
            </div>
        `;

              whiteboardContainer.appendChild(userDiv);

              const assignedList = document.getElementById("assignedListBoard");
              const unassignedListBoard = document.getElementById(
                "unassignedListBoard"
              );

              participantsCopy.forEach((participant) => {
                const listItem = document.createElement("li");
                listItem.classList.add(
                  "list-group-item",
                  "d-flex",
                  "justify-content-between",
                  "align-items-center",
                  "text-dark",
                  "mb-2",
                  "mr-2"
                );
                listItem.innerText = participant.name;

                if (participant.useBoard) {
                  const removeButton = document.createElement("button");
                  removeButton.classList.add(
                    "btn",
                    "btn-danger",
                    "btn-sm",
                    "mr-2",
                    "ml-2"
                  );
                  removeButton.innerHTML = '<i class="fas fa-times"></i>';
                  removeButton.addEventListener("click", () =>
                    toggleParticipant(participant, false)
                  );
                  listItem.appendChild(removeButton);
                  assignedList.appendChild(listItem);
                } else {
                  const addButton = document.createElement("button");
                  addButton.classList.add(
                    "btn",
                    "btn-primary",
                    "btn-sm",
                    "mr-2",
                    "ml-2"
                  );
                  addButton.innerHTML = '<i class="fas fa-check"></i>';
                  addButton.addEventListener("click", () =>
                    toggleParticipant(participant, true)
                  );
                  listItem.appendChild(addButton);
                  unassignedListBoard.appendChild(listItem);
                }
              });

              //if any of assignedList or unassignedListBoard is empty; we add a text
              if (assignedList.children.length == 0) {
                const listItem = document.createElement("li");
                listItem.classList.add(
                  "list-group-item",
                  "d-flex",
                  "justify-content-between",
                  "align-items-center",
                  "text-dark"
                );
                listItem.innerText = "None";
                assignedList.appendChild(listItem);
              }
              if (unassignedListBoard.children.length == 0) {
                const listItem = document.createElement("li");
                listItem.classList.add(
                  "list-group-item",
                  "d-flex",
                  "justify-content-between",
                  "align-items-center",
                  "text-dark"
                );
                listItem.innerText = "None";
                unassignedListBoard.appendChild(listItem);
              }
            }

            function toggleParticipant(participant, add) {
              const selectedParticipants = participantsCopy.filter(
                (participant) => participant.useBoard
              );
              if (add && selectedParticipants.length >= whiteboardLimit - 1) {
                showAlert(
                  `Participant limit exceeded - you can only add ${
                    whiteboardLimit - 1
                  } other participants`,
                  "danger"
                );
                return;
              }

              participant.useBoard = add;
              renderWhiteboard();
              canStartWhiteboard = false;
              checkCanStartWhiteboard();
            }

            function validateWhiteboard() {
              const selectedParticipants = participantsCopy.filter(
                (participant) => participant.useBoard
              );

              if (selectedParticipants.length > whiteboardLimit) {
                showAlert("Participant limit exceeded", "danger");
                return false;
              }

              return true;
            }

            function checkCanStartWhiteboard() {
              const startWhiteboardButton =
                document.getElementById("startWhiteboard");
              if (canStartWhiteboard) {
                startWhiteboardButton.style.display = "block";
                startWhiteboardButton.disabled = false;
                whiteboardStarted && !whiteboardEnded
                  ? (startWhiteboardButton.innerHTML =
                      'Update Whiteboard <i class="fas fa-sync-alt"></i>')
                  : (startWhiteboardButton.innerHTML =
                      'Start Whiteboard <i class="fas fa-play"></i>');
              } else {
                startWhiteboardButton.style.display = "none";
                startWhiteboardButton.disabled = true;
              }
              const stopWhiteboardButton =
                document.getElementById("stopWhiteboard");
              if (whiteboardStarted && !whiteboardEnded) {
                stopWhiteboardButton.style.display = "block";
                stopWhiteboardButton.disabled = false;
              } else {
                stopWhiteboardButton.style.display = "none";
                stopWhiteboardButton.disabled = true;
              }
            }

            document
              .getElementById("startWhiteboard")
              .addEventListener("click", async () => {
                if ((shareScreenStarted || shared) && !whiteboardStarted) {
                  showAlert(
                    "You cannot start whiteboard while screen sharing is active",
                    "danger"
                  );
                  return;
                }

                if (breakOutRoomStarted && !breakOutRoomEnded) {
                  showAlert(
                    "You cannot start whiteboard while breakout rooms are active",
                    "danger"
                  );
                  return;
                }

                if (canStartWhiteboard) {
                  const emitName =
                    whiteboardStarted && !whiteboardEnded
                      ? "updateWhiteboard"
                      : "startWhiteboard";

                  const filteredWhiteboardUsers = participantsCopy
                    .filter((participant) => participant.useBoard)
                    .map(({ name, useBoard }) => ({ name, useBoard }));
                  await socket.emit(
                    emitName,
                    { whiteboardUsers: filteredWhiteboardUsers, roomName },
                    async (response) => {
                      if (response.success) {
                        document.getElementById(
                          "stopWhiteboard"
                        ).style.display = "block";
                        showAlert("Whiteboard active", "success");
                        whiteboardStarted = true;
                        whiteboardEnded = false;

                        document.getElementById("startWhiteboard").innerHTML =
                          'Update Whiteboard <i class="fas fa-sync-alt"></i>';
                        document.getElementById(
                          "startWhiteboard"
                        ).disabled = true;
                        document.getElementById(
                          "startWhiteboard"
                        ).style.display = "none";
                        $("#whiteboardModal").modal("hide");

                        if (islevel != "2") {
                          shareScreenStarted = true;
                          await onScreenChanges(true);
                        }

                        try {
                          if (
                            islevel == "2" &&
                            (recordStarted || recordResumed)
                          ) {
                            if (!(recordPaused || recordStopped)) {
                              if (recordingMediaOptions == "video") {
                                await captureCanvasStream();
                              }
                            }
                          }
                        } catch (error) {}
                      } else {
                        showAlert(response.reason, "danger");
                      }
                    }
                  );
                }
              });

            document
              .getElementById("stopWhiteboard")
              .addEventListener("click", async () => {
                await socket.emit(
                  "stopWhiteboard",
                  { roomName },
                  async (response) => {
                    if (response.success) {
                      document.getElementById("stopWhiteboard").style.display =
                        "none";
                      showAlert("Whiteboard stopped", "success");
                      whiteboardEnded = true;

                      document.getElementById("startWhiteboard").innerHTML =
                        'Start Whiteboard <i class="fas fa-play"></i>';
                      document.getElementById(
                        "startWhiteboard"
                      ).disabled = false;
                      document.getElementById("startWhiteboard").style.display =
                        "block";

                      if (eventType == "conference") {
                        moveBoard();
                        $(".maingrid").remove();
                        //add timer
                        addTimer();
                        let height95 = window.innerHeight * 0.95;
                        $(".othergrid").css("height", height95 + "px");
                      }

                      //simulate screen sharing ended
                      shareScreenStarted = false;
                      screenId = null;
                      await prepopulateUserMedia(hostLabel);
                      await onScreenChanges(true);

                      await rePort(true);
                    } else {
                      showAlert(response.reason, "danger");
                    }
                  }
                );
              });
          }

          addWhiteboardModal();

          let shapes = []; // to store drawn shapes
          let useImageBackground = true;
          let redoStack = [];
          let undoStack = [];
          let canvasStream = null;

          async function captureCanvasStream(start = true) {
            try {
              if (start && !canvasStream) {
                canvasStream = $("#whiteboardCanvas")[0].captureStream(30);

                if (!transportCreated) {
                  if (p_sockets.length > 0) {
                    try {
                      await createSendTransportMediaSFU("screen");
                    } catch (error) {}
                  }
                } else {
                  if (p_sockets.length > 0) {
                    try {
                      await screenProducerMediaSFU.close();
                      await sleep(500);
                    } catch (error) {}

                    await connectSendTransportScreen(canvasStream, true);
                  }
                }
              } else {
                if (canvasStream && !start) {
                  canvasStream.getTracks().forEach((track) => track.stop());
                  canvasStream = null;
                  if (p_sockets.length > 0) {
                    disconnectSendTransportScreen(true);
                  }
                }
              }
            } catch (error) {}
          }

          async function startWhiteboard() {
            const canvas = document.getElementById("whiteboardCanvas");
            const ctx = canvas.getContext("2d");
            let mode = "draw"; // default mode
            let isDrawing = false;
            let startX, startY, currentX, currentY;
            let freehandDrawing = []; // to store freehand drawing points
            let selectedShape = null;
            let isPanning = false;
            let isDragging = false;
            let panX = 0,
              panY = 0;
            let scale = 1;
            const minScale = 0.25;
            const maxScale = 1.75;
            let eraserThickness = 10; // default eraser thickness
            let brushThickness = 6; // default brush thickness
            let lineThickness = 6; // default line thickness
            let lineType = "solid"; // default line type
            let color = "#000000"; // default color
            let font = "Arial"; // default font
            let fontSize = 20; // default font size
            let shape = null; // shape to be drawn
            const textInput = document.getElementById("textInput");
            let selectedHandle = null;
            let movingShape = false;
            const imageBackgroundUrl = "/images/svg/graph_paper.jpg";
            const backgroundImage = new Image();
            backgroundImage.src = imageBackgroundUrl;
            let isValidShape = false;

            backgroundImage.onload = () => {
              drawShapes(); // Initial drawing of shapes with the background
            };

            let maxWidth = 1280;
            let maxHeight = 720;
            let dimensionsFixed = false;

            try {
              if (
                targetResolution == "qhd" ||
                eventRoomParams.targetResolutionHost == "qhd"
              ) {
                maxWidth = 1920;
                maxHeight = 1080;
              } else if (
                targetResolution == "fhd" ||
                eventRoomParams.targetResolutionHost == "fhd"
              ) {
                maxWidth = 1920;
                maxHeight = 1080;
              }
              canvas.width = maxWidth;
              canvas.height = maxHeight;
              dimensionsFixed = true;
            } catch (error) {}

            // Event listeners for toolbar buttons
            document
              .getElementById("drawMode")
              .addEventListener("click", () => setMode("draw"));
            document
              .getElementById("shapeMode")
              .addEventListener("click", () => setMode("shape"));

            // Event delegation for shapeMode dropdown items
            document
              .querySelector("#shapeMode + .dropdown-menu")
              .addEventListener("click", (event) => {
                if (event.target.matches(".dropdown-item")) {
                  shape = event.target.getAttribute("data-shape");
                  setMode("shape");
                } else {
                  // it is matching the image in the dropdown so get the parent element
                  shape = event.target.parentElement.getAttribute("data-shape");
                  setMode("shape");
                }
              });

            document
              .getElementById("selectMode")
              .addEventListener("click", () => setMode("select"));
            document
              .getElementById("eraseMode")
              .addEventListener("click", () => setMode("erase"));

            // Event delegation for eraseMode dropdown items
            document
              .querySelector("#eraseMode + .dropdown-menu")
              .addEventListener("click", (event) => {
                if (event.target.matches(".dropdown-item")) {
                  eraserThickness = parseInt(
                    event.target.getAttribute("data-thickness")
                  );
                  setMode("erase");
                }
              });

            document
              .getElementById("panMode")
              .addEventListener("click", () => setMode("pan"));
            document
              .getElementById("zoomIn")
              .addEventListener("click", () => zoomCanvas(1.2));
            document
              .getElementById("zoomReset")
              .addEventListener("click", () => zoomCanvas(10));
            document
              .getElementById("zoomOut")
              .addEventListener("click", () => zoomCanvas(0.8));

            // Event delegation for addText dropdown items
            document
              .querySelector("#addText + .dropdown-menu")
              .addEventListener("click", (event) => {
                if (event.target.matches(".dropdown-item")) {
                  font = event.target.getAttribute("data-font");
                  setMode("text");
                }
              });

            document
              .querySelector("#fontSize + .dropdown-menu")
              .addEventListener("click", (event) => {
                if (event.target.matches(".dropdown-item")) {
                  fontSize = parseInt(event.target.getAttribute("data-size"));
                }
              });

            document
              .getElementById("freehandMode")
              .addEventListener("click", () => setMode("freehand"));

            // Event delegation for freehandMode dropdown items
            document
              .querySelector("#freehandMode + .dropdown-menu")
              .addEventListener("click", (event) => {
                if (event.target.matches(".dropdown-item")) {
                  brushThickness = parseInt(
                    event.target.getAttribute("data-brush-thickness")
                  );
                  setMode("freehand");
                }
              });

            // Event delegation for drawMode dropdown items
            document
              .querySelector("#drawMode + .dropdown-menu")
              .addEventListener("click", (event) => {
                if (event.target.matches(".dropdown-item")) {
                  lineThickness = parseInt(
                    event.target.getAttribute("data-thickness")
                  );
                }
              });

            function checkBoardAccess() {
              if (whiteboardStarted && !whiteboardEnded) {
                const user = whiteboardUsers.find(
                  (user) => user.name == member
                );
                if ((!user || !user.useBoard) && islevel != "2") {
                  showAlert(
                    "You are not allowed to use the whiteboard. Please ask the host to assign you.",
                    "danger"
                  );
                  return false;
                } else {
                  return true;
                }
              } else {
                return true;
              }
            }

            document.getElementById("undo").addEventListener("click", undo);
            document.getElementById("redo").addEventListener("click", redo);
            document
              .getElementById("colorPicker")
              .addEventListener("input", (e) => {
                checkBoardAccess() && (color = e.target.value);
              });
            document
              .getElementById("lineTypePicker")
              .addEventListener("input", (e) => {
                checkBoardAccess() && (lineType = e.target.value);
              });
            document
              .getElementById("save")
              .addEventListener("click", saveCanvas);
            document
              .getElementById("delete")
              .addEventListener("click", deleteShape);
            document
              .getElementById("clearCanvas")
              .addEventListener("click", clearCanvas);
            document
              .getElementById("toggleBackground")
              .addEventListener("click", toggleBackground);
            document
              .getElementById("uploadBoardImage")
              .addEventListener("change", uploadImage);

            canvas.addEventListener("mousedown", startDrawing);
            canvas.addEventListener("mousemove", draw);
            canvas.addEventListener("mouseup", stopDrawing);
            canvas.addEventListener("mouseout", stopDrawing);
            canvas.addEventListener("wheel", handleZoom);
            canvas.addEventListener("click", handleCanvasClick);

            // Event listeners for touch devices
            canvas.addEventListener("touchstart", handleTouchStart);
            canvas.addEventListener("touchmove", handleTouchMove);
            canvas.addEventListener("touchend", handleTouchEnd);

            document
              .getElementById("toolbarToggle")
              .addEventListener("click", function () {
                const toolbar = document.getElementById("toolbar");
                if (
                  toolbar.style.display === "none" ||
                  toolbar.style.display === ""
                ) {
                  toolbar.style.display = "block";
                  this.innerHTML = '<i class="fas fa-chevron-left"></i>'; // Change icon to indicate collapse action
                } else {
                  toolbar.style.display = "none";
                  this.innerHTML = '<i class="fas fa-chevron-right"></i>'; // Change icon to indicate expand action
                }
              });

            function handleTouchStart(e) {
              e.preventDefault();
              const touch = e.touches[0];
              const mouseEvent = new MouseEvent("mousedown", {
                clientX: touch.clientX,
                clientY: touch.clientY,
              });
              canvas.dispatchEvent(mouseEvent);
            }

            function handleTouchMove(e) {
              e.preventDefault();
              const touch = e.touches[0];
              const mouseEvent = new MouseEvent("mousemove", {
                clientX: touch.clientX,
                clientY: touch.clientY,
              });
              canvas.dispatchEvent(mouseEvent);
            }

            function handleTouchEnd(e) {
              e.preventDefault();
              const mouseEvent = new MouseEvent("mouseup", {});
              canvas.dispatchEvent(mouseEvent);
            }

            function setMode(newMode) {
              if (newMode != "pan" && !checkBoardAccess()) return;
              mode = newMode;
              if (mode === "pan") {
                canvas.style.cursor = "grab";
              } else if (mode === "select") {
                canvas.style.cursor = "pointer";
              } else if (mode === "erase") {
                canvas.style.cursor = "crosshair";
              } else {
                canvas.style.cursor = "crosshair";
              }
              if (mode !== "freehand") {
                // Save freehand drawing to shapes array when switching modes
                if (freehandDrawing.length > 0) {
                  shapes.push({
                    type: "freehand",
                    points: freehandDrawing,
                    color,
                    thickness: brushThickness,
                  });
                  freehandDrawing = [];
                  saveState();
                }
              }
            }

            function startDrawing(e) {
              isDrawing = true;
              startX = (e.offsetX - panX) / scale;
              startY = (e.offsetY - panY) / scale;

              if (mode === "erase") {
                erase(startX, startY);
              } else if (mode === "draw" || mode === "freehand") {
                ctx.beginPath();
                ctx.moveTo(startX, startY);
                if (mode === "freehand") {
                  freehandDrawing.push({ x: startX, y: startY });
                }
              } else if (mode === "pan") {
                isPanning = true;
                isDragging = false;
              } else if (mode === "select") {
                selectedHandle = getHandleAtPosition(startX, startY);
                if (selectedHandle) {
                  isDragging = true;
                  movingShape = selectedHandle.isCenter;
                } else {
                  selectedShape = findShape(startX, startY);
                  if (selectedShape) {
                    drawShapes();
                    drawSelection(selectedShape);
                  }
                }
              }
            }

            function draw(e) {
              if (!dimensionsFixed) {
                try {
                  if (
                    targetResolution == "qhd" ||
                    eventRoomParams.targetResolutionHost == "qhd"
                  ) {
                    maxWidth = 1920;
                    maxHeight = 1080;
                  } else if (
                    targetResolution == "fhd" ||
                    eventRoomParams.targetResolutionHost == "fhd"
                  ) {
                    maxWidth = 1920;
                    maxHeight = 1080;
                  }
                  canvas.width = maxWidth;
                  canvas.height = maxHeight;
                  dimensionsFixed = true;
                } catch (error) {}
              }

              if (!isDrawing) return;
              currentX = (e.offsetX - panX) / scale;
              currentY = (e.offsetY - panY) / scale;

              if (mode == "draw" || mode == "freehand" || mode == "shape") {
                //if more than max width or height or less than 0, return
                if (
                  currentX > maxWidth ||
                  currentY > maxHeight ||
                  currentX < 0 ||
                  currentY < 0
                ) {
                  isValidShape = false;
                  return;
                } else {
                  isValidShape = true;
                }
              }

              if (mode === "erase") {
                erase(currentX, currentY);
              } else if (mode === "draw") {
                ctx.clearRect(0, 0, canvas.width, canvas.height);
                drawShapes();
                drawLine(
                  startX,
                  startY,
                  currentX,
                  currentY,
                  color,
                  lineThickness,
                  lineType
                );
              } else if (mode === "freehand") {
                ctx.lineTo(currentX, currentY);
                ctx.strokeStyle = color;
                ctx.lineWidth = brushThickness;
                ctx.stroke();
                freehandDrawing.push({ x: currentX, y: currentY });
              } else if (mode === "shape") {
                ctx.clearRect(0, 0, canvas.width, canvas.height);
                drawShapes();
                drawShape(
                  shape,
                  startX,
                  startY,
                  currentX,
                  currentY,
                  color,
                  lineThickness,
                  lineType
                );
              } else if (mode === "pan" && isPanning) {
                isDragging = true;
                const dx = (currentX - startX) * scale;
                const dy = (currentY - startY) * scale;
                panX += dx;
                panY += dy;
                startX = currentX;
                startY = currentY;

                ctx.setTransform(scale, 0, 0, scale, panX, panY);
                drawShapes();
              } else if (mode === "select" && selectedShape) {
                ctx.clearRect(0, 0, canvas.width, canvas.height); // Clear canvas before drawing
                if (movingShape) {
                  const dx = currentX - startX;
                  const dy = currentY - startY;
                  moveShape(selectedShape, dx, dy);
                  startX = currentX;
                  startY = currentY;
                } else if (isDragging) {
                  resizeShape(
                    selectedShape,
                    selectedHandle,
                    currentX,
                    currentY
                  );
                }
                drawShapes();
                drawSelection(selectedShape);
              }
            }

            function stopDrawing(e) {
              isDrawing = false;
              isPanning = false;
              isDragging = false;
              ctx.closePath();

              if (mode === "draw" && isValidShape) {
                shapes.push({
                  type: "line",
                  x1: startX,
                  y1: startY,
                  x2: currentX,
                  y2: currentY,
                  color,
                  thickness: lineThickness,
                  lineType,
                });
                saveState();
                socket.emit(
                  "updateBoardAction",
                  {
                    action: "draw",
                    payload: {
                      type: "line",
                      x1: startX,
                      y1: startY,
                      x2: currentX,
                      y2: currentY,
                      color,
                      thickness: lineThickness,
                      lineType,
                    },
                  },
                  handleServerResponse
                );
              } else if (mode === "freehand" && isValidShape) {
                shapes.push({
                  type: "freehand",
                  points: freehandDrawing,
                  color,
                  thickness: brushThickness,
                });
                socket.emit(
                  "updateBoardAction",
                  {
                    action: "draw",
                    payload: {
                      type: "freehand",
                      points: freehandDrawing,
                      color,
                      thickness: brushThickness,
                    },
                  },
                  handleServerResponse
                );
                freehandDrawing = [];
                saveState();
              } else if (mode === "shape" && isValidShape) {
                shapes.push({
                  type: shape,
                  x1: startX,
                  y1: startY,
                  x2: currentX,
                  y2: currentY,
                  color,
                  thickness: lineThickness,
                  lineType,
                });
                saveState();
                socket.emit(
                  "updateBoardAction",
                  {
                    action: "shape",
                    payload: {
                      type: shape,
                      x1: startX,
                      y1: startY,
                      x2: currentX,
                      y2: currentY,
                      color,
                      thickness: lineThickness,
                      lineType,
                    },
                  },
                  handleServerResponse
                );
              } else if (mode === "select") {
                if (selectedShape && !movingShape && !isDragging) {
                  const shape = findShape(currentX, currentY);
                  if (shape) {
                    selectedShape = shape;
                    drawShapes();
                    drawSelection(shape);
                  }
                }
                if (selectedShape) {
                  socket.emit(
                    "updateBoardAction",
                    { action: "shapes", payload: { shapes } },
                    handleServerResponse
                  );
                }
                saveState();
              }
            }

            function erase(x, y) {
              ctx.save();
              ctx.globalCompositeOperation = "destination-out";
              ctx.beginPath();
              ctx.arc(x, y, eraserThickness / 2, 0, Math.PI * 2, false);
              ctx.fill();
              ctx.restore();

              let changeOccurred = false;

              // Erase parts of shapes
              shapes = shapes
                .map((shape) => {
                  if (shape.type === "freehand") {
                    return {
                      ...shape,
                      points: shape.points.filter((point) => {
                        const distance = Math.sqrt(
                          Math.pow(point.x - x, 2) + Math.pow(point.y - y, 2)
                        );
                        if (distance <= eraserThickness / 2) {
                          changeOccurred = true;
                          return false;
                        }
                        return distance > eraserThickness / 2;
                      }),
                    };
                  } else if (shape.type === "line") {
                    if (
                      isPointNearLine(
                        x,
                        y,
                        shape.x1,
                        shape.y1,
                        shape.x2,
                        shape.y2,
                        eraserThickness / 2
                      )
                    ) {
                      changeOccurred = true;
                      return null;
                    }
                  } else if (shape.type === "text") {
                    const textWidth = ctx.measureText(shape.text).width;
                    if (
                      x > shape.x &&
                      x < shape.x + textWidth &&
                      y > shape.y - shape.fontSize &&
                      y < shape.y
                    ) {
                      changeOccurred = true;
                      return null;
                    }
                  } else if (shape.type === "image") {
                    // check if the point is within the image
                    if (
                      x > shape.x1 &&
                      x < shape.x2 &&
                      y > shape.y1 &&
                      y < shape.y2
                    ) {
                      changeOccurred = true;
                      return null;
                    }
                  } else {
                    if (
                      x > shape.x1 &&
                      x < shape.x2 &&
                      y > shape.y1 &&
                      y < shape.y2
                    ) {
                      changeOccurred = true;
                      return null;
                    }
                  }
                  return shape;
                })
                .filter(
                  (shape) =>
                    shape &&
                    (shape.type !== "freehand" || shape.points.length > 0)
                );

              drawShapes();

              //if there is a change in the shapes array, we emit the changes to the server
              if (changeOccurred) {
                socket.emit(
                  "updateBoardAction",
                  { action: "shapes", payload: { shapes } },
                  handleServerResponse
                );
              }
            }

            function isPointNearLine(px, py, x1, y1, x2, y2, threshold) {
              const dx = x2 - x1;
              const dy = y2 - y1;
              const length = Math.sqrt(dx * dx + dy * dy);
              const dot = ((px - x1) * dx + (py - y1) * dy) / (length * length);
              const closestX = x1 + dot * dx;
              const closestY = y1 + dot * dy;
              const distance = Math.sqrt(
                Math.pow(px - closestX, 2) + Math.pow(py - closestY, 2)
              );
              return distance <= threshold;
            }

            function handleZoom(e) {
              e.preventDefault();
              if (e.deltaY < 0) {
                zoomCanvas(1.2);
              } else {
                zoomCanvas(0.8);
              }
            }

            function zoomCanvas(scaleFactor) {
              if (scaleFactor === 10) {
                // Reset to original scale and pan
                scale = 1;
                panX = 0;
                panY = 0;
              } else {
                let newScale = scale * scaleFactor;
                if (newScale < minScale) {
                  newScale = minScale;
                } else if (newScale > maxScale) {
                  newScale = maxScale;
                }

                const rect = canvas.getBoundingClientRect();
                const offsetX = (event.clientX - rect.left) / rect.width;
                const offsetY = (event.clientY - rect.top) / rect.height;

                const dx = offsetX * canvas.width * (1 - scaleFactor);
                const dy = offsetY * canvas.height * (1 - scaleFactor);

                scale = newScale;
                panX = panX * scaleFactor + dx;
                panY = panY * scaleFactor + dy;

                // Limit panning to canvas bounds
                const maxPanX = (canvas.width * (scale - 1)) / scale;
                const maxPanY = (canvas.height * (scale - 1)) / scale;
                panX = Math.min(Math.max(panX, -maxPanX), 0);
                panY = Math.min(Math.max(panY, -maxPanY), 0);
              }

              ctx.setTransform(scale, 0, 0, scale, panX, panY);
              drawShapes();
            }

            function drawEdgeMarkers() {
              ctx.save();
              ctx.setTransform(1, 0, 0, 1, 0, 0); // Reset transformations
              ctx.strokeStyle = "red";
              ctx.lineWidth = 5;
              ctx.setLineDash([]); // reset line dash

              const markerLength = 20; // Length of the marker lines

              const topLeftX = panX;
              const topLeftY = panY;

              const bottomRightX = panX + maxWidth * scale;
              const bottomRightY = panY + maxHeight * scale;

              // Top-left corner
              ctx.beginPath();
              ctx.moveTo(topLeftX, topLeftY + markerLength);
              ctx.lineTo(topLeftX, topLeftY);
              ctx.lineTo(topLeftX + markerLength, topLeftY);
              ctx.stroke();

              // Top-right corner
              ctx.beginPath();
              ctx.moveTo(bottomRightX - markerLength, topLeftY);
              ctx.lineTo(bottomRightX, topLeftY);
              ctx.lineTo(bottomRightX, topLeftY + markerLength);
              ctx.stroke();

              // Bottom-right corner
              ctx.beginPath();
              ctx.moveTo(bottomRightX, bottomRightY - markerLength);
              ctx.lineTo(bottomRightX, bottomRightY);
              ctx.lineTo(bottomRightX - markerLength, bottomRightY);
              ctx.stroke();

              // Bottom-left corner
              ctx.beginPath();
              ctx.moveTo(topLeftX + markerLength, bottomRightY);
              ctx.lineTo(topLeftX, bottomRightY);
              ctx.lineTo(topLeftX, bottomRightY - markerLength);
              ctx.stroke();

              ctx.restore();
            }

            function drawShapes() {
              ctx.clearRect(0, 0, canvas.width, canvas.height); // Clear canvas before drawing
              ctx.save();
              ctx.setTransform(scale, 0, 0, scale, panX, panY);
              if (useImageBackground) {
                ctx.drawImage(
                  backgroundImage,
                  -panX / scale,
                  -panY / scale,
                  canvas.width / scale,
                  canvas.height / scale
                );
              } else {
                ctx.fillStyle = "#fff";
                ctx.fillRect(
                  -panX / scale,
                  -panY / scale,
                  canvas.width / scale,
                  canvas.height / scale
                );
              }
              shapes.forEach((shape) => {
                if (shape.type === "line") {
                  drawLine(
                    shape.x1,
                    shape.y1,
                    shape.x2,
                    shape.y2,
                    shape.color,
                    shape.thickness,
                    shape.lineType
                  );
                } else if (shape.type === "freehand") {
                  drawFreehand(shape.points, shape.color, shape.thickness);
                } else if (shape.type === "text") {
                  ctx.font = `${shape.fontSize}px ${shape.font}`;
                  ctx.fillStyle = shape.color;
                  ctx.fillText(shape.text, shape.x, shape.y);
                } else if (shape.type === "image") {
                  ctx.drawImage(
                    shape.img,
                    shape.x1,
                    shape.y1,
                    shape.x2 - shape.x1,
                    shape.y2 - shape.y1
                  );
                } else {
                  drawShape(
                    shape.type,
                    shape.x1,
                    shape.y1,
                    shape.x2,
                    shape.y2,
                    shape.color,
                    shape.thickness,
                    shape.lineType
                  );
                }
              });
              ctx.restore();

              drawEdgeMarkers();
            }

            function drawLine(x1, y1, x2, y2, color, thickness, lineType) {
              ctx.beginPath();
              ctx.strokeStyle = color;
              ctx.lineWidth = thickness;
              if (lineType === "dashed") {
                ctx.setLineDash([10, 10]);
              } else if (lineType === "dotted") {
                ctx.setLineDash([2, 10]);
              } else if (lineType === "dashDot") {
                ctx.setLineDash([10, 5, 2, 5]);
              } else {
                ctx.setLineDash([]);
              }
              ctx.moveTo(x1, y1);
              ctx.lineTo(x2, y2);
              ctx.stroke();
              ctx.setLineDash([]); // reset dash
            }

            function drawText(text, x, y, color, font) {
              ctx.font = `20px ${font}`;
              ctx.fillStyle = color;
              ctx.fillText(text, x, y);
            }

            function drawFreehand(points, color, thickness) {
              if (points.length < 2) return;
              ctx.strokeStyle = color;
              ctx.lineWidth = thickness;
              ctx.beginPath();
              ctx.moveTo(points[0].x, points[0].y);
              for (let i = 1; i < points.length; i++) {
                ctx.lineTo(points[i].x, points[i].y);
              }
              ctx.stroke();
            }

            function drawPolygon(ctx, sides, x1, y1, x2, y2) {
              const centerX = (x1 + x2) / 2;
              const centerY = (y1 + y2) / 2;
              const radius = Math.min(Math.abs(x2 - x1), Math.abs(y2 - y1)) / 2;
              const angle = (2 * Math.PI) / sides;
              ctx.beginPath();
              for (let i = 0; i < sides; i++) {
                const x = centerX + radius * Math.cos(i * angle - Math.PI / 2);
                const y = centerY + radius * Math.sin(i * angle - Math.PI / 2);
                if (i === 0) {
                  ctx.moveTo(x, y);
                } else {
                  ctx.lineTo(x, y);
                }
              }
              ctx.closePath();
              ctx.stroke();
            }

            function drawShape(
              type,
              x1,
              y1,
              x2,
              y2,
              color,
              thickness,
              lineType,
              ctxx = ctx
            ) {
              ctxx.beginPath();
              ctxx.strokeStyle = color;
              ctxx.lineWidth = thickness;
              if (lineType === "dashed") {
              } else if (lineType === "dotted") {
                ctxx.setLineDash([2, 10]);
              } else if (lineType === "dashDot") {
                ctxx.setLineDash([10, 5, 2, 5]);
              } else {
                ctxx.setLineDash([]);
              }
              if (type === "rectangle") {
                ctxx.strokeRect(x1, y1, x2 - x1, y2 - y1);
              } else if (type === "circle") {
                const radius = Math.sqrt(
                  Math.pow(x2 - x1, 2) + Math.pow(y2 - y1, 2)
                );
                ctxx.arc(x1, y1, radius, 0, 2 * Math.PI);
                ctxx.stroke();
              } else if (type === "rhombus") {
                const centerX = (x1 + x2) / 2;
                const centerY = (y1 + y2) / 2;
                const halfWidth = Math.abs(x2 - x1) / 2;
                const halfHeight = Math.abs(y2 - y1) / 2;
                ctxx.moveTo(centerX, y1);
                ctxx.lineTo(x2, centerY);
                ctxx.lineTo(centerX, y2);
                ctxx.lineTo(x1, centerY);
                ctxx.closePath();
                ctxx.stroke();
              } else if (type === "pentagon") {
                drawPolygon(ctxx, 5, x1, y1, x2, y2);
              } else if (type === "hexagon") {
                drawPolygon(ctxx, 6, x1, y1, x2, y2);
              } else if (type === "triangle") {
                const centerXTriangle = (x1 + x2) / 2;
                ctxx.moveTo(centerXTriangle, y1);
                ctxx.lineTo(x2, y2);
                ctxx.lineTo(x1, y2);
                ctxx.closePath();
                ctxx.stroke();
              } else if (type === "square") {
                ctxx.strokeRect(x1, y1, x2 - x1, x2 - x1);
              } else if (type === "octagon") {
                drawPolygon(ctxx, 8, x1, y1, x2, y2);
              } else if (type === "oval") {
                const radiusX = Math.abs(x2 - x1) / 2;
                const radiusY = Math.abs(y2 - y1) / 2;
                const centerX = (x1 + x2) / 2;
                const centerY = (y1 + y2) / 2;
                ctxx.ellipse(
                  centerX,
                  centerY,
                  radiusX,
                  radiusY,
                  0,
                  0,
                  2 * Math.PI
                );
                ctxx.stroke();
              } else if (type === "parallelogram") {
                const centerX = (x1 + x2) / 2;
                const centerY = (y1 + y2) / 2;
                ctxx.moveTo(centerX, y1);
                ctxx.lineTo(x2, y2);
                ctxx.lineTo(centerX, y2);
                ctxx.lineTo(x1, y1);
                ctxx.closePath();
                ctxx.stroke();
              } else if (type === "image") {
                ctxx.drawImage(shape.img, x1, y1, x2 - x1, y2 - y1);
              }
            }

            function handleCanvasClick(e) {
              if (mode === "text") {
                textInput.style.left = e.clientX + "px";
                textInput.style.top = e.clientY + "px";
                textInput.style.display = "block";
                textInput.focus();
                textInput.addEventListener("keypress", function onEnter(event) {
                  if (event.key === "Enter") {
                    const text = textInput.value;
                    textInput.style.display = "none";
                    textInput.value = "";
                    shapes.push({
                      type: "text",
                      text,
                      x: (e.offsetX - panX) / scale,
                      y: (e.offsetY - panY) / scale,
                      color,
                      font,
                      fontSize,
                    });
                    drawShapes();
                    textInput.removeEventListener("keypress", onEnter);
                    socket.emit(
                      "updateBoardAction",
                      {
                        action: "text",
                        payload: {
                          type: "text",
                          text,
                          x: (e.offsetX - panX) / scale,
                          y: (e.offsetY - panY) / scale,
                          color,
                          font,
                          fontSize,
                        },
                      },
                      handleServerResponse
                    );
                  }
                });
              }
            }

            function undo() {
              if (!checkBoardAccess()) return;

              if (shapes.length > 0) {
                redoStack.push(shapes.pop());
                drawShapes();
                socket.emit(
                  "updateBoardAction",
                  { action: "undo" },
                  handleServerResponse
                );
              }
            }

            function redo() {
              if (!checkBoardAccess()) return;

              if (redoStack.length > 0) {
                shapes.push(redoStack.pop());
                drawShapes();
                socket.emit(
                  "updateBoardAction",
                  { action: "redo" },
                  handleServerResponse
                );
              }
            }

            function saveState() {
              undoStack.push(JSON.stringify(shapes));
            }

            function findShape(x, y) {
              return shapes.find((shape) => {
                if (shape.type === "freehand") {
                  return shape.points.some((point) => {
                    const distance = Math.sqrt(
                      Math.pow(point.x - x, 2) + Math.pow(point.y - y, 2)
                    );
                    return distance < shape.thickness;
                  });
                } else if (shape.type === "text") {
                  ctx.font = `${shape.fontSize}px ${shape.font}`;
                  const textMetrics = ctx.measureText(shape.text);
                  return (
                    x > shape.x &&
                    x < shape.x + textMetrics.width &&
                    y > shape.y - shape.fontSize &&
                    y < shape.y
                  );
                } else if (shape.type === "image") {
                  return (
                    x > shape.x1 && x < shape.x2 && y > shape.y1 && y < shape.y2
                  );
                } else {
                  return (
                    x > shape.x1 && x < shape.x2 && y > shape.y1 && y < shape.y2
                  );
                }
              });
            }

            function drawSelection(shape, doEmits = true) {
              if (!shape || !doEmits) return;

              const handles = getResizeHandles(shape);
              ctx.strokeStyle = "red";
              ctx.lineWidth = 2;
              ctx.setLineDash([6, 3]);
              if (shape.type === "line") {
                ctx.beginPath();
                ctx.moveTo(shape.x1, shape.y1);
                ctx.lineTo(shape.x2, shape.y2);
                ctx.stroke();
              } else if (shape.type === "circle") {
                const radius = Math.sqrt(
                  Math.pow(shape.x2 - shape.x1, 2) +
                    Math.pow(shape.y2 - shape.y1, 2)
                );
                ctx.beginPath();
                ctx.arc(shape.x1, shape.y1, radius, 0, 2 * Math.PI);
                ctx.stroke();
              } else {
                ctx.strokeRect(
                  shape.x1,
                  shape.y1,
                  shape.x2 - shape.x1,
                  shape.y2 - shape.y1
                );
              }

              ctx.setLineDash([]); // reset dash

              handles.forEach((handle) => {
                ctx.fillStyle = handle.isCenter ? "blue" : "red"; // Different color for center handle
                ctx.fillRect(handle.x - 6, handle.y - 6, 12, 12); // Increase the size of the dots
              });
            }

            function getResizeHandles(shape) {
              const handles = [];
              if (shape.type === "line") {
                handles.push({ x: shape.x1, y: shape.y1 });
                handles.push({ x: shape.x2, y: shape.y2 });
              } else if (shape.type === "circle") {
                const radius = Math.sqrt(
                  Math.pow(shape.x2 - shape.x1, 2) +
                    Math.pow(shape.y2 - shape.y1, 2)
                );
                handles.push({ x: shape.x1 + radius, y: shape.y1 });
                handles.push({ x: shape.x1 - radius, y: shape.y1 });
                handles.push({ x: shape.x1, y: shape.y1 + radius });
                handles.push({ x: shape.x1, y: shape.y1 - radius });
                handles.push({ x: shape.x1, y: shape.y1, isCenter: true }); // Center handle for moving
              } else if (shape.type === "text") {
                const textMetrics = ctx.measureText(shape.text);
                handles.push({
                  x: shape.x,
                  y: shape.y - shape.fontSize,
                  isCenter: true,
                }); // Top-left corner for moving
                handles.push({
                  x: shape.x + textMetrics.width,
                  y: shape.y,
                  isCenter: false,
                }); // Bottom-right corner for resizing
              } else if (shape.type === "image") {
                handles.push({ x: shape.x1, y: shape.y1 });
                handles.push({ x: shape.x2, y: shape.y1 });
                handles.push({ x: shape.x2, y: shape.y2 });
                handles.push({ x: shape.x1, y: shape.y2 });
                handles.push({
                  x: (shape.x1 + shape.x2) / 2,
                  y: (shape.y1 + shape.y2) / 2,
                  isCenter: true,
                }); // Center handle for moving
              } else {
                handles.push({ x: shape.x1, y: shape.y1 });
                handles.push({ x: shape.x2, y: shape.y1 });
                handles.push({ x: shape.x2, y: shape.y2 });
                handles.push({ x: shape.x1, y: shape.y2 });
                handles.push({
                  x: (shape.x1 + shape.x2) / 2,
                  y: (shape.y1 + shape.y2) / 2,
                  isCenter: true,
                }); // Center handle for moving
              }
              return handles.map((handle) => ({
                ...handle,
                isCenter: handle.isCenter || false,
              }));
            }

            function getHandleAtPosition(x, y) {
              if (!selectedShape) return null;
              return getResizeHandles(selectedShape).find((handle) => {
                return Math.abs(handle.x - x) < 6 && Math.abs(handle.y - y) < 6;
              });
            }

            function resizeShape(shape, handle, x, y, doEmits = true) {
              if (shape.type === "line") {
                if (handle.x === shape.x1 && handle.y === shape.y1) {
                  shape.x1 = x;
                  shape.y1 = y;
                } else {
                  shape.x2 = x;
                  shape.y2 = y;
                }
              } else if (shape.type === "circle") {
                const dx = x - shape.x1;
                const dy = y - shape.y1;
                const radius = Math.sqrt(dx * dx + dy * dy);
                shape.x2 = shape.x1 + radius;
                shape.y2 = shape.y1;
              } else if (shape.type === "text") {
                if (handle.isCenter) {
                  shape.x = x;
                  shape.y = y;
                } else {
                  const textMetrics = ctx.measureText(shape.text);
                  shape.x = x - textMetrics.width;
                  shape.y = y;
                }
              } else if (shape.type === "image") {
                if (handle.isCenter) {
                  const dx = x - (shape.x1 + shape.x2) / 2;
                  const dy = y - (shape.y1 + shape.y2) / 2;
                  moveShape(shape, dx, dy);
                } else {
                  if (handle.x === shape.x1 && handle.y === shape.y1) {
                    shape.x1 = x;
                    shape.y1 = y;
                  } else if (handle.x === shape.x2 && handle.y === shape.y1) {
                    shape.x2 = x;
                    shape.y1 = y;
                  } else if (handle.x === shape.x2 && handle.y === shape.y2) {
                    shape.x2 = x;
                    shape.y2 = y;
                  } else {
                    shape.x1 = x;
                    shape.y2 = y;
                  }
                }
              } else {
                if (handle.isCenter) {
                  const dx = x - (shape.x1 + shape.x2) / 2;
                  const dy = y - (shape.y1 + shape.y2) / 2;
                  moveShape(shape, dx, dy);
                } else {
                  if (handle.x === shape.x1 && handle.y === shape.y1) {
                    shape.x1 = x;
                    shape.y1 = y;
                  } else if (handle.x === shape.x2 && handle.y === shape.y1) {
                    shape.x2 = x;
                    shape.y1 = y;
                  } else if (handle.x === shape.x2 && handle.y === shape.y2) {
                    shape.x2 = x;
                    shape.y2 = y;
                  } else {
                    shape.x1 = x;
                    shape.y2 = y;
                  }
                }
              }
              drawShapes(); // Ensure the initial shape is not shown when resizing
            }

            function moveShape(shape, dx, dy, doEmits = true) {
              if (shape.type === "line" || shape.type === "circle") {
                shape.x1 += dx;
                shape.y1 += dy;
                shape.x2 += dx;
                shape.y2 += dy;
              } else if (shape.type === "freehand") {
                shape.points.forEach((point) => {
                  point.x += dx;
                  point.y += dy;
                });
              } else if (shape.type === "text") {
                shape.x += dx;
                shape.y += dy;
              } else if (shape.type === "image") {
                shape.x1 += dx;
                shape.y1 += dy;
                shape.x2 += dx;
                shape.y2 += dy;
              } else {
                shape.x1 += dx;
                shape.y1 += dy;
                shape.x2 += dx;
                shape.y2 += dy;
              }
            }

            function downloadCanvas(canvas) {
              const link = document.createElement("a");
              link.download = "whiteboard.png";
              link.href = canvas.toDataURL();
              link.click();
            }

            function saveCanvas() {
              const tempCanvas = document.createElement("canvas");
              const tempCtx = tempCanvas.getContext("2d");
              tempCanvas.width = canvas.width;
              tempCanvas.height = canvas.height;
              const notShapes = ["freehand", "text", "image", "line"];

              if (useImageBackground) {
                const backgroundImage = new Image();
                backgroundImage.crossOrigin = "anonymous";
                backgroundImage.onload = () => {
                  tempCtx.drawImage(
                    backgroundImage,
                    0,
                    0,
                    tempCanvas.width,
                    tempCanvas.height
                  );
                  shapes.forEach((shape) => {
                    !notShapes.includes(shape.type)
                      ? drawShape(
                          shape.type,
                          shape.x1,
                          shape.y1,
                          shape.x2,
                          shape.y2,
                          shape.color,
                          shape.thickness,
                          shape.lineType,
                          tempCtx
                        )
                      : drawShapeOnCanvas(shape, tempCtx);
                  });
                  downloadCanvas(tempCanvas);
                };
                backgroundImage.src = imageBackgroundUrl;
              } else {
                // set the background color back to white
                tempCtx.fillStyle = "white";
                tempCtx.fillRect(0, 0, tempCanvas.width, tempCanvas.height);

                shapes.forEach((shape) => {
                  !notShapes.includes(shape.type)
                    ? drawShape(
                        shape.type,
                        shape.x1,
                        shape.y1,
                        shape.x2,
                        shape.y2,
                        shape.color,
                        shape.thickness,
                        shape.lineType,
                        tempCtx
                      )
                    : drawShapeOnCanvas(shape, tempCtx);
                });
                downloadCanvas(tempCanvas);
              }
            }

            function drawShapeOnCanvas(shape, ctxx = ctx) {
              ctxx.beginPath();
              ctxx.strokeStyle = shape.color;
              ctxx.lineWidth = shape.thickness || 2;
              ctxx.fillStyle = shape.color;
              ctxx.font = `${shape.fontSize}px ${shape.fontFamily}`;

              const lineType = shape.lineType ? shape.lineType : "solid";

              if (lineType === "dashed") {
              } else if (lineType === "dotted") {
                ctxx.setLineDash([2, 10]);
              } else if (lineType === "dashDot") {
                ctxx.setLineDash([10, 5, 2, 5]);
              } else {
                ctxx.setLineDash([]);
              }
              switch (shape.type) {
                case "line":
                  ctxx.moveTo(shape.x1, shape.y1);
                  ctxx.lineTo(shape.x2, shape.y2);
                  break;
                case "freehand":
                  try {
                    ctxx.moveTo(shape.points[0].x, shape.points[0].y);
                    shape.points.forEach((point) =>
                      ctxx.lineTo(point.x, point.y)
                    );
                  } catch (e) {}
                  break;
                case "text":
                  ctxx.fillText(shape.text, shape.x, shape.y);
                  break;
                case "image":
                  ctxx.drawImage(
                    shape.img,
                    shape.x1,
                    shape.y1,
                    shape.x2 - shape.x1,
                    shape.y2 - shape.y1
                  );
                  break;
                default:
                  break;
              }
              ctxx.stroke();
            }

            function deleteShape(doEmits = true) {
              if (doEmits && !checkBoardAccess()) return;

              if (!selectedShape) return;
              if (selectedShape) {
                shapes = shapes.filter((shape) => shape !== selectedShape);
                if (doEmits) {
                  socket.emit(
                    "updateBoardAction",
                    { action: "shapes", payload: { shapes } },
                    handleServerResponse
                  );
                }
                selectedShape = null;
                drawShapes();
              }
            }

            function toggleBackground(doEmits = true) {
              if (doEmits && !checkBoardAccess()) return;

              useImageBackground = !useImageBackground;
              const toggleButton = document.getElementById("toggleBackground");
              if (useImageBackground) {
                canvas.style.backgroundImage = `url('${imageBackgroundUrl}')`;
                toggleButton.classList.remove("active");
              } else {
                canvas.style.backgroundImage = "none";
                canvas.style.backgroundColor = "white";
                toggleButton.classList.add("active");
              }
              drawShapes();
              if (doEmits) {
                socket.emit(
                  "updateBoardAction",
                  { action: "toggleBackground", payload: useImageBackground },
                  handleServerResponse
                );
              }
            }

            function clearCanvas(doEmits = true) {
              if (islevel != "2" && doEmits) {
                showAlert(
                  "You do not have permission to clear the board",
                  "danger"
                );
                return;
              }
              if (shapes.length === 0) return;
              shapes = [];
              drawShapes();
              if (doEmits) {
                socket.emit(
                  "updateBoardAction",
                  { action: "clear" },
                  handleServerResponse
                );
              }
            }

            function uploadImage(e, doEmits = true) {
              try {
                if (doEmits && !checkBoardAccess()) return;
                const file = e.target.files[0];
                if (file.size > 1024 * 1024) {
                  // 1MB
                  showAlert("File size must be less than 1MB", "danger");
                  return;
                }

                const reader = new FileReader();
                reader.onload = function (event) {
                  const img = new Image();
                  img.onload = function () {
                    if (
                      img.height > 600 &&
                      img.height > img.width &&
                      !file.type.includes("jpeg")
                    ) {
                      showAlert(
                        "For better performance, please upload the image in JPG format.",
                        "warning"
                      );
                      return;
                    }

                    let imageWidth = 350; // Fixed width
                    const aspectRatio = img.height / img.width;
                    let imageHeight = imageWidth * aspectRatio;
                    const maxHeight = 600; // Max height
                    if (imageHeight > maxHeight) {
                      imageHeight = maxHeight;
                      imageWidth = imageHeight / aspectRatio;
                      if (imageWidth > 600) {
                        // Max width
                        imageWidth = 600;
                      }
                    }
                    const imageShape = {
                      type: "image",
                      img: img,
                      src: event.target.result,
                      x1: 50,
                      y1: 50,
                      x2: 50 + imageWidth,
                      y2: 50 + imageHeight,
                    };
                    shapes.push(imageShape);
                    drawShapes();
                    if (doEmits) {
                      socket.emit(
                        "updateBoardAction",
                        { action: "uploadImage", payload: imageShape },
                        handleServerResponse
                      );
                    }
                  };
                  img.onerror = function () {
                    showAlert("Error loading image", "danger");
                  };
                  img.src = event.target.result;
                };
                reader.onerror = function () {
                  showAlert("Error reading file", "danger");
                };
                reader.readAsDataURL(file);
              } catch (error) {}
            }

            function handleServerResponse(response) {
              if (!response.success) {
                showAlert(
                  `Whiteboard action failed: ${response.reason}`,
                  "danger"
                );
              }
            }

            // Listen for events from the server
            socket.on("whiteboardAction", (data) => {
              const { action, payload } = data;

              switch (action) {
                case "draw":
                  if (payload.type === "freehand") {
                    drawFreehand(
                      payload.points,
                      payload.color,
                      payload.thickness
                    );
                    shapes.push({
                      type: "freehand",
                      points: payload.points,
                      color: payload.color,
                      thickness: payload.thickness,
                    });
                  } else {
                    drawLine(
                      payload.x1,
                      payload.y1,
                      payload.x2,
                      payload.y2,
                      payload.color,
                      payload.thickness,
                      payload.lineType
                    );
                    shapes.push({
                      type: "line",
                      x1: payload.x1,
                      y1: payload.y1,
                      x2: payload.x2,
                      y2: payload.y2,
                      color: payload.color,
                      thickness: payload.thickness,
                      lineType: payload.lineType,
                    });
                  }
                  break;
                case "shape":
                  drawShape(
                    payload.type,
                    payload.x1,
                    payload.y1,
                    payload.x2,
                    payload.y2,
                    payload.color,
                    payload.thickness,
                    payload.lineType
                  );
                  shapes.push({
                    type: payload.type,
                    x1: payload.x1,
                    y1: payload.y1,
                    x2: payload.x2,
                    y2: payload.y2,
                    color: payload.color,
                    thickness: payload.thickness,
                    lineType: payload.lineType,
                  });
                  break;
                case "erase":
                  erase(payload.x, payload.y, payload.eraserThickness);
                  break;
                case "clear":
                  clearCanvas(false);
                  break;
                case "uploadImage":
                  const img = new Image();
                  img.onload = function () {
                    const imageShape = {
                      type: "image",
                      img,
                      src: payload.src,
                      x1: payload.x1,
                      y1: payload.y1,
                      x2: payload.x2,
                      y2: payload.y2,
                    };
                    shapes.push(imageShape);
                    drawShapes();
                  };
                  img.src = payload.src;
                  break;
                case "toggleBackground":
                  toggleBackground(false);
                  drawShapes();
                  break;
                case "undo":
                  if (shapes.length > 0) {
                    redoStack.push(shapes.pop());
                    drawShapes();
                  }
                  break;
                case "redo":
                  if (redoStack.length > 0) {
                    shapes.push(redoStack.pop());
                    drawShapes();
                  }
                  break;
                case "text":
                  shapes.push({
                    type: "text",
                    text: payload.text,
                    x: payload.x,
                    y: payload.y,
                    color: payload.color,
                    font: payload.font,
                    fontSize: payload.fontSize,
                  });
                  drawShapes();
                  break;
                case "deleteShape":
                  shapes = shapes.filter((shape) => shape !== payload);
                  drawShapes();
                  break;
                case "shapes":
                  //loop through the shapes and if we have images; and old shapes also have image of same src, we keep
                  //the old image object to avoid flickering
                  const oldShapes = shapes.filter(
                    (shape) => shape.type === "image"
                  );
                  shapes = payload.shapes.map((shape) => {
                    if (shape.type === "image") {
                      const oldShape = oldShapes.find(
                        (oldShape) => oldShape.src === shape.src
                      );
                      if (oldShape) {
                        return { ...shape, img: oldShape.img };
                      } else {
                        //we load the image and return the new shape object
                        const img = new Image();
                        img.src = shape.src;
                        return { ...shape, img };
                      }
                    } else {
                      return shape;
                    }
                  });
                  drawShapes();
                  break;
                default:
                  break;
              }
            });

            setMode("pan"); // Initialize in draw mode
          }

          startWhiteboard();

          async function startScreenboard(canvasRef = "screenboardCanvas") {
            let canvas = document.getElementById(canvasRef);
            const ctx = canvas.getContext("2d");
            let mode = "draw"; // default mode
            let isDrawing = false;
            let startX, startY, currentX, currentY;
            let freehandDrawing = []; // to store freehand drawing points
            let selectedShape = null;
            let shapes = [];
            let eraserThickness = 10; // default eraser thickness
            let brushThickness = 6; // default brush thickness
            let lineThickness = 6; // default line thickness
            let lineType = "solid"; // default line type
            let color = "#000000"; // default color
            let font = "Arial"; // default font
            let fontSize = 20; // default font size
            let shape = null; // shape to be drawn

            // Event listeners for toolbar buttons
            document
              .getElementById("drawModeScreen")
              .addEventListener("click", () => setMode("draw"));
            document
              .getElementById("shapeModeScreen")
              .addEventListener("click", () => setMode("shape"));
            document
              .querySelector("#shapeModeScreen + .dropdown-menu")
              .addEventListener("click", (event) => {
                if (event.target.matches(".dropdown-item")) {
                  shape = event.target.getAttribute("data-shape");
                  setMode("shape");
                } else {
                  shape = event.target.parentElement.getAttribute("data-shape");
                  setMode("shape");
                }
              });
            document
              .getElementById("eraseModeScreen")
              .addEventListener("click", () => setMode("erase"));
            document
              .querySelector("#eraseModeScreen + .dropdown-menu")
              .addEventListener("click", (event) => {
                if (event.target.matches(".dropdown-item")) {
                  eraserThickness = parseInt(
                    event.target.getAttribute("data-thickness")
                  );
                  setMode("erase");
                }
              });
            document
              .getElementById("colorPickerScreen")
              .addEventListener("input", (e) => (color = e.target.value));
            document
              .getElementById("lineTypePickerScreen")
              .addEventListener("input", (e) => (lineType = e.target.value));

            document
              .getElementById("freehandModeScreen")
              .addEventListener("click", () => setMode("freehand"));

            // Event delegation for freehandMode dropdown items
            document
              .querySelector("#freehandModeScreen + .dropdown-menu")
              .addEventListener("click", (event) => {
                if (event.target.matches(".dropdown-item")) {
                  brushThickness = parseInt(
                    event.target.getAttribute("data-brush-thickness")
                  );
                  setMode("freehand");
                }
              });

            document
              .getElementById("toolbarToggleScreen")
              .addEventListener("click", function () {
                const toolbar = document.getElementById("toolbarScreen");
                if (
                  toolbar.style.display === "none" ||
                  toolbar.style.display === ""
                ) {
                  toolbar.style.display = "block";
                  this.innerHTML = '<i class="fas fa-chevron-right"></i>'; // Change icon to indicate collapse action
                } else {
                  toolbar.style.display = "none";
                  this.innerHTML = '<i class="fas fa-chevron-left"></i>'; // Change icon to indicate expand action
                }
              });

            async function updateAnnotateSupport() {
              annotateScreenStream = !annotateScreenStream;

              if (annotateScreenStream) {
                document.getElementById("annotateScreen").style.color = "red";
              } else {
                document.getElementById("annotateScreen").style.color = "green";
              }

              //hide/show the toolbar
              const toolbar = document.getElementById("toolbarScreen");
              const toolbarToggle = document.getElementById(
                "toolbarToggleScreen"
              );
              if (!annotateScreenStream) {
                toolbar.style.display = "none";
                toolbarToggle.style.display = "none";
              } else {
                toolbar.style.display = "block";
                toolbarToggle.style.display = "block";
              }

              if (annotateScreenStream) {
                try {
                  await $("#screenAnnotateModal").modal("show");
                  await sleep(500);
                  await $("#screenAnnotateModal").modal("hide");
                  await onScreenChanges(true);
                } catch (error) {}
              } else {
                try {
                  await $("#screenAnnotateModal").modal("show");
                  await sleep(500);
                  await $("#screenAnnotateModal").modal("hide");
                  await onScreenChanges(true);
                  shapes = [];
                } catch (error) {}
              }
            }

            document
              .getElementById("annotateScreen")
              .addEventListener("click", async () => {
                await updateAnnotateSupport();
              });

            canvas.addEventListener("mousedown", startDrawing);
            canvas.addEventListener("mousemove", draw);
            canvas.addEventListener("mouseup", stopDrawing);
            canvas.addEventListener("mouseout", stopDrawing);

            let refCanvasWidthHeight = { width: 100000, height: 100000 };
            let prevRefCanvasWidthHeight = { width: 100000, height: 100000 };

            function checkAndReDraw() {
              drawShapes();
            }

            document
              .getElementById("zoomResetScreen")
              .addEventListener("click", () => {
                checkAndReDraw();
              });

            function setMode(newMode) {
              mode = newMode;
              canvas.style.cursor =
                mode === "erase" ? "crosshair" : "crosshair";
              if (mode !== "freehand") {
                if (freehandDrawing.length > 0) {
                  shapes.push({
                    type: "freehand",
                    points: freehandDrawing,
                    color,
                    thickness: brushThickness,
                  });
                  freehandDrawing = [];
                }
              }
            }

            function startDrawing(e) {
              isDrawing = true;
              startX = e.offsetX;
              startY = e.offsetY;

              if (mode === "erase") {
                erase(startX, startY);
              } else if (mode === "draw" || mode === "freehand") {
                ctx.beginPath();
                ctx.moveTo(startX, startY);
                if (mode === "freehand") {
                  freehandDrawing.push({ x: startX, y: startY });
                }
              }
            }

            function draw(e) {
              if (!isDrawing) return;
              currentX = e.offsetX;
              currentY = e.offsetY;

              if (mode === "erase") {
                erase(currentX, currentY);
              } else if (mode === "draw") {
                ctx.clearRect(0, 0, canvas.width, canvas.height);
                drawShapes();
                drawLine(
                  startX,
                  startY,
                  currentX,
                  currentY,
                  color,
                  lineThickness,
                  lineType
                );
              } else if (mode === "freehand") {
                ctx.lineTo(currentX, currentY);
                ctx.strokeStyle = color;
                ctx.lineWidth = brushThickness;
                ctx.stroke();
                freehandDrawing.push({ x: currentX, y: currentY });
              } else if (mode === "shape") {
                ctx.clearRect(0, 0, canvas.width, canvas.height);
                drawShapes();
                drawShape(
                  shape,
                  startX,
                  startY,
                  currentX,
                  currentY,
                  color,
                  lineThickness,
                  lineType
                );
              }
            }

            function stopDrawing(e) {
              isDrawing = false;
              ctx.closePath();

              if (mode === "draw") {
                shapes.push({
                  type: "line",
                  x1: startX,
                  y1: startY,
                  x2: currentX,
                  y2: currentY,
                  color,
                  thickness: lineThickness,
                  lineType,
                });
              } else if (mode === "freehand") {
                shapes.push({
                  type: "freehand",
                  points: freehandDrawing,
                  color,
                  thickness: brushThickness,
                });
                freehandDrawing = [];
              } else if (mode === "shape") {
                shapes.push({
                  type: shape,
                  x1: startX,
                  y1: startY,
                  x2: currentX,
                  y2: currentY,
                  color,
                  thickness: lineThickness,
                  lineType,
                });
              }
              drawShapes();
              setTimeout(() => removeShape(), 15000);
            }

            function isPointNearLine(px, py, x1, y1, x2, y2, threshold) {
              const dx = x2 - x1;
              const dy = y2 - y1;
              const length = Math.sqrt(dx * dx + dy * dy);
              const dot = ((px - x1) * dx + (py - y1) * dy) / (length * length);
              const closestX = x1 + dot * dx;
              const closestY = y1 + dot * dy;
              const distance = Math.sqrt(
                Math.pow(px - closestX, 2) + Math.pow(py - closestY, 2)
              );
              return distance <= threshold;
            }

            function erase(x, y) {
              ctx.save();
              ctx.globalCompositeOperation = "destination-out";
              ctx.beginPath();
              ctx.arc(x, y, eraserThickness / 2, 0, Math.PI * 2, false);
              ctx.fill();
              ctx.restore();

              // Erase parts of shapes
              shapes = shapes
                .map((shape) => {
                  if (shape.type === "freehand") {
                    return {
                      ...shape,
                      points: shape.points.filter((point) => {
                        const distance = Math.sqrt(
                          Math.pow(point.x - x, 2) + Math.pow(point.y - y, 2)
                        );
                        return distance > eraserThickness / 2;
                      }),
                    };
                  } else if (shape.type === "line") {
                    if (
                      isPointNearLine(
                        x,
                        y,
                        shape.x1,
                        shape.y1,
                        shape.x2,
                        shape.y2,
                        eraserThickness / 2
                      )
                    ) {
                      return null;
                    }
                  } else if (shape.type === "text") {
                    const textWidth = ctx.measureText(shape.text).width;
                    if (
                      x > shape.x &&
                      x < shape.x + textWidth &&
                      y > shape.y - shape.fontSize &&
                      y < shape.y
                    ) {
                      return null;
                    }
                  } else {
                    if (
                      x > shape.x1 &&
                      x < shape.x2 &&
                      y > shape.y1 &&
                      y < shape.y2
                    ) {
                      return null;
                    }
                  }
                  return shape;
                })
                .filter(
                  (shape) =>
                    shape &&
                    (shape.type !== "freehand" || shape.points.length > 0)
                );

              drawShapes();
            }

            function drawShapes() {
              ctx.clearRect(0, 0, canvas.width, canvas.height); // Clear canvas before drawing
              shapes.forEach((shape) => {
                if (shape.type === "line") {
                  drawLine(
                    shape.x1,
                    shape.y1,
                    shape.x2,
                    shape.y2,
                    shape.color,
                    shape.thickness,
                    shape.lineType
                  );
                } else if (shape.type === "freehand") {
                  drawFreehand(shape.points, shape.color, shape.thickness);
                } else {
                  drawShape(
                    shape.type,
                    shape.x1,
                    shape.y1,
                    shape.x2,
                    shape.y2,
                    shape.color,
                    shape.thickness,
                    shape.lineType
                  );
                }
              });
            }

            function drawLine(x1, y1, x2, y2, color, thickness, lineType) {
              ctx.beginPath();
              ctx.strokeStyle = color;
              ctx.lineWidth = thickness;
              if (lineType === "dashed") {
                ctx.setLineDash([10, 10]);
              } else if (lineType === "dotted") {
                ctx.setLineDash([2, 10]);
              } else if (lineType === "dashDot") {
                ctx.setLineDash([10, 5, 2, 5]);
              } else {
                ctx.setLineDash([]);
              }
              ctx.moveTo(x1, y1);
              ctx.lineTo(x2, y2);
              ctx.stroke();
              ctx.setLineDash([]);
            }

            function drawFreehand(points, color, thickness) {
              if (points.length < 2) return;
              ctx.strokeStyle = color;
              ctx.lineWidth = thickness;
              ctx.beginPath();
              ctx.moveTo(points[0].x, points[0].y);
              for (let i = 1; i < points.length; i++) {
                ctx.lineTo(points[i].x, points[i].y);
              }
              ctx.stroke();
            }

            function drawPolygon(ctx, sides, x1, y1, x2, y2) {
              const centerX = (x1 + x2) / 2;
              const centerY = (y1 + y2) / 2;
              const radius = Math.min(Math.abs(x2 - x1), Math.abs(y2 - y1)) / 2;
              const angle = (2 * Math.PI) / sides;
              ctx.beginPath();
              for (let i = 0; i < sides; i++) {
                const x = centerX + radius * Math.cos(i * angle - Math.PI / 2);
                const y = centerY + radius * Math.sin(i * angle - Math.PI / 2);
                if (i === 0) {
                  ctx.moveTo(x, y);
                } else {
                  ctx.lineTo(x, y);
                }
              }
              ctx.closePath();
              ctx.stroke();
            }

            function drawShape(
              type,
              x1,
              y1,
              x2,
              y2,
              color,
              thickness,
              lineType
            ) {
              ctx.beginPath();
              ctx.strokeStyle = color;
              ctx.lineWidth = thickness;
              if (lineType === "dashed") {
                ctx.setLineDash([10, 10]);
              } else if (lineType === "dotted") {
                ctx.setLineDash([2, 10]);
              } else if (lineType === "dashDot") {
                ctx.setLineDash([10, 5, 2, 5]);
              } else {
                ctx.setLineDash([]);
              }
              if (type === "rectangle") {
                ctx.strokeRect(x1, y1, x2 - x1, y2 - y1);
              } else if (type === "circle") {
                const radius = Math.sqrt(
                  Math.pow(x2 - x1, 2) + Math.pow(y2 - y1, 2)
                );
                ctx.arc(x1, y1, radius, 0, 2 * Math.PI);
                ctx.stroke();
              } else if (type === "rhombus") {
                const centerX = (x1 + x2) / 2;
                const centerY = (y1 + y2) / 2;
                const halfWidth = Math.abs(x2 - x1) / 2;
                const halfHeight = Math.abs(y2 - y1) / 2;
                ctx.moveTo(centerX, y1);
                ctx.lineTo(x2, centerY);
                ctx.lineTo(centerX, y2);
                ctx.lineTo(x1, centerY);
                ctx.closePath();
                ctx.stroke();
              } else if (type === "pentagon") {
                drawPolygon(ctx, 5, x1, y1, x2, y2);
              } else if (type === "hexagon") {
                drawPolygon(ctx, 6, x1, y1, x2, y2);
              } else if (type === "triangle") {
                const centerXTriangle = (x1 + x2) / 2;
                ctx.moveTo(centerXTriangle, y1);
                ctx.lineTo(x2, y2);
                ctx.lineTo(x1, y2);
                ctx.closePath();
                ctx.stroke();
              } else if (type === "square") {
                ctx.strokeRect(x1, y1, x2 - x1, x2 - x1);
              } else if (type === "octagon") {
                drawPolygon(ctx, 8, x1, y1, x2, y2);
              } else if (type === "oval") {
                const radiusX = Math.abs(x2 - x1) / 2;
                const radiusY = Math.abs(y2 - y1) / 2;
                const centerX = (x1 + x2) / 2;
                const centerY = (y1 + y2) / 2;
                ctx.ellipse(
                  centerX,
                  centerY,
                  radiusX,
                  radiusY,
                  0,
                  0,
                  2 * Math.PI
                );
                ctx.stroke();
              } else if (type === "parallelogram") {
                const centerX = (x1 + x2) / 2;
                const centerY = (y1 + y2) / 2;
                ctx.moveTo(centerX, y1);
                ctx.lineTo(x2, y2);
                ctx.lineTo(centerX, y2);
                ctx.lineTo(x1, y1);
                ctx.closePath();
                ctx.stroke();
              }
              ctx.setLineDash([]);
            }

            function removeShape() {
              shapes.shift();
              drawShapes();
            }

            // Set transparent background for the canvas
            canvas.style.backgroundColor = "transparent";
            canvas.style.position = "absolute";
            canvas.style.top = 0;
            canvas.style.left = 0;

            setMode("draw"); // Initialize in draw mode
          }

          startScreenboard();

          let annotateScreenStream = false;
          let processedScreenStream = null;
          let mainScreenCanvas = null;

          async function addScreenAnnotateModal() {
            const screenVideo = document.querySelector("#screenVideo");
            let annotate = annotateScreenStream;
            const videoPreview = document.getElementById("screenPreview");
            let annotationInterval;

            let clonedStreamScreen = null;

            async function annotatationPreview() {
              if (!mainScreenCanvas) {
                // mainScreenCanvas = new OffscreenCanvas(1280, 720);
                mainScreenCanvas = document.getElementById("screenCanvas");
              }

              if (
                annotate &&
                (!clonedStreamScreen ||
                  (clonedStreamScreen &&
                    clonedStreamScreen.getVideoTracks().length > 0 &&
                    clonedStreamScreen.getVideoTracks()[0].readyState ==
                      "ended"))
              ) {
                const originalTrack = localStreamScreen.getVideoTracks()[0];
                const originalSettings = originalTrack.getSettings();

                const cloned = await originalTrack.clone();
                cloned.applyConstraints({
                  width: originalSettings.width,
                  height: originalSettings.height,
                  frameRate: originalSettings.frameRate,
                  aspectRatio: originalSettings.aspectRatio,
                });

                clonedStreamScreen = new MediaStream([cloned]);
              }

              if (
                clonedStreamScreen &&
                localStreamScreen &&
                localStreamScreen.getVideoTracks().length > 0 &&
                localStreamScreen.getVideoTracks()[0].readyState == "ended"
              ) {
                //remove the video track
                await localStreamScreen.removeTrack(
                  localStreamScreen.getVideoTracks()[0]
                );
                await localStreamScreen.addTrack(
                  clonedStreamScreen.getVideoTracks()[0].clone()
                );
              }

              if (clonedStreamScreen) {
                clonedStreamScreen.getVideoTracks()[0].onended =
                  async function () {
                    //supports both manual and automatic screen share end
                    await disconnectSendTransportScreen();
                    await stopShareScreen();
                  };
              }

              mainScreenCanvas.width = await localStreamScreen
                .getVideoTracks()[0]
                .getSettings().width;
              mainScreenCanvas.height = await localStreamScreen
                .getVideoTracks()[0]
                .getSettings().height;
              const mediaCanvas = mainScreenCanvas;
              const ctx = mediaCanvas.getContext("2d");

              if (!annotate) {
                // Just show the video
                processedScreenStream = null;
              }

              //get a video with the id screenId
              let videoScreenID = screenId ? screenId : "localScreenShare";
              let videoScreen = document.getElementById(videoScreenID);

              annotateVideo = clonedStreamScreen;
              if (annotateVideo && annotate) {
                // Create a new video element to display the screen share stream
                screenVideo.style.width =
                  annotateVideo.getVideoTracks()[0].getSettings().width + "px";
                screenVideo.style.height =
                  annotateVideo.getVideoTracks()[0].getSettings().height + "px";
                screenVideo.srcObject = annotateVideo;
                await annotateImage(annotateVideo.getVideoTracks()[0]);
              }

              let canvasElement = document.getElementById("screenboardCanvas");
              canvasElement.width = mediaCanvas.width;
              canvasElement.height = mediaCanvas.height;

              function drawCombined() {
                // Clear the entire canvas
                ctx.clearRect(0, 0, canvasElement.width, canvasElement.height);

                // Draw the video content onto the target canvas without scaling
                ctx.drawImage(
                  screenVideo,
                  0,
                  0,
                  canvasElement.width,
                  canvasElement.height
                );

                // Draw the annotation canvas on top of the video content
                ctx.drawImage(
                  canvasElement,
                  0,
                  0,
                  canvasElement.width,
                  canvasElement.height
                );

                // Restore the context state to avoid affecting subsequent drawings
                ctx.restore();
              }

              function captureStream(videoTrack) {
                const stream = mediaCanvas.captureStream(30); // 30 FPS
                annotationInterval = setInterval(() => {
                  drawCombined(videoTrack);
                }, 30);

                return stream;
              }

              async function annotateImage(videoTrack) {
                processedScreenStream = await captureStream(videoTrack);
              }
            }

            function stopAnnotation() {
              if (annotationInterval) {
                clearInterval(annotationInterval);
                annotationInterval = null;
              }

              if (processedScreenStream) {
                processedScreenStream
                  .getTracks()
                  .forEach((track) => track.stop());
                processedScreenStream = null;
              }

              if (mainScreenCanvas) {
                mainScreenCanvas
                  .getContext("2d")
                  .clearRect(
                    0,
                    0,
                    mainScreenCanvas.width,
                    mainScreenCanvas.height
                  );
              }
            }

            // Show the screen annotate modal
            $("#screenAnnotateModal").on("show.bs.modal", async function () {
              annotate = annotateScreenStream;
              try {
                if (annotate && shared) {
                  screenVideo.classList.remove("d-none");
                  await annotatationPreview();
                  if (!transportCreated) {
                    await createSendTransport("screen");
                    // await socket.emit('annotateScreen', { annotate: true, roomName: roomName, member }, (data) => {
                    // });
                  } else {
                    try {
                      if (
                        localStreamScreen.getVideoTracks().length > 0 &&
                        localStreamScreen.getVideoTracks()[0].id ==
                          screenProducer.track.id
                      ) {
                        if (
                          clonedStreamScreen &&
                          clonedStreamScreen.getVideoTracks().length > 0 &&
                          clonedStreamScreen.getVideoTracks()[0].readyState ==
                            "ended"
                        ) {
                          clonedStreamScreen.removeTrack(
                            clonedStreamScreen.getVideoTracks()[0]
                          );
                          clonedStreamScreen.addTrack(
                            localStreamScreen.getVideoTracks()[0].clone()
                          );
                        }
                        localStreamScreen.removeTrack(
                          localStreamScreen.getVideoTracks()[0]
                        );
                        localStreamScreen.addTrack(
                          clonedStreamScreen.getVideoTracks()[0].clone()
                        );
                      }
                      await disconnectSendTransportScreen();
                      if (p_sockets.length > 0) {
                        try {
                          await disconnectSendTransportScreen(true);
                        } catch (error) {}
                      }
                      await sleep(250);
                    } catch (error) {}

                    await connectSendTransportScreen(processedScreenStream);
                    if (p_sockets.length > 0) {
                      try {
                        await connectSendTransportScreen(
                          processedScreenStream,
                          true
                        );
                      } catch (error) {}
                    }
                  }
                  await prepopulateUserMedia(hostLabel);
                } else {
                  screenVideo.classList.add("d-none");
                }
              } catch (error) {}
            });

            $("#screenAnnotateModal").on("hide.bs.modal", async function () {
              // Hide the screen removal modal
              // stop the video stream
              annotate = annotateScreenStream;

              try {
                if (!annotate) {
                  try {
                    await stopAnnotation();
                  } catch (error) {}

                  if (shared) {
                    if (!transportCreated) {
                      await createSendTransport("screen");
                      if (p_sockets.length > 0) {
                        try {
                          await createSendTransport("screen", true);
                        } catch (error) {}
                      }
                    } else {
                      try {
                        await disconnectSendTransportScreen();
                        await sleep(500);
                      } catch (error) {}

                      if (p_sockets.length > 0) {
                        try {
                          await disconnectSendTransportScreen(true);
                        } catch (error) {}
                      }

                      if (
                        localStreamScreen &&
                        localStreamScreen.getVideoTracks().length > 0 &&
                        localStreamScreen.getVideoTracks()[0].readyState ==
                          "ended"
                      ) {
                        localStreamScreen.removeTrack(
                          localStreamScreen.getVideoTracks()[0]
                        );
                        localStreamScreen.addTrack(
                          clonedStreamScreen.getVideoTracks()[0].clone()
                        );
                      }

                      clonedStreamScreen.getVideoTracks()[0].onended =
                        async function () {
                          //supports both manual and automatic screen share end
                          await disconnectSendTransportScreen();
                          if (p_sockets.length > 0) {
                            try {
                              await disconnectSendTransportScreen(true);
                            } catch (error) {}
                          }
                          await stopShareScreen();
                        };

                      await connectSendTransportScreen(localStreamScreen);
                      if (p_sockets.length > 0) {
                        try {
                          await connectSendTransportScreen(
                            localStreamScreen,
                            true
                          );
                        } catch (error) {}
                      }
                    }
                  } else {
                    //close all the tracks
                    try {
                      if (
                        localStreamScreen &&
                        localStreamScreen.getVideoTracks().length > 0
                      ) {
                        localStreamScreen.getVideoTracks().forEach((track) => {
                          track.stop();
                        });
                      }
                    } catch (error) {}

                    try {
                      if (
                        clonedStreamScreen &&
                        clonedStreamScreen.getVideoTracks().length > 0
                      ) {
                        clonedStreamScreen.getVideoTracks().forEach((track) => {
                          track.stop();
                        });
                      }
                    } catch (error) {}

                    try {
                      if (processedScreenStream) {
                        processedScreenStream.getTracks().forEach((track) => {
                          track.stop();
                        });
                      }
                    } catch (error) {}

                    captureScreenStream = null;
                    clonedStreamScreen = null;
                  }
                  await prepopulateUserMedia(hostLabel);
                }
                await screenVideo.classList.add("d-none");
                if (mainScreenCanvas) {
                  // make visibility of the canvas to hidden
                  $("#screenCanvas").hide();
                }
              } catch (error) {
                // console.log(error, 'Error stopping the video stream');
              }
            });
          }
          addScreenAnnotateModal();

          function getCookie(name) {
            const value = `; ${document.cookie}`;
            const parts = value.split(`; ${name}=`);
            if (parts.length === 2) return parts.pop().split(";").shift();
          }

          try {
            const userVideoDevice = getCookie("videoDevice");
            const userAudioDevice = getCookie("audioDevice");
            const userUseBackground = getCookie("useBackground");
            const userbackgroundSrc = getCookie("backgroundSrc");
            const facingMode = getCookie("facingMode");

            if (userUseBackground == "true") {
              keepBackground = true;
              appliedBackground = true;
              selectedImage =
                userbackgroundSrc || "/images/backgrounds/wall.png";
            }

            if (facingMode) {
              currentFacingMode = facingMode;
            }
          } catch (error) {}
        }

        // Utility function to pad single-digit numbers with leading zeros
        function padNumber(number) {
          return number.toString().padStart(2, "0");
        }

        // Format the time in HH:MM:SS format
        function formatTime(time) {
          const hours = Math.floor(time / 3600);
          const minutes = Math.floor((time % 3600) / 60);
          const seconds = (time % 60).toFixed(0).padStart(2, "0"); // Use toFixed(0) to remove decimal places

          return (
            padNumber(hours) +
            ":" +
            padNumber(minutes) +
            ":" +
            padNumber(seconds)
          );
        }

        // Calculate the elapsed time based on the start time
        function calculateElapsedTime(startTime) {
          const currentTime = Math.floor(new Date().getTime() / 1000);
          return currentTime - startTime;
        }

        // Start the meeting progress timer with a custom start time
        function startMeetingProgressTimer(startTime) {
          //function to start the meeting progress timer with a custom start time

          const progressTimer = $("#meetingProgressTimer");

          let elapsedTime = calculateElapsedTime(startTime);

          // Update the timer and indicator every second
          setInterval(() => {
            elapsedTime++;
            const formattedTime = formatTime(elapsedTime);
            progressTimer.text(formattedTime);
          }, 1000);
        }

        // Hide the spinner modal
        async function hideLoadingModal() {
          //function to hide the loading modal
          if (loadingModal) {
            await $("#loadingModal").modal("hide");
            await $(".mediasfu").show();
            await $("#subAspect").show();

            loadingModal = false;

            setTimeout(() => {
              //check if the modal is still open and hide it
              if ($("#loadingModal").hasClass("show")) {
                $("#loadingModal").modal("hide");
                loadingModal = false;
              }
            }, 500);

            // start the meeting progress timer with a custom start time
            startMeetingProgressTimer(Date.now() / 1000);
          }
        }

        function disconnectSocket() {
          // Function to disconnect the socket
          if (socket) {
            socket.close();
          }
        }

        // Attach the initializeSocket function to the window.onload event
        window.onload = initializeSocket;

        // Attach the disconnectSocket function to the beforeunload event
        window.addEventListener("beforeunload", disconnectSocket);
      },
      { "mediasoup-client": 68, "socket.io-client": 83 },
    ],
  },
  {},
  [98]
);
